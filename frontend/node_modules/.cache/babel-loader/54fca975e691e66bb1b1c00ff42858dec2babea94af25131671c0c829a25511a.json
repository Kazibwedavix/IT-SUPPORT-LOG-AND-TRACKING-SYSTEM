{"ast":null,"code":"/**\r\n * Authentication Service\r\n * \r\n * Enterprise-grade authentication service with comprehensive\r\n * error handling, security features, and production monitoring.\r\n * \r\n * Features:\r\n * - JWT token management\r\n * - Session handling\r\n * - Password management\r\n * - Security event tracking\r\n * - Request/response interceptors\r\n * - Rate limiting awareness\r\n * - Audit logging\r\n * \r\n * @version 3.0.0\r\n * @author IT Support Team\r\n */\nimport api from './api';\n\n// Security event tracking\nconst logSecurityEvent = (eventType, data = {}) => {\n  const event = {\n    timestamp: new Date().toISOString(),\n    event: eventType,\n    ...data,\n    userAgent: navigator.userAgent\n  };\n\n  // Development logging\n  if (process.env.NODE_ENV === 'development') {\n    console.log('ðŸ” Security Event:', event);\n  }\n\n  // Send to security monitoring (implement in production)\n  sendToSecurityMonitoring(event);\n};\n\n// Send to security monitoring service\nconst sendToSecurityMonitoring = event => {\n  try {\n    // Store events locally for debugging (remove in production)\n    const existingEvents = JSON.parse(localStorage.getItem('auth_security_events') || '[]');\n    existingEvents.push(event);\n\n    // Keep only last 100 events\n    if (existingEvents.length > 100) {\n      existingEvents.shift();\n    }\n    localStorage.setItem('auth_security_events', JSON.stringify(existingEvents));\n  } catch (e) {\n    // Silently fail if localStorage is not available\n  }\n};\n\n// Request interceptor for adding auth token\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n  if (token && config.url.includes('/auth/')) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n\n  // Add request timestamp for monitoring\n  config.metadata = {\n    startTime: Date.now()\n  };\n  return config;\n}, error => {\n  logSecurityEvent('request_interceptor_error', {\n    error: error.message\n  });\n  return Promise.reject(error);\n});\n\n// Response interceptor for monitoring and error handling\napi.interceptors.response.use(response => {\n  // Log successful auth requests\n  if (response.config.url.includes('/auth/')) {\n    var _response$config$meta;\n    const duration = Date.now() - (((_response$config$meta = response.config.metadata) === null || _response$config$meta === void 0 ? void 0 : _response$config$meta.startTime) || Date.now());\n    logSecurityEvent('auth_request_success', {\n      endpoint: response.config.url,\n      method: response.config.method,\n      duration: `${duration}ms`\n    });\n  }\n  return response;\n}, error => {\n  var _error$config, _error$config$url;\n  // Log auth request failures\n  if ((_error$config = error.config) !== null && _error$config !== void 0 && (_error$config$url = _error$config.url) !== null && _error$config$url !== void 0 && _error$config$url.includes('/auth/')) {\n    var _error$response;\n    logSecurityEvent('auth_request_failed', {\n      endpoint: error.config.url,\n      method: error.config.method,\n      status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status,\n      error: error.message\n    });\n  }\n\n  // Handle specific error cases\n  if (error.response) {\n    const {\n      status,\n      data\n    } = error.response;\n    switch (status) {\n      case 401:\n        // Unauthorized - token invalid or expired\n        logSecurityEvent('auth_unauthorized', {\n          endpoint: error.config.url,\n          message: data.message || 'Authentication required'\n        });\n        break;\n      case 403:\n        // Forbidden - insufficient permissions\n        logSecurityEvent('auth_forbidden', {\n          endpoint: error.config.url,\n          message: data.message || 'Insufficient permissions'\n        });\n        break;\n      case 429:\n        // Rate limited\n        logSecurityEvent('auth_rate_limited', {\n          endpoint: error.config.url,\n          retryAfter: error.response.headers['retry-after']\n        });\n        break;\n      case 500:\n        // Server error\n        logSecurityEvent('auth_server_error', {\n          endpoint: error.config.url,\n          message: 'Internal server error'\n        });\n        break;\n    }\n  } else if (error.request) {\n    var _error$config2;\n    // Network error\n    logSecurityEvent('auth_network_error', {\n      endpoint: (_error$config2 = error.config) === null || _error$config2 === void 0 ? void 0 : _error$config2.url,\n      message: 'Network connection failed'\n    });\n  }\n  return Promise.reject(error);\n});\nconst authService = {\n  /**\r\n   * User login with credentials\r\n   * \r\n   * @param {string} email - User email\r\n   * @param {string} password - User password\r\n   * @returns {Promise<Object>} Authentication response\r\n   */\n  login: async (email, password) => {\n    try {\n      logSecurityEvent('login_attempt', {\n        email\n      });\n      const response = await api.post('/auth/login', {\n        email: email.toLowerCase().trim(),\n        password: password.trim()\n      });\n      const {\n        user,\n        token,\n        expiresIn\n      } = response.data;\n\n      // Validate response\n      if (!user || !token) {\n        throw new Error('Invalid login response from server');\n      }\n\n      // Log successful login\n      logSecurityEvent('login_success', {\n        userId: user._id,\n        email: user.email,\n        role: user.role\n      });\n      return {\n        user,\n        token,\n        expiresIn\n      };\n    } catch (error) {\n      var _error$response2, _error$response2$data, _error$response3, _error$response3$data;\n      // Log failed login\n      logSecurityEvent('login_failed', {\n        email,\n        error: ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || error.message\n      });\n\n      // Re-throw with user-friendly message\n      const errorMessage = ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Login failed. Please check your credentials.';\n      throw new Error(errorMessage);\n    }\n  },\n  /**\r\n   * User registration\r\n   * \r\n   * @param {Object} userData - User registration data\r\n   * @returns {Promise<Object>} Registration response\r\n   */\n  register: async userData => {\n    try {\n      var _userData$department, _userData$phone;\n      logSecurityEvent('registration_attempt', {\n        email: userData.email\n      });\n\n      // Validate required fields\n      const requiredFields = ['name', 'email', 'password', 'role'];\n      const missingFields = requiredFields.filter(field => !userData[field]);\n      if (missingFields.length > 0) {\n        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n      }\n\n      // Sanitize user data\n      const sanitizedData = {\n        name: userData.name.trim(),\n        email: userData.email.toLowerCase().trim(),\n        password: userData.password.trim(),\n        role: userData.role.toLowerCase(),\n        department: ((_userData$department = userData.department) === null || _userData$department === void 0 ? void 0 : _userData$department.trim()) || '',\n        phone: ((_userData$phone = userData.phone) === null || _userData$phone === void 0 ? void 0 : _userData$phone.trim()) || ''\n      };\n      const response = await api.post('/auth/register', sanitizedData);\n      const {\n        user,\n        token,\n        expiresIn\n      } = response.data;\n\n      // Validate response\n      if (!user || !token) {\n        throw new Error('Invalid registration response from server');\n      }\n\n      // Log successful registration\n      logSecurityEvent('registration_success', {\n        userId: user._id,\n        email: user.email,\n        role: user.role\n      });\n      return {\n        user,\n        token,\n        expiresIn\n      };\n    } catch (error) {\n      var _error$response4, _error$response4$data, _error$response5, _error$response5$data;\n      // Log failed registration\n      logSecurityEvent('registration_failed', {\n        email: userData.email,\n        error: ((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || error.message\n      });\n\n      // Re-throw with user-friendly message\n      const errorMessage = ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.message) || 'Registration failed. Please try again.';\n      throw new Error(errorMessage);\n    }\n  },\n  /**\r\n   * Get current authenticated user\r\n   * \r\n   * @returns {Promise<Object>} Current user data\r\n   */\n  getCurrentUser: async () => {\n    try {\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n      if (!token) {\n        throw new Error('No authentication token found');\n      }\n      const response = await api.get('/auth/me', {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      const user = response.data;\n\n      // Validate user data\n      if (!user || !user._id || !user.email || !user.role) {\n        throw new Error('Invalid user data received');\n      }\n      return user;\n    } catch (error) {\n      var _error$response6;\n      logSecurityEvent('get_current_user_failed', {\n        error: error.message\n      });\n\n      // Clear invalid token\n      if (((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status) === 401) {\n        localStorage.removeItem('token');\n        sessionStorage.removeItem('token');\n        localStorage.removeItem('user');\n      }\n      throw error;\n    }\n  },\n  /**\r\n   * Refresh authentication token\r\n   * \r\n   * @returns {Promise<Object>} New token and user data\r\n   */\n  refreshToken: async () => {\n    try {\n      logSecurityEvent('token_refresh_attempt');\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n      if (!token) {\n        throw new Error('No token available for refresh');\n      }\n      const response = await api.post('/auth/refresh-token', {}, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      const {\n        user,\n        token: newToken,\n        expiresIn\n      } = response.data;\n      if (!newToken || !user) {\n        throw new Error('Invalid token refresh response');\n      }\n      logSecurityEvent('token_refresh_success', {\n        userId: user._id\n      });\n      return {\n        user,\n        token: newToken,\n        expiresIn\n      };\n    } catch (error) {\n      logSecurityEvent('token_refresh_failed', {\n        error: error.message\n      });\n\n      // Clear invalid tokens\n      localStorage.removeItem('token');\n      sessionStorage.removeItem('token');\n      throw error;\n    }\n  },\n  /**\r\n   * Verify session validity\r\n   * \r\n   * @returns {Promise<Object>} Session verification result\r\n   */\n  verifySession: async () => {\n    try {\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n      if (!token) {\n        return {\n          valid: false,\n          reason: 'No token found'\n        };\n      }\n      const response = await api.get('/auth/verify-session', {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      return {\n        valid: true,\n        user: response.data.user,\n        expiresAt: response.data.expiresAt\n      };\n    } catch (error) {\n      var _error$response7;\n      return {\n        valid: false,\n        reason: ((_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : _error$response7.status) === 401 ? 'Token expired' : 'Verification failed'\n      };\n    }\n  },\n  /**\r\n   * Update user profile\r\n   * \r\n   * @param {Object} updates - Profile updates\r\n   * @returns {Promise<Object>} Updated user data\r\n   */\n  updateProfile: async updates => {\n    try {\n      logSecurityEvent('profile_update_attempt', {\n        updates: Object.keys(updates)\n      });\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n\n      // Validate updates\n      const allowedUpdates = ['name', 'email', 'phone', 'department', 'avatar'];\n      const invalidUpdates = Object.keys(updates).filter(key => !allowedUpdates.includes(key));\n      if (invalidUpdates.length > 0) {\n        throw new Error(`Invalid update fields: ${invalidUpdates.join(', ')}`);\n      }\n      const response = await api.put('/auth/profile', updates, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      logSecurityEvent('profile_update_success', {\n        fields: Object.keys(updates)\n      });\n      return response.data;\n    } catch (error) {\n      logSecurityEvent('profile_update_failed', {\n        error: error.message,\n        updates: Object.keys(updates)\n      });\n      throw error;\n    }\n  },\n  /**\r\n   * Change user password\r\n   * \r\n   * @param {string} currentPassword - Current password\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  changePassword: async (currentPassword, newPassword) => {\n    try {\n      logSecurityEvent('password_change_attempt');\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n\n      // Validate password strength\n      if (newPassword.length < 8) {\n        throw new Error('New password must be at least 8 characters long');\n      }\n      const response = await api.put('/auth/change-password', {\n        currentPassword: currentPassword.trim(),\n        newPassword: newPassword.trim()\n      }, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      logSecurityEvent('password_change_success');\n      return response.data;\n    } catch (error) {\n      logSecurityEvent('password_change_failed', {\n        error: error.message\n      });\n      throw error;\n    }\n  },\n  /**\r\n   * Request password reset\r\n   * \r\n   * @param {string} email - User email\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  requestPasswordReset: async email => {\n    try {\n      logSecurityEvent('password_reset_request', {\n        email\n      });\n      const response = await api.post('/auth/request-password-reset', {\n        email: email.toLowerCase().trim()\n      });\n      logSecurityEvent('password_reset_request_success', {\n        email\n      });\n      return response.data;\n    } catch (error) {\n      logSecurityEvent('password_reset_request_failed', {\n        email,\n        error: error.message\n      });\n\n      // Don't reveal if email exists or not\n      throw new Error('If an account exists with this email, you will receive reset instructions.');\n    }\n  },\n  /**\r\n   * Reset password with token\r\n   * \r\n   * @param {string} token - Reset token\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  resetPassword: async (token, newPassword) => {\n    try {\n      logSecurityEvent('password_reset_attempt', {\n        token: token.substring(0, 10) + '...'\n      });\n      if (newPassword.length < 8) {\n        throw new Error('Password must be at least 8 characters long');\n      }\n      const response = await api.post('/auth/reset-password', {\n        token: token.trim(),\n        newPassword: newPassword.trim()\n      });\n      logSecurityEvent('password_reset_success');\n      return response.data;\n    } catch (error) {\n      logSecurityEvent('password_reset_failed', {\n        error: error.message\n      });\n      throw error;\n    }\n  },\n  /**\r\n   * Logout from all devices\r\n   * \r\n   * @returns {Promise<Object>} Success response\r\n   */\n  logoutAllDevices: async () => {\n    try {\n      logSecurityEvent('logout_all_devices_attempt');\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n      const response = await api.post('/auth/logout-all', {}, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      logSecurityEvent('logout_all_devices_success');\n      return response.data;\n    } catch (error) {\n      logSecurityEvent('logout_all_devices_failed', {\n        error: error.message\n      });\n      throw error;\n    }\n  },\n  /**\r\n   * Get user activity logs\r\n   * \r\n   * @param {Object} filters - Activity filters\r\n   * @returns {Promise<Array>} Activity logs\r\n   */\n  getActivityLogs: async (filters = {}) => {\n    try {\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n      const params = new URLSearchParams();\n      Object.keys(filters).forEach(key => {\n        if (filters[key] !== undefined && filters[key] !== null) {\n          params.append(key, filters[key]);\n        }\n      });\n      const response = await api.get(`/auth/activity-logs?${params}`, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      logSecurityEvent('activity_logs_failed', {\n        error: error.message\n      });\n      throw error;\n    }\n  },\n  /**\r\n   * Get login sessions\r\n   * \r\n   * @returns {Promise<Array>} Active sessions\r\n   */\n  getSessions: async () => {\n    try {\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n      const response = await api.get('/auth/sessions', {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      logSecurityEvent('get_sessions_failed', {\n        error: error.message\n      });\n      throw error;\n    }\n  },\n  /**\r\n   * Revoke a specific session\r\n   * \r\n   * @param {string} sessionId - Session ID to revoke\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  revokeSession: async sessionId => {\n    try {\n      logSecurityEvent('revoke_session_attempt', {\n        sessionId\n      });\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n      const response = await api.delete(`/auth/sessions/${sessionId}`, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      logSecurityEvent('revoke_session_success', {\n        sessionId\n      });\n      return response.data;\n    } catch (error) {\n      logSecurityEvent('revoke_session_failed', {\n        sessionId,\n        error: error.message\n      });\n      throw error;\n    }\n  },\n  /**\r\n   * Validate authentication token\r\n   * \r\n   * @param {string} token - Token to validate\r\n   * @returns {Promise<Object>} Validation result\r\n   */\n  validateToken: async token => {\n    try {\n      const response = await api.post('/auth/validate-token', {\n        token\n      });\n      return response.data;\n    } catch (error) {\n      return {\n        valid: false,\n        error: error.message\n      };\n    }\n  },\n  /**\r\n   * Clear all security events (for testing/debugging)\r\n   */\n  clearSecurityEvents: () => {\n    localStorage.removeItem('auth_security_events');\n  },\n  /**\r\n   * Get security events (for debugging)\r\n   */\n  getSecurityEvents: () => {\n    try {\n      return JSON.parse(localStorage.getItem('auth_security_events') || '[]');\n    } catch (e) {\n      return [];\n    }\n  }\n};\nexport default authService;","map":{"version":3,"names":["api","logSecurityEvent","eventType","data","event","timestamp","Date","toISOString","userAgent","navigator","process","env","NODE_ENV","console","log","sendToSecurityMonitoring","existingEvents","JSON","parse","localStorage","getItem","push","length","shift","setItem","stringify","e","interceptors","request","use","config","token","sessionStorage","url","includes","headers","Authorization","metadata","startTime","now","error","message","Promise","reject","response","_response$config$meta","duration","endpoint","method","_error$config","_error$config$url","_error$response","status","retryAfter","_error$config2","authService","login","email","password","post","toLowerCase","trim","user","expiresIn","Error","userId","_id","role","_error$response2","_error$response2$data","_error$response3","_error$response3$data","errorMessage","register","userData","_userData$department","_userData$phone","requiredFields","missingFields","filter","field","join","sanitizedData","name","department","phone","_error$response4","_error$response4$data","_error$response5","_error$response5$data","getCurrentUser","get","_error$response6","removeItem","refreshToken","newToken","verifySession","valid","reason","expiresAt","_error$response7","updateProfile","updates","Object","keys","allowedUpdates","invalidUpdates","key","put","fields","changePassword","currentPassword","newPassword","requestPasswordReset","resetPassword","substring","logoutAllDevices","getActivityLogs","filters","params","URLSearchParams","forEach","undefined","append","getSessions","revokeSession","sessionId","delete","validateToken","clearSecurityEvents","getSecurityEvents"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/services/authService.js"],"sourcesContent":["/**\r\n * Authentication Service\r\n * \r\n * Enterprise-grade authentication service with comprehensive\r\n * error handling, security features, and production monitoring.\r\n * \r\n * Features:\r\n * - JWT token management\r\n * - Session handling\r\n * - Password management\r\n * - Security event tracking\r\n * - Request/response interceptors\r\n * - Rate limiting awareness\r\n * - Audit logging\r\n * \r\n * @version 3.0.0\r\n * @author IT Support Team\r\n */\r\nimport api from './api';\r\n\r\n// Security event tracking\r\nconst logSecurityEvent = (eventType, data = {}) => {\r\n  const event = {\r\n    timestamp: new Date().toISOString(),\r\n    event: eventType,\r\n    ...data,\r\n    userAgent: navigator.userAgent\r\n  };\r\n\r\n  // Development logging\r\n  if (process.env.NODE_ENV === 'development') {\r\n    console.log('ðŸ” Security Event:', event);\r\n  }\r\n\r\n  // Send to security monitoring (implement in production)\r\n  sendToSecurityMonitoring(event);\r\n};\r\n\r\n// Send to security monitoring service\r\nconst sendToSecurityMonitoring = (event) => {\r\n  try {\r\n    // Store events locally for debugging (remove in production)\r\n    const existingEvents = JSON.parse(localStorage.getItem('auth_security_events') || '[]');\r\n    existingEvents.push(event);\r\n    \r\n    // Keep only last 100 events\r\n    if (existingEvents.length > 100) {\r\n      existingEvents.shift();\r\n    }\r\n    \r\n    localStorage.setItem('auth_security_events', JSON.stringify(existingEvents));\r\n  } catch (e) {\r\n    // Silently fail if localStorage is not available\r\n  }\r\n};\r\n\r\n// Request interceptor for adding auth token\r\napi.interceptors.request.use(\r\n  (config) => {\r\n    const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n    \r\n    if (token && config.url.includes('/auth/')) {\r\n      config.headers.Authorization = `Bearer ${token}`;\r\n    }\r\n    \r\n    // Add request timestamp for monitoring\r\n    config.metadata = { startTime: Date.now() };\r\n    \r\n    return config;\r\n  },\r\n  (error) => {\r\n    logSecurityEvent('request_interceptor_error', { error: error.message });\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Response interceptor for monitoring and error handling\r\napi.interceptors.response.use(\r\n  (response) => {\r\n    // Log successful auth requests\r\n    if (response.config.url.includes('/auth/')) {\r\n      const duration = Date.now() - (response.config.metadata?.startTime || Date.now());\r\n      logSecurityEvent('auth_request_success', {\r\n        endpoint: response.config.url,\r\n        method: response.config.method,\r\n        duration: `${duration}ms`\r\n      });\r\n    }\r\n    \r\n    return response;\r\n  },\r\n  (error) => {\r\n    // Log auth request failures\r\n    if (error.config?.url?.includes('/auth/')) {\r\n      logSecurityEvent('auth_request_failed', {\r\n        endpoint: error.config.url,\r\n        method: error.config.method,\r\n        status: error.response?.status,\r\n        error: error.message\r\n      });\r\n    }\r\n    \r\n    // Handle specific error cases\r\n    if (error.response) {\r\n      const { status, data } = error.response;\r\n      \r\n      switch (status) {\r\n        case 401:\r\n          // Unauthorized - token invalid or expired\r\n          logSecurityEvent('auth_unauthorized', {\r\n            endpoint: error.config.url,\r\n            message: data.message || 'Authentication required'\r\n          });\r\n          break;\r\n          \r\n        case 403:\r\n          // Forbidden - insufficient permissions\r\n          logSecurityEvent('auth_forbidden', {\r\n            endpoint: error.config.url,\r\n            message: data.message || 'Insufficient permissions'\r\n          });\r\n          break;\r\n          \r\n        case 429:\r\n          // Rate limited\r\n          logSecurityEvent('auth_rate_limited', {\r\n            endpoint: error.config.url,\r\n            retryAfter: error.response.headers['retry-after']\r\n          });\r\n          break;\r\n          \r\n        case 500:\r\n          // Server error\r\n          logSecurityEvent('auth_server_error', {\r\n            endpoint: error.config.url,\r\n            message: 'Internal server error'\r\n          });\r\n          break;\r\n      }\r\n    } else if (error.request) {\r\n      // Network error\r\n      logSecurityEvent('auth_network_error', {\r\n        endpoint: error.config?.url,\r\n        message: 'Network connection failed'\r\n      });\r\n    }\r\n    \r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nconst authService = {\r\n  /**\r\n   * User login with credentials\r\n   * \r\n   * @param {string} email - User email\r\n   * @param {string} password - User password\r\n   * @returns {Promise<Object>} Authentication response\r\n   */\r\n  login: async (email, password) => {\r\n    try {\r\n      logSecurityEvent('login_attempt', { email });\r\n      \r\n      const response = await api.post('/auth/login', { \r\n        email: email.toLowerCase().trim(),\r\n        password: password.trim()\r\n      });\r\n      \r\n      const { user, token, expiresIn } = response.data;\r\n      \r\n      // Validate response\r\n      if (!user || !token) {\r\n        throw new Error('Invalid login response from server');\r\n      }\r\n      \r\n      // Log successful login\r\n      logSecurityEvent('login_success', { \r\n        userId: user._id, \r\n        email: user.email,\r\n        role: user.role \r\n      });\r\n      \r\n      return {\r\n        user,\r\n        token,\r\n        expiresIn\r\n      };\r\n    } catch (error) {\r\n      // Log failed login\r\n      logSecurityEvent('login_failed', { \r\n        email,\r\n        error: error.response?.data?.message || error.message \r\n      });\r\n      \r\n      // Re-throw with user-friendly message\r\n      const errorMessage = error.response?.data?.message || \r\n                          'Login failed. Please check your credentials.';\r\n      \r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * User registration\r\n   * \r\n   * @param {Object} userData - User registration data\r\n   * @returns {Promise<Object>} Registration response\r\n   */\r\n  register: async (userData) => {\r\n    try {\r\n      logSecurityEvent('registration_attempt', { email: userData.email });\r\n      \r\n      // Validate required fields\r\n      const requiredFields = ['name', 'email', 'password', 'role'];\r\n      const missingFields = requiredFields.filter(field => !userData[field]);\r\n      \r\n      if (missingFields.length > 0) {\r\n        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\r\n      }\r\n      \r\n      // Sanitize user data\r\n      const sanitizedData = {\r\n        name: userData.name.trim(),\r\n        email: userData.email.toLowerCase().trim(),\r\n        password: userData.password.trim(),\r\n        role: userData.role.toLowerCase(),\r\n        department: userData.department?.trim() || '',\r\n        phone: userData.phone?.trim() || ''\r\n      };\r\n      \r\n      const response = await api.post('/auth/register', sanitizedData);\r\n      \r\n      const { user, token, expiresIn } = response.data;\r\n      \r\n      // Validate response\r\n      if (!user || !token) {\r\n        throw new Error('Invalid registration response from server');\r\n      }\r\n      \r\n      // Log successful registration\r\n      logSecurityEvent('registration_success', { \r\n        userId: user._id, \r\n        email: user.email,\r\n        role: user.role \r\n      });\r\n      \r\n      return {\r\n        user,\r\n        token,\r\n        expiresIn\r\n      };\r\n    } catch (error) {\r\n      // Log failed registration\r\n      logSecurityEvent('registration_failed', { \r\n        email: userData.email,\r\n        error: error.response?.data?.message || error.message \r\n      });\r\n      \r\n      // Re-throw with user-friendly message\r\n      const errorMessage = error.response?.data?.message || \r\n                          'Registration failed. Please try again.';\r\n      \r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get current authenticated user\r\n   * \r\n   * @returns {Promise<Object>} Current user data\r\n   */\r\n  getCurrentUser: async () => {\r\n    try {\r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      \r\n      if (!token) {\r\n        throw new Error('No authentication token found');\r\n      }\r\n      \r\n      const response = await api.get('/auth/me', {\r\n        headers: {\r\n          Authorization: `Bearer ${token}`\r\n        }\r\n      });\r\n      \r\n      const user = response.data;\r\n      \r\n      // Validate user data\r\n      if (!user || !user._id || !user.email || !user.role) {\r\n        throw new Error('Invalid user data received');\r\n      }\r\n      \r\n      return user;\r\n    } catch (error) {\r\n      logSecurityEvent('get_current_user_failed', { \r\n        error: error.message \r\n      });\r\n      \r\n      // Clear invalid token\r\n      if (error.response?.status === 401) {\r\n        localStorage.removeItem('token');\r\n        sessionStorage.removeItem('token');\r\n        localStorage.removeItem('user');\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Refresh authentication token\r\n   * \r\n   * @returns {Promise<Object>} New token and user data\r\n   */\r\n  refreshToken: async () => {\r\n    try {\r\n      logSecurityEvent('token_refresh_attempt');\r\n      \r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      \r\n      if (!token) {\r\n        throw new Error('No token available for refresh');\r\n      }\r\n      \r\n      const response = await api.post('/auth/refresh-token', {}, {\r\n        headers: {\r\n          Authorization: `Bearer ${token}`\r\n        }\r\n      });\r\n      \r\n      const { user, token: newToken, expiresIn } = response.data;\r\n      \r\n      if (!newToken || !user) {\r\n        throw new Error('Invalid token refresh response');\r\n      }\r\n      \r\n      logSecurityEvent('token_refresh_success', { \r\n        userId: user._id \r\n      });\r\n      \r\n      return {\r\n        user,\r\n        token: newToken,\r\n        expiresIn\r\n      };\r\n    } catch (error) {\r\n      logSecurityEvent('token_refresh_failed', { \r\n        error: error.message \r\n      });\r\n      \r\n      // Clear invalid tokens\r\n      localStorage.removeItem('token');\r\n      sessionStorage.removeItem('token');\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Verify session validity\r\n   * \r\n   * @returns {Promise<Object>} Session verification result\r\n   */\r\n  verifySession: async () => {\r\n    try {\r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      \r\n      if (!token) {\r\n        return { valid: false, reason: 'No token found' };\r\n      }\r\n      \r\n      const response = await api.get('/auth/verify-session', {\r\n        headers: {\r\n          Authorization: `Bearer ${token}`\r\n        }\r\n      });\r\n      \r\n      return {\r\n        valid: true,\r\n        user: response.data.user,\r\n        expiresAt: response.data.expiresAt\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        valid: false,\r\n        reason: error.response?.status === 401 ? 'Token expired' : 'Verification failed'\r\n      };\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update user profile\r\n   * \r\n   * @param {Object} updates - Profile updates\r\n   * @returns {Promise<Object>} Updated user data\r\n   */\r\n  updateProfile: async (updates) => {\r\n    try {\r\n      logSecurityEvent('profile_update_attempt', { updates: Object.keys(updates) });\r\n      \r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      \r\n      if (!token) {\r\n        throw new Error('Authentication required');\r\n      }\r\n      \r\n      // Validate updates\r\n      const allowedUpdates = ['name', 'email', 'phone', 'department', 'avatar'];\r\n      const invalidUpdates = Object.keys(updates).filter(key => !allowedUpdates.includes(key));\r\n      \r\n      if (invalidUpdates.length > 0) {\r\n        throw new Error(`Invalid update fields: ${invalidUpdates.join(', ')}`);\r\n      }\r\n      \r\n      const response = await api.put('/auth/profile', updates, {\r\n        headers: {\r\n          Authorization: `Bearer ${token}`\r\n        }\r\n      });\r\n      \r\n      logSecurityEvent('profile_update_success', { \r\n        fields: Object.keys(updates) \r\n      });\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      logSecurityEvent('profile_update_failed', { \r\n        error: error.message,\r\n        updates: Object.keys(updates)\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Change user password\r\n   * \r\n   * @param {string} currentPassword - Current password\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  changePassword: async (currentPassword, newPassword) => {\r\n    try {\r\n      logSecurityEvent('password_change_attempt');\r\n      \r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      \r\n      if (!token) {\r\n        throw new Error('Authentication required');\r\n      }\r\n      \r\n      // Validate password strength\r\n      if (newPassword.length < 8) {\r\n        throw new Error('New password must be at least 8 characters long');\r\n      }\r\n      \r\n      const response = await api.put('/auth/change-password', {\r\n        currentPassword: currentPassword.trim(),\r\n        newPassword: newPassword.trim()\r\n      }, {\r\n        headers: {\r\n          Authorization: `Bearer ${token}`\r\n        }\r\n      });\r\n      \r\n      logSecurityEvent('password_change_success');\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      logSecurityEvent('password_change_failed', { \r\n        error: error.message \r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Request password reset\r\n   * \r\n   * @param {string} email - User email\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  requestPasswordReset: async (email) => {\r\n    try {\r\n      logSecurityEvent('password_reset_request', { email });\r\n      \r\n      const response = await api.post('/auth/request-password-reset', {\r\n        email: email.toLowerCase().trim()\r\n      });\r\n      \r\n      logSecurityEvent('password_reset_request_success', { email });\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      logSecurityEvent('password_reset_request_failed', { \r\n        email,\r\n        error: error.message \r\n      });\r\n      \r\n      // Don't reveal if email exists or not\r\n      throw new Error('If an account exists with this email, you will receive reset instructions.');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Reset password with token\r\n   * \r\n   * @param {string} token - Reset token\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  resetPassword: async (token, newPassword) => {\r\n    try {\r\n      logSecurityEvent('password_reset_attempt', { token: token.substring(0, 10) + '...' });\r\n      \r\n      if (newPassword.length < 8) {\r\n        throw new Error('Password must be at least 8 characters long');\r\n      }\r\n      \r\n      const response = await api.post('/auth/reset-password', {\r\n        token: token.trim(),\r\n        newPassword: newPassword.trim()\r\n      });\r\n      \r\n      logSecurityEvent('password_reset_success');\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      logSecurityEvent('password_reset_failed', { \r\n        error: error.message \r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Logout from all devices\r\n   * \r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  logoutAllDevices: async () => {\r\n    try {\r\n      logSecurityEvent('logout_all_devices_attempt');\r\n      \r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      \r\n      if (!token) {\r\n        throw new Error('Authentication required');\r\n      }\r\n      \r\n      const response = await api.post('/auth/logout-all', {}, {\r\n        headers: {\r\n          Authorization: `Bearer ${token}`\r\n        }\r\n      });\r\n      \r\n      logSecurityEvent('logout_all_devices_success');\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      logSecurityEvent('logout_all_devices_failed', { \r\n        error: error.message \r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get user activity logs\r\n   * \r\n   * @param {Object} filters - Activity filters\r\n   * @returns {Promise<Array>} Activity logs\r\n   */\r\n  getActivityLogs: async (filters = {}) => {\r\n    try {\r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      \r\n      if (!token) {\r\n        throw new Error('Authentication required');\r\n      }\r\n      \r\n      const params = new URLSearchParams();\r\n      Object.keys(filters).forEach(key => {\r\n        if (filters[key] !== undefined && filters[key] !== null) {\r\n          params.append(key, filters[key]);\r\n        }\r\n      });\r\n      \r\n      const response = await api.get(`/auth/activity-logs?${params}`, {\r\n        headers: {\r\n          Authorization: `Bearer ${token}`\r\n        }\r\n      });\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      logSecurityEvent('activity_logs_failed', { \r\n        error: error.message \r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get login sessions\r\n   * \r\n   * @returns {Promise<Array>} Active sessions\r\n   */\r\n  getSessions: async () => {\r\n    try {\r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      \r\n      if (!token) {\r\n        throw new Error('Authentication required');\r\n      }\r\n      \r\n      const response = await api.get('/auth/sessions', {\r\n        headers: {\r\n          Authorization: `Bearer ${token}`\r\n        }\r\n      });\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      logSecurityEvent('get_sessions_failed', { \r\n        error: error.message \r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Revoke a specific session\r\n   * \r\n   * @param {string} sessionId - Session ID to revoke\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  revokeSession: async (sessionId) => {\r\n    try {\r\n      logSecurityEvent('revoke_session_attempt', { sessionId });\r\n      \r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      \r\n      if (!token) {\r\n        throw new Error('Authentication required');\r\n      }\r\n      \r\n      const response = await api.delete(`/auth/sessions/${sessionId}`, {\r\n        headers: {\r\n          Authorization: `Bearer ${token}`\r\n        }\r\n      });\r\n      \r\n      logSecurityEvent('revoke_session_success', { sessionId });\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      logSecurityEvent('revoke_session_failed', { \r\n        sessionId,\r\n        error: error.message \r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Validate authentication token\r\n   * \r\n   * @param {string} token - Token to validate\r\n   * @returns {Promise<Object>} Validation result\r\n   */\r\n  validateToken: async (token) => {\r\n    try {\r\n      const response = await api.post('/auth/validate-token', { token });\r\n      return response.data;\r\n    } catch (error) {\r\n      return { valid: false, error: error.message };\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear all security events (for testing/debugging)\r\n   */\r\n  clearSecurityEvents: () => {\r\n    localStorage.removeItem('auth_security_events');\r\n  },\r\n\r\n  /**\r\n   * Get security events (for debugging)\r\n   */\r\n  getSecurityEvents: () => {\r\n    try {\r\n      return JSON.parse(localStorage.getItem('auth_security_events') || '[]');\r\n    } catch (e) {\r\n      return [];\r\n    }\r\n  }\r\n};\r\n\r\nexport default authService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}