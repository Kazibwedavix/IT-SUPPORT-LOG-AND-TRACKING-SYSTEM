{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\KADZ-TECH\\\\Documents\\\\dev\\\\it-support-system\\\\frontend\\\\src\\\\context\\\\AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect, useCallback, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport authService from '../services/authService';\nimport api from '../services/api';\n\n/**\r\n * AuthContext - Enterprise Authentication System\r\n * \r\n * Features:\r\n * - JWT token management with auto-refresh\r\n * - Session validation and monitoring\r\n * - Role-based access control\r\n * - Activity logging\r\n * - Security event tracking\r\n * - Concurrent session prevention\r\n * - Token refresh queue\r\n * - Graceful error handling\r\n * \r\n * @version 4.1.0\r\n * @author IT Support Team\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const AuthContext = /*#__PURE__*/createContext();\n\n/**\r\n * Custom hook to access authentication context\r\n * \r\n * @returns {Object} Authentication context\r\n * @throws {Error} If used outside AuthProvider\r\n */\nexport const useAuth = () => {\n  _s();\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\n/**\r\n * Validates user data structure\r\n * \r\n * @param {Object} userData - User data to validate\r\n * @returns {boolean} True if valid\r\n */\n_s(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst validateUserData = userData => {\n  if (!userData || typeof userData !== 'object') {\n    return false;\n  }\n\n  // Required fields\n  const requiredFields = ['_id', 'email', 'role'];\n  for (const field of requiredFields) {\n    if (!userData[field]) {\n      console.warn(`Invalid user data: Missing ${field}`);\n      return false;\n    }\n  }\n\n  // Validate role\n  const validRoles = ['admin', 'technician', 'staff', 'student'];\n  if (!validRoles.includes(userData.role)) {\n    console.warn(`Invalid user data: Invalid role \"${userData.role}\"`);\n    return false;\n  }\n\n  // Validate email format\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(userData.email)) {\n    console.warn(`Invalid user data: Invalid email \"${userData.email}\"`);\n    return false;\n  }\n  return true;\n};\n\n/**\r\n * Sanitizes user data before storage\r\n * \r\n * @param {Object} userData - Raw user data\r\n * @returns {Object} Sanitized user data\r\n */\nconst sanitizeUserData = userData => {\n  const sanitized = {\n    ...userData\n  };\n\n  // Remove sensitive fields\n  delete sanitized.password;\n  delete sanitized.tempPassword;\n  delete sanitized.resetToken;\n  delete sanitized.verificationToken;\n\n  // Ensure role is lowercase\n  if (sanitized.role) {\n    sanitized.role = sanitized.role.toLowerCase();\n  }\n  return sanitized;\n};\n\n/**\r\n * AuthProvider Component\r\n * \r\n * @param {Object} props - Component properties\r\n * @param {ReactNode} props.children - Child components\r\n */\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [sessionValid, setSessionValid] = useState(false);\n  const [sessionExpiresAt, setSessionExpiresAt] = useState(null);\n  const [authError, setAuthError] = useState(null);\n  const refreshTimeoutRef = useRef(null);\n  const sessionCheckIntervalRef = useRef(null);\n  const isRefreshingRef = useRef(false);\n  const refreshQueueRef = useRef([]);\n\n  // Valid roles for role checking\n  const validRoles = ['admin', 'technician', 'staff', 'student'];\n\n  /**\r\n   * Initializes authentication state from storage\r\n   */\n  const initializeAuth = useCallback(async () => {\n    try {\n      setLoading(true);\n      setAuthError(null);\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n      const savedUser = localStorage.getItem('user') || sessionStorage.getItem('user');\n      const sessionExpiry = localStorage.getItem('sessionExpiry');\n      if (!token || !savedUser) {\n        setLoading(false);\n        return;\n      }\n\n      // Parse and validate saved user\n      let parsedUser;\n      try {\n        parsedUser = JSON.parse(savedUser);\n      } catch (error) {\n        console.error('Error parsing saved user:', error);\n        logout('Invalid session data');\n        return;\n      }\n\n      // Validate user data\n      if (!validateUserData(parsedUser)) {\n        console.warn('Invalid user data in storage, logging out');\n        logout('Invalid user data');\n        return;\n      }\n\n      // Check session expiry\n      if (sessionExpiry) {\n        const expiryTime = parseInt(sessionExpiry, 10);\n        if (Date.now() > expiryTime) {\n          console.warn('Session expired, logging out');\n          logout('Session expired');\n          return;\n        }\n        setSessionExpiresAt(expiryTime);\n      }\n\n      // Set token in API headers\n      api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n\n      // Verify token with backend\n      try {\n        const userData = await authService.getCurrentUser();\n        if (!validateUserData(userData)) {\n          throw new Error('Invalid user data received from server');\n        }\n        const sanitizedUser = sanitizeUserData(userData);\n        setUser(sanitizedUser);\n        setSessionValid(true);\n\n        // Update storage with fresh data\n        const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\n        storage.setItem('user', JSON.stringify(sanitizedUser));\n\n        // Schedule token refresh\n        scheduleTokenRefresh();\n\n        // Start session monitoring\n        startSessionMonitoring();\n      } catch (error) {\n        console.error('Token verification failed:', error);\n\n        // Try to refresh token\n        try {\n          await refreshToken();\n        } catch (refreshError) {\n          console.error('Token refresh failed:', refreshError);\n          logout('Session verification failed');\n        }\n      }\n    } catch (error) {\n      console.error('Auth initialization error:', error);\n      setAuthError('Authentication initialization failed');\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  /**\r\n   * Refreshes authentication token\r\n   */\n  const refreshToken = useCallback(async () => {\n    // Prevent multiple concurrent refresh attempts\n    if (isRefreshingRef.current) {\n      return new Promise((resolve, reject) => {\n        refreshQueueRef.current.push({\n          resolve,\n          reject\n        });\n      });\n    }\n    try {\n      isRefreshingRef.current = true;\n      const response = await authService.refreshToken();\n      if (!response.token || !response.user) {\n        throw new Error('Invalid refresh response');\n      }\n\n      // Validate user data\n      if (!validateUserData(response.user)) {\n        throw new Error('Invalid user data in refresh response');\n      }\n      const sanitizedUser = sanitizeUserData(response.user);\n\n      // Update state and storage\n      setUser(sanitizedUser);\n      setSessionValid(true);\n      const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\n      storage.setItem('token', response.token);\n      storage.setItem('user', JSON.stringify(sanitizedUser));\n\n      // Update API headers\n      api.defaults.headers.common['Authorization'] = `Bearer ${response.token}`;\n\n      // Set new session expiry (24 hours from now)\n      const expiryTime = Date.now() + 24 * 60 * 60 * 1000;\n      setSessionExpiresAt(expiryTime);\n      localStorage.setItem('sessionExpiry', expiryTime.toString());\n\n      // Schedule next refresh\n      scheduleTokenRefresh();\n\n      // Process queued requests\n      while (refreshQueueRef.current.length > 0) {\n        const queued = refreshQueueRef.current.shift();\n        queued.resolve();\n      }\n      return response;\n    } catch (error) {\n      console.error('Token refresh failed:', error);\n\n      // Process queued requests with error\n      while (refreshQueueRef.current.length > 0) {\n        const queued = refreshQueueRef.current.shift();\n        queued.reject(error);\n      }\n      throw error;\n    } finally {\n      isRefreshingRef.current = false;\n    }\n  }, []);\n\n  /**\r\n   * Schedules token refresh before expiry\r\n   */\n  const scheduleTokenRefresh = useCallback(() => {\n    // Clear existing timeout\n    if (refreshTimeoutRef.current) {\n      clearTimeout(refreshTimeoutRef.current);\n    }\n\n    // Schedule refresh 5 minutes before expiry\n    const refreshTime = sessionExpiresAt ? sessionExpiresAt - 5 * 60 * 1000 - Date.now() : 55 * 60 * 1000; // Default: 55 minutes\n\n    if (refreshTime > 0) {\n      refreshTimeoutRef.current = setTimeout(async () => {\n        try {\n          await refreshToken();\n        } catch (error) {\n          console.error('Scheduled token refresh failed:', error);\n          // Don't logout immediately, let session monitoring handle it\n        }\n      }, refreshTime);\n    }\n  }, [sessionExpiresAt, refreshToken]);\n\n  /**\r\n   * Starts session monitoring\r\n   */\n  const startSessionMonitoring = useCallback(() => {\n    // Clear existing interval\n    if (sessionCheckIntervalRef.current) {\n      clearInterval(sessionCheckIntervalRef.current);\n    }\n\n    // Check session every minute\n    sessionCheckIntervalRef.current = setInterval(() => {\n      if (sessionExpiresAt && Date.now() > sessionExpiresAt) {\n        console.warn('Session expired during monitoring');\n        logout('Session expired');\n      }\n    }, 60 * 1000);\n  }, [sessionExpiresAt]);\n\n  /**\r\n   * Handles user login\r\n   */\n  const login = useCallback(async (email, password, rememberMe = false) => {\n    try {\n      setAuthError(null);\n      setLoading(true);\n      const response = await authService.login(email, password);\n      if (!response.token || !response.user) {\n        throw new Error('Invalid login response');\n      }\n\n      // Validate user data\n      if (!validateUserData(response.user)) {\n        throw new Error('Invalid user data received from server');\n      }\n      const sanitizedUser = sanitizeUserData(response.user);\n\n      // Update state\n      setUser(sanitizedUser);\n      setSessionValid(true);\n\n      // Calculate session expiry\n      const expiryTime = Date.now() + 24 * 60 * 60 * 1000; // 24 hours\n      setSessionExpiresAt(expiryTime);\n\n      // Choose storage based on rememberMe\n      const storage = rememberMe ? localStorage : sessionStorage;\n      storage.setItem('token', response.token);\n      storage.setItem('user', JSON.stringify(sanitizedUser));\n      if (rememberMe) {\n        localStorage.setItem('sessionExpiry', expiryTime.toString());\n        localStorage.setItem('rememberMe', 'true');\n      }\n\n      // Update API headers\n      api.defaults.headers.common['Authorization'] = `Bearer ${response.token}`;\n\n      // Schedule token refresh\n      scheduleTokenRefresh();\n\n      // Start session monitoring\n      startSessionMonitoring();\n\n      // Log successful login\n      logSecurityEvent('login_success', {\n        email,\n        role: sanitizedUser.role\n      });\n      return response;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error('Login error:', error);\n\n      // Log failed login attempt\n      logSecurityEvent('login_failed', {\n        email,\n        error: error.message\n      });\n      const errorMessage = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.message || 'Login failed. Please check your credentials.';\n      setAuthError(errorMessage);\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  }, [scheduleTokenRefresh, startSessionMonitoring]);\n\n  /**\r\n   * Handles user registration\r\n   */\n  const register = useCallback(async userData => {\n    try {\n      setAuthError(null);\n      setLoading(true);\n      const response = await authService.register(userData);\n      if (!response.token || !response.user) {\n        throw new Error('Invalid registration response');\n      }\n\n      // Validate user data\n      if (!validateUserData(response.user)) {\n        throw new Error('Invalid user data received from server');\n      }\n      const sanitizedUser = sanitizeUserData(response.user);\n\n      // Update state\n      setUser(sanitizedUser);\n      setSessionValid(true);\n\n      // Calculate session expiry\n      const expiryTime = Date.now() + 24 * 60 * 60 * 1000; // 24 hours\n      setSessionExpiresAt(expiryTime);\n\n      // Store in localStorage by default for new registrations\n      localStorage.setItem('token', response.token);\n      localStorage.setItem('user', JSON.stringify(sanitizedUser));\n      localStorage.setItem('sessionExpiry', expiryTime.toString());\n\n      // Update API headers\n      api.defaults.headers.common['Authorization'] = `Bearer ${response.token}`;\n\n      // Schedule token refresh\n      scheduleTokenRefresh();\n\n      // Start session monitoring\n      startSessionMonitoring();\n\n      // Log successful registration\n      logSecurityEvent('registration_success', {\n        email: sanitizedUser.email,\n        role: sanitizedUser.role\n      });\n      return response;\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      console.error('Registration error:', error);\n\n      // Log failed registration\n      logSecurityEvent('registration_failed', {\n        email: userData.email,\n        error: error.message\n      });\n      const errorMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || error.message || 'Registration failed. Please try again.';\n      setAuthError(errorMessage);\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  }, [scheduleTokenRefresh, startSessionMonitoring]);\n\n  /**\r\n   * Handles user logout\r\n   */\n  const logout = useCallback((reason = 'user_initiated') => {\n    // Clear state\n    setUser(null);\n    setSessionValid(false);\n    setSessionExpiresAt(null);\n    setAuthError(null);\n\n    // Clear timeouts and intervals\n    if (refreshTimeoutRef.current) {\n      clearTimeout(refreshTimeoutRef.current);\n      refreshTimeoutRef.current = null;\n    }\n    if (sessionCheckIntervalRef.current) {\n      clearInterval(sessionCheckIntervalRef.current);\n      sessionCheckIntervalRef.current = null;\n    }\n\n    // Clear storage\n    localStorage.removeItem('token');\n    localStorage.removeItem('user');\n    localStorage.removeItem('sessionExpiry');\n    localStorage.removeItem('rememberMe');\n    sessionStorage.removeItem('token');\n    sessionStorage.removeItem('user');\n\n    // Clear API authorization header\n    delete api.defaults.headers.common['Authorization'];\n\n    // Log logout event\n    logSecurityEvent('logout', {\n      reason\n    });\n\n    // Clear refresh queue\n    refreshQueueRef.current = [];\n  }, []);\n\n  /**\r\n   * Logs security events for monitoring\r\n   */\n  const logSecurityEvent = useCallback((eventType, data = {}) => {\n    const securityEvent = {\n      timestamp: new Date().toISOString(),\n      event: eventType,\n      userId: user === null || user === void 0 ? void 0 : user._id,\n      userRole: user === null || user === void 0 ? void 0 : user.role,\n      ...data,\n      userAgent: navigator.userAgent,\n      ip: 'client-ip' // In production, get from request headers\n    };\n\n    // Log to console in development\n    if (process.env.NODE_ENV === 'development') {\n      console.log('ðŸ”’ Security Event:', securityEvent);\n    }\n\n    // Send to security monitoring service\n    sendToSecurityLog(securityEvent);\n  }, [user]);\n\n  /**\r\n   * Sends security events to monitoring service\r\n   */\n  const sendToSecurityLog = useCallback(eventData => {\n    try {\n      // Store in localStorage for debugging (remove in production)\n      const existingEvents = JSON.parse(localStorage.getItem('security_events') || '[]');\n      existingEvents.push(eventData);\n\n      // Keep only last 50 events\n      if (existingEvents.length > 50) {\n        existingEvents.shift();\n      }\n      localStorage.setItem('security_events', JSON.stringify(existingEvents));\n    } catch (e) {\n      // Silently fail if localStorage is not available\n    }\n  }, []);\n\n  /**\r\n   * Checks if user has required role(s)\r\n   */\n  const hasRole = useCallback(roles => {\n    if (!user || !user.role) return false;\n    const rolesToCheck = Array.isArray(roles) ? roles : [roles];\n    return rolesToCheck.includes(user.role);\n  }, [user]);\n\n  /**\r\n   * Checks if user has required permission(s)\r\n   */\n  const hasPermission = useCallback(permissions => {\n    if (!user || !user.permissions) return false;\n    const permissionsToCheck = Array.isArray(permissions) ? permissions : [permissions];\n    return permissionsToCheck.every(permission => user.permissions.includes(permission));\n  }, [user]);\n\n  /**\r\n   * Checks if session is valid and active\r\n   */\n  const checkSession = useCallback(async () => {\n    if (!user) return false;\n    try {\n      await authService.getCurrentUser();\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }, [user]);\n\n  /**\r\n   * Updates user profile\r\n   */\n  const updateProfile = useCallback(async updates => {\n    try {\n      const response = await authService.updateProfile(updates);\n      if (response.user) {\n        const sanitizedUser = sanitizeUserData(response.user);\n        setUser(sanitizedUser);\n        const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\n        storage.setItem('user', JSON.stringify(sanitizedUser));\n      }\n      return response;\n    } catch (error) {\n      console.error('Profile update error:', error);\n      throw error;\n    }\n  }, []);\n\n  /**\r\n   * Changes user password\r\n   */\n  const changePassword = useCallback(async (currentPassword, newPassword) => {\n    try {\n      await authService.changePassword(currentPassword, newPassword);\n      logSecurityEvent('password_changed');\n    } catch (error) {\n      console.error('Password change error:', error);\n      throw error;\n    }\n  }, [logSecurityEvent]);\n\n  // Initialize authentication on mount\n  useEffect(() => {\n    initializeAuth();\n\n    // Cleanup on unmount\n    return () => {\n      if (refreshTimeoutRef.current) {\n        clearTimeout(refreshTimeoutRef.current);\n      }\n      if (sessionCheckIntervalRef.current) {\n        clearInterval(sessionCheckIntervalRef.current);\n      }\n    };\n  }, [initializeAuth]);\n\n  // Set up axios interceptor for token refresh\n  useEffect(() => {\n    const interceptor = api.interceptors.response.use(response => response, async error => {\n      var _error$response3;\n      const originalRequest = error.config;\n\n      // If error is 401 and not a retry, try to refresh token\n      if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 401 && !originalRequest._retry) {\n        originalRequest._retry = true;\n        try {\n          await refreshToken();\n\n          // Retry the original request with new token\n          const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n          originalRequest.headers.Authorization = `Bearer ${token}`;\n          return api(originalRequest);\n        } catch (refreshError) {\n          // Refresh failed, logout user\n          logout('token_refresh_failed');\n          return Promise.reject(refreshError);\n        }\n      }\n      return Promise.reject(error);\n    });\n\n    // Cleanup interceptor\n    return () => {\n      api.interceptors.response.eject(interceptor);\n    };\n  }, [refreshToken, logout]);\n\n  // Context value\n  const value = {\n    // State\n    user,\n    loading,\n    sessionValid,\n    sessionExpiresAt,\n    authError,\n    // Authentication methods\n    login,\n    register,\n    logout,\n    refreshToken,\n    checkSession,\n    // User management\n    updateProfile,\n    changePassword,\n    // Access control\n    hasRole,\n    hasPermission,\n    // Security logging\n    logSecurityEvent,\n    // Utility\n    isAuthenticated: !!user && sessionValid\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 695,\n    columnNumber: 5\n  }, this);\n};\n\n// PropTypes\n_s2(AuthProvider, \"TYiN3pwVgV6SfcNjj4IkuNuwabQ=\");\n_c = AuthProvider;\nAuthProvider.propTypes = {\n  children: PropTypes.node.isRequired\n};\n\n// âœ… Export both as named exports and default\nexport default AuthContext;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useCallback","useRef","PropTypes","authService","api","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","context","Error","validateUserData","userData","requiredFields","field","console","warn","validRoles","includes","role","emailRegex","test","email","sanitizeUserData","sanitized","password","tempPassword","resetToken","verificationToken","toLowerCase","AuthProvider","children","_s2","user","setUser","loading","setLoading","sessionValid","setSessionValid","sessionExpiresAt","setSessionExpiresAt","authError","setAuthError","refreshTimeoutRef","sessionCheckIntervalRef","isRefreshingRef","refreshQueueRef","initializeAuth","token","localStorage","getItem","sessionStorage","savedUser","sessionExpiry","parsedUser","JSON","parse","error","logout","expiryTime","parseInt","Date","now","defaults","headers","common","getCurrentUser","sanitizedUser","storage","setItem","stringify","scheduleTokenRefresh","startSessionMonitoring","refreshToken","refreshError","current","Promise","resolve","reject","push","response","toString","length","queued","shift","clearTimeout","refreshTime","setTimeout","clearInterval","setInterval","login","rememberMe","logSecurityEvent","_error$response","_error$response$data","message","errorMessage","data","register","_error$response2","_error$response2$data","reason","removeItem","eventType","securityEvent","timestamp","toISOString","event","userId","_id","userRole","userAgent","navigator","ip","process","env","NODE_ENV","log","sendToSecurityLog","eventData","existingEvents","e","hasRole","roles","rolesToCheck","Array","isArray","hasPermission","permissions","permissionsToCheck","every","permission","checkSession","updateProfile","updates","changePassword","currentPassword","newPassword","interceptor","interceptors","use","_error$response3","originalRequest","config","status","_retry","Authorization","eject","value","isAuthenticated","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","propTypes","node","isRequired","$RefreshReg$"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/context/AuthContext.js"],"sourcesContent":["import React, { createContext, useState, useContext, useEffect, useCallback, useRef } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport authService from '../services/authService';\r\nimport api from '../services/api';\r\n\r\n/**\r\n * AuthContext - Enterprise Authentication System\r\n * \r\n * Features:\r\n * - JWT token management with auto-refresh\r\n * - Session validation and monitoring\r\n * - Role-based access control\r\n * - Activity logging\r\n * - Security event tracking\r\n * - Concurrent session prevention\r\n * - Token refresh queue\r\n * - Graceful error handling\r\n * \r\n * @version 4.1.0\r\n * @author IT Support Team\r\n */\r\n\r\nexport const AuthContext = createContext();\r\n\r\n/**\r\n * Custom hook to access authentication context\r\n * \r\n * @returns {Object} Authentication context\r\n * @throws {Error} If used outside AuthProvider\r\n */\r\nexport const useAuth = () => {\r\n  const context = useContext(AuthContext);\r\n  if (!context) {\r\n    throw new Error('useAuth must be used within an AuthProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n/**\r\n * Validates user data structure\r\n * \r\n * @param {Object} userData - User data to validate\r\n * @returns {boolean} True if valid\r\n */\r\nconst validateUserData = (userData) => {\r\n  if (!userData || typeof userData !== 'object') {\r\n    return false;\r\n  }\r\n\r\n  // Required fields\r\n  const requiredFields = ['_id', 'email', 'role'];\r\n  for (const field of requiredFields) {\r\n    if (!userData[field]) {\r\n      console.warn(`Invalid user data: Missing ${field}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Validate role\r\n  const validRoles = ['admin', 'technician', 'staff', 'student'];\r\n  if (!validRoles.includes(userData.role)) {\r\n    console.warn(`Invalid user data: Invalid role \"${userData.role}\"`);\r\n    return false;\r\n  }\r\n\r\n  // Validate email format\r\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  if (!emailRegex.test(userData.email)) {\r\n    console.warn(`Invalid user data: Invalid email \"${userData.email}\"`);\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * Sanitizes user data before storage\r\n * \r\n * @param {Object} userData - Raw user data\r\n * @returns {Object} Sanitized user data\r\n */\r\nconst sanitizeUserData = (userData) => {\r\n  const sanitized = { ...userData };\r\n  \r\n  // Remove sensitive fields\r\n  delete sanitized.password;\r\n  delete sanitized.tempPassword;\r\n  delete sanitized.resetToken;\r\n  delete sanitized.verificationToken;\r\n  \r\n  // Ensure role is lowercase\r\n  if (sanitized.role) {\r\n    sanitized.role = sanitized.role.toLowerCase();\r\n  }\r\n  \r\n  return sanitized;\r\n};\r\n\r\n/**\r\n * AuthProvider Component\r\n * \r\n * @param {Object} props - Component properties\r\n * @param {ReactNode} props.children - Child components\r\n */\r\nexport const AuthProvider = ({ children }) => {\r\n  const [user, setUser] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [sessionValid, setSessionValid] = useState(false);\r\n  const [sessionExpiresAt, setSessionExpiresAt] = useState(null);\r\n  const [authError, setAuthError] = useState(null);\r\n  \r\n  const refreshTimeoutRef = useRef(null);\r\n  const sessionCheckIntervalRef = useRef(null);\r\n  const isRefreshingRef = useRef(false);\r\n  const refreshQueueRef = useRef([]);\r\n\r\n  // Valid roles for role checking\r\n  const validRoles = ['admin', 'technician', 'staff', 'student'];\r\n\r\n  /**\r\n   * Initializes authentication state from storage\r\n   */\r\n  const initializeAuth = useCallback(async () => {\r\n    try {\r\n      setLoading(true);\r\n      setAuthError(null);\r\n\r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      const savedUser = localStorage.getItem('user') || sessionStorage.getItem('user');\r\n      const sessionExpiry = localStorage.getItem('sessionExpiry');\r\n\r\n      if (!token || !savedUser) {\r\n        setLoading(false);\r\n        return;\r\n      }\r\n\r\n      // Parse and validate saved user\r\n      let parsedUser;\r\n      try {\r\n        parsedUser = JSON.parse(savedUser);\r\n      } catch (error) {\r\n        console.error('Error parsing saved user:', error);\r\n        logout('Invalid session data');\r\n        return;\r\n      }\r\n\r\n      // Validate user data\r\n      if (!validateUserData(parsedUser)) {\r\n        console.warn('Invalid user data in storage, logging out');\r\n        logout('Invalid user data');\r\n        return;\r\n      }\r\n\r\n      // Check session expiry\r\n      if (sessionExpiry) {\r\n        const expiryTime = parseInt(sessionExpiry, 10);\r\n        if (Date.now() > expiryTime) {\r\n          console.warn('Session expired, logging out');\r\n          logout('Session expired');\r\n          return;\r\n        }\r\n        setSessionExpiresAt(expiryTime);\r\n      }\r\n\r\n      // Set token in API headers\r\n      api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\r\n\r\n      // Verify token with backend\r\n      try {\r\n        const userData = await authService.getCurrentUser();\r\n        \r\n        if (!validateUserData(userData)) {\r\n          throw new Error('Invalid user data received from server');\r\n        }\r\n\r\n        const sanitizedUser = sanitizeUserData(userData);\r\n        setUser(sanitizedUser);\r\n        setSessionValid(true);\r\n        \r\n        // Update storage with fresh data\r\n        const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\r\n        storage.setItem('user', JSON.stringify(sanitizedUser));\r\n        \r\n        // Schedule token refresh\r\n        scheduleTokenRefresh();\r\n        \r\n        // Start session monitoring\r\n        startSessionMonitoring();\r\n        \r\n      } catch (error) {\r\n        console.error('Token verification failed:', error);\r\n        \r\n        // Try to refresh token\r\n        try {\r\n          await refreshToken();\r\n        } catch (refreshError) {\r\n          console.error('Token refresh failed:', refreshError);\r\n          logout('Session verification failed');\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Auth initialization error:', error);\r\n      setAuthError('Authentication initialization failed');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Refreshes authentication token\r\n   */\r\n  const refreshToken = useCallback(async () => {\r\n    // Prevent multiple concurrent refresh attempts\r\n    if (isRefreshingRef.current) {\r\n      return new Promise((resolve, reject) => {\r\n        refreshQueueRef.current.push({ resolve, reject });\r\n      });\r\n    }\r\n\r\n    try {\r\n      isRefreshingRef.current = true;\r\n      \r\n      const response = await authService.refreshToken();\r\n      \r\n      if (!response.token || !response.user) {\r\n        throw new Error('Invalid refresh response');\r\n      }\r\n\r\n      // Validate user data\r\n      if (!validateUserData(response.user)) {\r\n        throw new Error('Invalid user data in refresh response');\r\n      }\r\n\r\n      const sanitizedUser = sanitizeUserData(response.user);\r\n      \r\n      // Update state and storage\r\n      setUser(sanitizedUser);\r\n      setSessionValid(true);\r\n      \r\n      const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\r\n      storage.setItem('token', response.token);\r\n      storage.setItem('user', JSON.stringify(sanitizedUser));\r\n      \r\n      // Update API headers\r\n      api.defaults.headers.common['Authorization'] = `Bearer ${response.token}`;\r\n      \r\n      // Set new session expiry (24 hours from now)\r\n      const expiryTime = Date.now() + (24 * 60 * 60 * 1000);\r\n      setSessionExpiresAt(expiryTime);\r\n      localStorage.setItem('sessionExpiry', expiryTime.toString());\r\n      \r\n      // Schedule next refresh\r\n      scheduleTokenRefresh();\r\n      \r\n      // Process queued requests\r\n      while (refreshQueueRef.current.length > 0) {\r\n        const queued = refreshQueueRef.current.shift();\r\n        queued.resolve();\r\n      }\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('Token refresh failed:', error);\r\n      \r\n      // Process queued requests with error\r\n      while (refreshQueueRef.current.length > 0) {\r\n        const queued = refreshQueueRef.current.shift();\r\n        queued.reject(error);\r\n      }\r\n      \r\n      throw error;\r\n    } finally {\r\n      isRefreshingRef.current = false;\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Schedules token refresh before expiry\r\n   */\r\n  const scheduleTokenRefresh = useCallback(() => {\r\n    // Clear existing timeout\r\n    if (refreshTimeoutRef.current) {\r\n      clearTimeout(refreshTimeoutRef.current);\r\n    }\r\n\r\n    // Schedule refresh 5 minutes before expiry\r\n    const refreshTime = sessionExpiresAt \r\n      ? sessionExpiresAt - (5 * 60 * 1000) - Date.now()\r\n      : 55 * 60 * 1000; // Default: 55 minutes\r\n\r\n    if (refreshTime > 0) {\r\n      refreshTimeoutRef.current = setTimeout(async () => {\r\n        try {\r\n          await refreshToken();\r\n        } catch (error) {\r\n          console.error('Scheduled token refresh failed:', error);\r\n          // Don't logout immediately, let session monitoring handle it\r\n        }\r\n      }, refreshTime);\r\n    }\r\n  }, [sessionExpiresAt, refreshToken]);\r\n\r\n  /**\r\n   * Starts session monitoring\r\n   */\r\n  const startSessionMonitoring = useCallback(() => {\r\n    // Clear existing interval\r\n    if (sessionCheckIntervalRef.current) {\r\n      clearInterval(sessionCheckIntervalRef.current);\r\n    }\r\n\r\n    // Check session every minute\r\n    sessionCheckIntervalRef.current = setInterval(() => {\r\n      if (sessionExpiresAt && Date.now() > sessionExpiresAt) {\r\n        console.warn('Session expired during monitoring');\r\n        logout('Session expired');\r\n      }\r\n    }, 60 * 1000);\r\n  }, [sessionExpiresAt]);\r\n\r\n  /**\r\n   * Handles user login\r\n   */\r\n  const login = useCallback(async (email, password, rememberMe = false) => {\r\n    try {\r\n      setAuthError(null);\r\n      setLoading(true);\r\n\r\n      const response = await authService.login(email, password);\r\n      \r\n      if (!response.token || !response.user) {\r\n        throw new Error('Invalid login response');\r\n      }\r\n\r\n      // Validate user data\r\n      if (!validateUserData(response.user)) {\r\n        throw new Error('Invalid user data received from server');\r\n      }\r\n\r\n      const sanitizedUser = sanitizeUserData(response.user);\r\n      \r\n      // Update state\r\n      setUser(sanitizedUser);\r\n      setSessionValid(true);\r\n      \r\n      // Calculate session expiry\r\n      const expiryTime = Date.now() + (24 * 60 * 60 * 1000); // 24 hours\r\n      setSessionExpiresAt(expiryTime);\r\n      \r\n      // Choose storage based on rememberMe\r\n      const storage = rememberMe ? localStorage : sessionStorage;\r\n      storage.setItem('token', response.token);\r\n      storage.setItem('user', JSON.stringify(sanitizedUser));\r\n      \r\n      if (rememberMe) {\r\n        localStorage.setItem('sessionExpiry', expiryTime.toString());\r\n        localStorage.setItem('rememberMe', 'true');\r\n      }\r\n\r\n      // Update API headers\r\n      api.defaults.headers.common['Authorization'] = `Bearer ${response.token}`;\r\n\r\n      // Schedule token refresh\r\n      scheduleTokenRefresh();\r\n      \r\n      // Start session monitoring\r\n      startSessionMonitoring();\r\n      \r\n      // Log successful login\r\n      logSecurityEvent('login_success', { email, role: sanitizedUser.role });\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('Login error:', error);\r\n      \r\n      // Log failed login attempt\r\n      logSecurityEvent('login_failed', { email, error: error.message });\r\n      \r\n      const errorMessage = error.response?.data?.message || \r\n                          error.message || \r\n                          'Login failed. Please check your credentials.';\r\n      \r\n      setAuthError(errorMessage);\r\n      throw error;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [scheduleTokenRefresh, startSessionMonitoring]);\r\n\r\n  /**\r\n   * Handles user registration\r\n   */\r\n  const register = useCallback(async (userData) => {\r\n    try {\r\n      setAuthError(null);\r\n      setLoading(true);\r\n\r\n      const response = await authService.register(userData);\r\n      \r\n      if (!response.token || !response.user) {\r\n        throw new Error('Invalid registration response');\r\n      }\r\n\r\n      // Validate user data\r\n      if (!validateUserData(response.user)) {\r\n        throw new Error('Invalid user data received from server');\r\n      }\r\n\r\n      const sanitizedUser = sanitizeUserData(response.user);\r\n      \r\n      // Update state\r\n      setUser(sanitizedUser);\r\n      setSessionValid(true);\r\n      \r\n      // Calculate session expiry\r\n      const expiryTime = Date.now() + (24 * 60 * 60 * 1000); // 24 hours\r\n      setSessionExpiresAt(expiryTime);\r\n      \r\n      // Store in localStorage by default for new registrations\r\n      localStorage.setItem('token', response.token);\r\n      localStorage.setItem('user', JSON.stringify(sanitizedUser));\r\n      localStorage.setItem('sessionExpiry', expiryTime.toString());\r\n\r\n      // Update API headers\r\n      api.defaults.headers.common['Authorization'] = `Bearer ${response.token}`;\r\n\r\n      // Schedule token refresh\r\n      scheduleTokenRefresh();\r\n      \r\n      // Start session monitoring\r\n      startSessionMonitoring();\r\n      \r\n      // Log successful registration\r\n      logSecurityEvent('registration_success', { \r\n        email: sanitizedUser.email, \r\n        role: sanitizedUser.role \r\n      });\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('Registration error:', error);\r\n      \r\n      // Log failed registration\r\n      logSecurityEvent('registration_failed', { \r\n        email: userData.email, \r\n        error: error.message \r\n      });\r\n      \r\n      const errorMessage = error.response?.data?.message || \r\n                          error.message || \r\n                          'Registration failed. Please try again.';\r\n      \r\n      setAuthError(errorMessage);\r\n      throw error;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [scheduleTokenRefresh, startSessionMonitoring]);\r\n\r\n  /**\r\n   * Handles user logout\r\n   */\r\n  const logout = useCallback((reason = 'user_initiated') => {\r\n    // Clear state\r\n    setUser(null);\r\n    setSessionValid(false);\r\n    setSessionExpiresAt(null);\r\n    setAuthError(null);\r\n    \r\n    // Clear timeouts and intervals\r\n    if (refreshTimeoutRef.current) {\r\n      clearTimeout(refreshTimeoutRef.current);\r\n      refreshTimeoutRef.current = null;\r\n    }\r\n    \r\n    if (sessionCheckIntervalRef.current) {\r\n      clearInterval(sessionCheckIntervalRef.current);\r\n      sessionCheckIntervalRef.current = null;\r\n    }\r\n    \r\n    // Clear storage\r\n    localStorage.removeItem('token');\r\n    localStorage.removeItem('user');\r\n    localStorage.removeItem('sessionExpiry');\r\n    localStorage.removeItem('rememberMe');\r\n    sessionStorage.removeItem('token');\r\n    sessionStorage.removeItem('user');\r\n    \r\n    // Clear API authorization header\r\n    delete api.defaults.headers.common['Authorization'];\r\n    \r\n    // Log logout event\r\n    logSecurityEvent('logout', { reason });\r\n    \r\n    // Clear refresh queue\r\n    refreshQueueRef.current = [];\r\n  }, []);\r\n\r\n  /**\r\n   * Logs security events for monitoring\r\n   */\r\n  const logSecurityEvent = useCallback((eventType, data = {}) => {\r\n    const securityEvent = {\r\n      timestamp: new Date().toISOString(),\r\n      event: eventType,\r\n      userId: user?._id,\r\n      userRole: user?.role,\r\n      ...data,\r\n      userAgent: navigator.userAgent,\r\n      ip: 'client-ip' // In production, get from request headers\r\n    };\r\n\r\n    // Log to console in development\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log('ðŸ”’ Security Event:', securityEvent);\r\n    }\r\n\r\n    // Send to security monitoring service\r\n    sendToSecurityLog(securityEvent);\r\n  }, [user]);\r\n\r\n  /**\r\n   * Sends security events to monitoring service\r\n   */\r\n  const sendToSecurityLog = useCallback((eventData) => {\r\n    try {\r\n      // Store in localStorage for debugging (remove in production)\r\n      const existingEvents = JSON.parse(localStorage.getItem('security_events') || '[]');\r\n      existingEvents.push(eventData);\r\n      \r\n      // Keep only last 50 events\r\n      if (existingEvents.length > 50) {\r\n        existingEvents.shift();\r\n      }\r\n      \r\n      localStorage.setItem('security_events', JSON.stringify(existingEvents));\r\n    } catch (e) {\r\n      // Silently fail if localStorage is not available\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Checks if user has required role(s)\r\n   */\r\n  const hasRole = useCallback((roles) => {\r\n    if (!user || !user.role) return false;\r\n    \r\n    const rolesToCheck = Array.isArray(roles) ? roles : [roles];\r\n    return rolesToCheck.includes(user.role);\r\n  }, [user]);\r\n\r\n  /**\r\n   * Checks if user has required permission(s)\r\n   */\r\n  const hasPermission = useCallback((permissions) => {\r\n    if (!user || !user.permissions) return false;\r\n    \r\n    const permissionsToCheck = Array.isArray(permissions) ? permissions : [permissions];\r\n    return permissionsToCheck.every(permission => \r\n      user.permissions.includes(permission)\r\n    );\r\n  }, [user]);\r\n\r\n  /**\r\n   * Checks if session is valid and active\r\n   */\r\n  const checkSession = useCallback(async () => {\r\n    if (!user) return false;\r\n    \r\n    try {\r\n      await authService.getCurrentUser();\r\n      return true;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }, [user]);\r\n\r\n  /**\r\n   * Updates user profile\r\n   */\r\n  const updateProfile = useCallback(async (updates) => {\r\n    try {\r\n      const response = await authService.updateProfile(updates);\r\n      \r\n      if (response.user) {\r\n        const sanitizedUser = sanitizeUserData(response.user);\r\n        setUser(sanitizedUser);\r\n        \r\n        const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\r\n        storage.setItem('user', JSON.stringify(sanitizedUser));\r\n      }\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('Profile update error:', error);\r\n      throw error;\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Changes user password\r\n   */\r\n  const changePassword = useCallback(async (currentPassword, newPassword) => {\r\n    try {\r\n      await authService.changePassword(currentPassword, newPassword);\r\n      logSecurityEvent('password_changed');\r\n    } catch (error) {\r\n      console.error('Password change error:', error);\r\n      throw error;\r\n    }\r\n  }, [logSecurityEvent]);\r\n\r\n  // Initialize authentication on mount\r\n  useEffect(() => {\r\n    initializeAuth();\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (refreshTimeoutRef.current) {\r\n        clearTimeout(refreshTimeoutRef.current);\r\n      }\r\n      if (sessionCheckIntervalRef.current) {\r\n        clearInterval(sessionCheckIntervalRef.current);\r\n      }\r\n    };\r\n  }, [initializeAuth]);\r\n\r\n  // Set up axios interceptor for token refresh\r\n  useEffect(() => {\r\n    const interceptor = api.interceptors.response.use(\r\n      (response) => response,\r\n      async (error) => {\r\n        const originalRequest = error.config;\r\n        \r\n        // If error is 401 and not a retry, try to refresh token\r\n        if (error.response?.status === 401 && !originalRequest._retry) {\r\n          originalRequest._retry = true;\r\n          \r\n          try {\r\n            await refreshToken();\r\n            \r\n            // Retry the original request with new token\r\n            const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n            originalRequest.headers.Authorization = `Bearer ${token}`;\r\n            return api(originalRequest);\r\n          } catch (refreshError) {\r\n            // Refresh failed, logout user\r\n            logout('token_refresh_failed');\r\n            return Promise.reject(refreshError);\r\n          }\r\n        }\r\n        \r\n        return Promise.reject(error);\r\n      }\r\n    );\r\n\r\n    // Cleanup interceptor\r\n    return () => {\r\n      api.interceptors.response.eject(interceptor);\r\n    };\r\n  }, [refreshToken, logout]);\r\n\r\n  // Context value\r\n  const value = {\r\n    // State\r\n    user,\r\n    loading,\r\n    sessionValid,\r\n    sessionExpiresAt,\r\n    authError,\r\n    \r\n    // Authentication methods\r\n    login,\r\n    register,\r\n    logout,\r\n    refreshToken,\r\n    checkSession,\r\n    \r\n    // User management\r\n    updateProfile,\r\n    changePassword,\r\n    \r\n    // Access control\r\n    hasRole,\r\n    hasPermission,\r\n    \r\n    // Security logging\r\n    logSecurityEvent,\r\n    \r\n    // Utility\r\n    isAuthenticated: !!user && sessionValid\r\n  };\r\n\r\n  return (\r\n    <AuthContext.Provider value={value}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n};\r\n\r\n// PropTypes\r\nAuthProvider.propTypes = {\r\n  children: PropTypes.node.isRequired\r\n};\r\n\r\n// âœ… Export both as named exports and default\r\nexport default AuthContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}