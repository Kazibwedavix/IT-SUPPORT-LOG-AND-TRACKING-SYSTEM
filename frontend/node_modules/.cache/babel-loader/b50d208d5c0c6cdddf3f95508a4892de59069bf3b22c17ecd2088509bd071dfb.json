{"ast":null,"code":"// frontend/src/services/api.js\nimport axios from 'axios';\nimport { getToken, clearTokens } from './tokenService';\n\n// Configuration\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5002/api';\nconst REQUEST_TIMEOUT = 30000; // 30 seconds\nconst MAX_RETRY_ATTEMPTS = 3;\n\n// Create axios instance\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: REQUEST_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// Flag to prevent multiple concurrent refresh attempts\nlet isRefreshing = false;\nlet failedQueue = [];\n\n// Process queue of failed requests\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\n\n// Request interceptor\napi.interceptors.request.use(async config => {\n  // Add request timestamp for monitoring\n  config.metadata = {\n    startTime: Date.now()\n  };\n\n  // Skip auth header for auth endpoints (except logout)\n  const isAuthEndpoint = config.url.includes('/auth/');\n  const isLogout = config.url.includes('/auth/logout');\n  if (!isAuthEndpoint || isLogout) {\n    const token = getToken();\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n  }\n\n  // Add request ID for tracking\n  config.headers['X-Request-ID'] = generateRequestId();\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\n\n// Response interceptor\napi.interceptors.response.use(response => {\n  var _response$config$meta;\n  const duration = Date.now() - (((_response$config$meta = response.config.metadata) === null || _response$config$meta === void 0 ? void 0 : _response$config$meta.startTime) || Date.now());\n\n  // Handle successful login response\n  if (response.config.url.includes('/auth/login') && response.data.success) {\n    const {\n      accessToken,\n      refreshToken,\n      user\n    } = response.data.data;\n    if (accessToken) {\n      // Store tokens\n      localStorage.setItem('accessToken', accessToken);\n      if (refreshToken) {\n        localStorage.setItem('refreshToken', refreshToken);\n      }\n      if (user) {\n        localStorage.setItem('user', JSON.stringify(user));\n      }\n\n      // Update axios default header\n      api.defaults.headers.common.Authorization = `Bearer ${accessToken}`;\n    }\n  }\n  return response;\n}, async error => {\n  var _error$response, _error$response2, _error$response3, _error$response4, _error$response4$data, _error$response5, _error$response6;\n  const originalRequest = error.config;\n\n  // If error is 401 and we haven't retried yet\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry) {\n    // If we're already refreshing, add to queue\n    if (isRefreshing) {\n      return new Promise((resolve, reject) => {\n        failedQueue.push({\n          resolve,\n          reject\n        });\n      }).then(token => {\n        originalRequest.headers.Authorization = `Bearer ${token}`;\n        return api(originalRequest);\n      }).catch(err => Promise.reject(err));\n    }\n    originalRequest._retry = true;\n    isRefreshing = true;\n    try {\n      // Attempt to refresh token\n      const refreshToken = localStorage.getItem('refreshToken');\n      if (!refreshToken) {\n        throw new Error('No refresh token available');\n      }\n      const refreshResponse = await axios.post(`${API_BASE_URL}/auth/refresh`, {\n        refreshToken\n      }, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        timeout: REQUEST_TIMEOUT\n      });\n      if (refreshResponse.data.success) {\n        const {\n          accessToken,\n          refreshToken: newRefreshToken\n        } = refreshResponse.data.data;\n\n        // Store new tokens\n        localStorage.setItem('accessToken', accessToken);\n        localStorage.setItem('refreshToken', newRefreshToken);\n\n        // Update axios default header\n        api.defaults.headers.common.Authorization = `Bearer ${accessToken}`;\n\n        // Update the original request\n        originalRequest.headers.Authorization = `Bearer ${accessToken}`;\n\n        // Process queued requests\n        processQueue(null, accessToken);\n\n        // Retry the original request\n        return api(originalRequest);\n      } else {\n        throw new Error('Token refresh failed');\n      }\n    } catch (refreshError) {\n      // Clear all tokens and redirect to login\n      clearTokens();\n      processQueue(refreshError, null);\n\n      // Only redirect if not already on login page\n      if (!window.location.pathname.includes('/login')) {\n        window.location.href = '/login?session=expired';\n      }\n      return Promise.reject(refreshError);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n\n  // Handle 403 - Forbidden\n  if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 403) {\n    // You can redirect to unauthorized page or show message\n    console.error('Access forbidden:', error.response.data);\n  }\n\n  // Handle 429 - Rate limiting\n  if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 429) {\n    const retryAfter = error.response.headers['retry-after'] || 60;\n    console.warn(`Rate limited. Retrying after ${retryAfter} seconds`);\n    await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));\n    return api(originalRequest);\n  }\n\n  // Handle network errors\n  if (!error.response) {\n    console.error('Network error:', error.message);\n\n    // Implement exponential backoff for retries\n    if (!originalRequest._retryCount) {\n      originalRequest._retryCount = 0;\n    }\n    if (originalRequest._retryCount < MAX_RETRY_ATTEMPTS) {\n      originalRequest._retryCount++;\n      const delay = Math.pow(2, originalRequest._retryCount) * 1000; // Exponential backoff\n\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return api(originalRequest);\n    }\n  }\n\n  // Return error response\n  return Promise.reject({\n    message: ((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || 'An error occurred',\n    status: (_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.status,\n    data: (_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.data,\n    config: error.config\n  });\n});\n\n// Generate unique request ID\nfunction generateRequestId() {\n  return 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n}\n\n// Token management functions\nexport const tokenService = {\n  getToken: () => localStorage.getItem('accessToken'),\n  getRefreshToken: () => localStorage.getItem('refreshToken'),\n  setTokens: (accessToken, refreshToken) => {\n    if (accessToken) {\n      localStorage.setItem('accessToken', accessToken);\n      api.defaults.headers.common.Authorization = `Bearer ${accessToken}`;\n    }\n    if (refreshToken) {\n      localStorage.setItem('refreshToken', refreshToken);\n    }\n  },\n  clearTokens: () => {\n    localStorage.removeItem('accessToken');\n    localStorage.removeItem('refreshToken');\n    localStorage.removeItem('user');\n    delete api.defaults.headers.common.Authorization;\n  },\n  isAuthenticated: () => {\n    const token = localStorage.getItem('accessToken');\n    return !!token;\n  }\n};\n\n// API utility functions\nexport const apiService = {\n  // Health check\n  healthCheck: async () => {\n    try {\n      const response = await api.get('/health');\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  },\n  // Set auth header manually (useful after login)\n  setAuthHeader: token => {\n    if (token) {\n      api.defaults.headers.common.Authorization = `Bearer ${token}`;\n    } else {\n      delete api.defaults.headers.common.Authorization;\n    }\n  },\n  // Clear all auth data\n  clearAuth: () => {\n    tokenService.clearTokens();\n  },\n  // Test API connection\n  testConnection: async () => {\n    try {\n      const startTime = Date.now();\n      await api.get('/health');\n      const latency = Date.now() - startTime;\n      return {\n        connected: true,\n        latency,\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      return {\n        connected: false,\n        error: error.message,\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n};\n\n// Export the configured axios instance\nexport default api;","map":{"version":3,"names":["axios","getToken","clearTokens","API_BASE_URL","process","env","REACT_APP_API_URL","REQUEST_TIMEOUT","MAX_RETRY_ATTEMPTS","api","create","baseURL","timeout","headers","isRefreshing","failedQueue","processQueue","error","token","forEach","prom","reject","resolve","interceptors","request","use","config","metadata","startTime","Date","now","isAuthEndpoint","url","includes","isLogout","Authorization","generateRequestId","Promise","response","_response$config$meta","duration","data","success","accessToken","refreshToken","user","localStorage","setItem","JSON","stringify","defaults","common","_error$response","_error$response2","_error$response3","_error$response4","_error$response4$data","_error$response5","_error$response6","originalRequest","status","_retry","push","then","catch","err","getItem","Error","refreshResponse","post","newRefreshToken","refreshError","window","location","pathname","href","console","retryAfter","warn","setTimeout","message","_retryCount","delay","Math","pow","random","toString","substr","tokenService","getRefreshToken","setTokens","removeItem","isAuthenticated","apiService","healthCheck","get","setAuthHeader","clearAuth","testConnection","latency","connected","timestamp","toISOString"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/services/api.js"],"sourcesContent":["// frontend/src/services/api.js\r\nimport axios from 'axios';\r\nimport { getToken, clearTokens } from './tokenService';\r\n\r\n// Configuration\r\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5002/api';\r\nconst REQUEST_TIMEOUT = 30000; // 30 seconds\r\nconst MAX_RETRY_ATTEMPTS = 3;\r\n\r\n// Create axios instance\r\nconst api = axios.create({\r\n  baseURL: API_BASE_URL,\r\n  timeout: REQUEST_TIMEOUT,\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n    'Accept': 'application/json',\r\n  },\r\n});\r\n\r\n// Flag to prevent multiple concurrent refresh attempts\r\nlet isRefreshing = false;\r\nlet failedQueue = [];\r\n\r\n// Process queue of failed requests\r\nconst processQueue = (error, token = null) => {\r\n  failedQueue.forEach(prom => {\r\n    if (error) {\r\n      prom.reject(error);\r\n    } else {\r\n      prom.resolve(token);\r\n    }\r\n  });\r\n  failedQueue = [];\r\n};\r\n\r\n// Request interceptor\r\napi.interceptors.request.use(\r\n  async (config) => {\r\n    // Add request timestamp for monitoring\r\n    config.metadata = { startTime: Date.now() };\r\n\r\n    // Skip auth header for auth endpoints (except logout)\r\n    const isAuthEndpoint = config.url.includes('/auth/');\r\n    const isLogout = config.url.includes('/auth/logout');\r\n    \r\n    if (!isAuthEndpoint || isLogout) {\r\n      const token = getToken();\r\n      if (token) {\r\n        config.headers.Authorization = `Bearer ${token}`;\r\n      }\r\n    }\r\n\r\n    // Add request ID for tracking\r\n    config.headers['X-Request-ID'] = generateRequestId();\r\n    \r\n    return config;\r\n  },\r\n  (error) => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Response interceptor\r\napi.interceptors.response.use(\r\n  (response) => {\r\n    const duration = Date.now() - (response.config.metadata?.startTime || Date.now());\r\n    \r\n    // Handle successful login response\r\n    if (response.config.url.includes('/auth/login') && response.data.success) {\r\n      const { accessToken, refreshToken, user } = response.data.data;\r\n      \r\n      if (accessToken) {\r\n        // Store tokens\r\n        localStorage.setItem('accessToken', accessToken);\r\n        if (refreshToken) {\r\n          localStorage.setItem('refreshToken', refreshToken);\r\n        }\r\n        if (user) {\r\n          localStorage.setItem('user', JSON.stringify(user));\r\n        }\r\n        \r\n        // Update axios default header\r\n        api.defaults.headers.common.Authorization = `Bearer ${accessToken}`;\r\n      }\r\n    }\r\n\r\n    return response;\r\n  },\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n    \r\n    // If error is 401 and we haven't retried yet\r\n    if (error.response?.status === 401 && !originalRequest._retry) {\r\n      \r\n      // If we're already refreshing, add to queue\r\n      if (isRefreshing) {\r\n        return new Promise((resolve, reject) => {\r\n          failedQueue.push({ resolve, reject });\r\n        }).then(token => {\r\n          originalRequest.headers.Authorization = `Bearer ${token}`;\r\n          return api(originalRequest);\r\n        }).catch(err => Promise.reject(err));\r\n      }\r\n\r\n      originalRequest._retry = true;\r\n      isRefreshing = true;\r\n\r\n      try {\r\n        // Attempt to refresh token\r\n        const refreshToken = localStorage.getItem('refreshToken');\r\n        \r\n        if (!refreshToken) {\r\n          throw new Error('No refresh token available');\r\n        }\r\n\r\n        const refreshResponse = await axios.post(\r\n          `${API_BASE_URL}/auth/refresh`,\r\n          { refreshToken },\r\n          { \r\n            headers: { 'Content-Type': 'application/json' },\r\n            timeout: REQUEST_TIMEOUT \r\n          }\r\n        );\r\n\r\n        if (refreshResponse.data.success) {\r\n          const { accessToken, refreshToken: newRefreshToken } = refreshResponse.data.data;\r\n          \r\n          // Store new tokens\r\n          localStorage.setItem('accessToken', accessToken);\r\n          localStorage.setItem('refreshToken', newRefreshToken);\r\n          \r\n          // Update axios default header\r\n          api.defaults.headers.common.Authorization = `Bearer ${accessToken}`;\r\n          \r\n          // Update the original request\r\n          originalRequest.headers.Authorization = `Bearer ${accessToken}`;\r\n          \r\n          // Process queued requests\r\n          processQueue(null, accessToken);\r\n          \r\n          // Retry the original request\r\n          return api(originalRequest);\r\n        } else {\r\n          throw new Error('Token refresh failed');\r\n        }\r\n      } catch (refreshError) {\r\n        // Clear all tokens and redirect to login\r\n        clearTokens();\r\n        processQueue(refreshError, null);\r\n        \r\n        // Only redirect if not already on login page\r\n        if (!window.location.pathname.includes('/login')) {\r\n          window.location.href = '/login?session=expired';\r\n        }\r\n        \r\n        return Promise.reject(refreshError);\r\n      } finally {\r\n        isRefreshing = false;\r\n      }\r\n    }\r\n\r\n    // Handle 403 - Forbidden\r\n    if (error.response?.status === 403) {\r\n      // You can redirect to unauthorized page or show message\r\n      console.error('Access forbidden:', error.response.data);\r\n    }\r\n\r\n    // Handle 429 - Rate limiting\r\n    if (error.response?.status === 429) {\r\n      const retryAfter = error.response.headers['retry-after'] || 60;\r\n      console.warn(`Rate limited. Retrying after ${retryAfter} seconds`);\r\n      \r\n      await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));\r\n      return api(originalRequest);\r\n    }\r\n\r\n    // Handle network errors\r\n    if (!error.response) {\r\n      console.error('Network error:', error.message);\r\n      \r\n      // Implement exponential backoff for retries\r\n      if (!originalRequest._retryCount) {\r\n        originalRequest._retryCount = 0;\r\n      }\r\n      \r\n      if (originalRequest._retryCount < MAX_RETRY_ATTEMPTS) {\r\n        originalRequest._retryCount++;\r\n        const delay = Math.pow(2, originalRequest._retryCount) * 1000; // Exponential backoff\r\n        \r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        return api(originalRequest);\r\n      }\r\n    }\r\n\r\n    // Return error response\r\n    return Promise.reject({\r\n      message: error.response?.data?.message || 'An error occurred',\r\n      status: error.response?.status,\r\n      data: error.response?.data,\r\n      config: error.config,\r\n    });\r\n  }\r\n);\r\n\r\n// Generate unique request ID\r\nfunction generateRequestId() {\r\n  return 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\r\n}\r\n\r\n// Token management functions\r\nexport const tokenService = {\r\n  getToken: () => localStorage.getItem('accessToken'),\r\n  getRefreshToken: () => localStorage.getItem('refreshToken'),\r\n  setTokens: (accessToken, refreshToken) => {\r\n    if (accessToken) {\r\n      localStorage.setItem('accessToken', accessToken);\r\n      api.defaults.headers.common.Authorization = `Bearer ${accessToken}`;\r\n    }\r\n    if (refreshToken) {\r\n      localStorage.setItem('refreshToken', refreshToken);\r\n    }\r\n  },\r\n  clearTokens: () => {\r\n    localStorage.removeItem('accessToken');\r\n    localStorage.removeItem('refreshToken');\r\n    localStorage.removeItem('user');\r\n    delete api.defaults.headers.common.Authorization;\r\n  },\r\n  isAuthenticated: () => {\r\n    const token = localStorage.getItem('accessToken');\r\n    return !!token;\r\n  }\r\n};\r\n\r\n// API utility functions\r\nexport const apiService = {\r\n  // Health check\r\n  healthCheck: async () => {\r\n    try {\r\n      const response = await api.get('/health');\r\n      return response.data;\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Set auth header manually (useful after login)\r\n  setAuthHeader: (token) => {\r\n    if (token) {\r\n      api.defaults.headers.common.Authorization = `Bearer ${token}`;\r\n    } else {\r\n      delete api.defaults.headers.common.Authorization;\r\n    }\r\n  },\r\n\r\n  // Clear all auth data\r\n  clearAuth: () => {\r\n    tokenService.clearTokens();\r\n  },\r\n\r\n  // Test API connection\r\n  testConnection: async () => {\r\n    try {\r\n      const startTime = Date.now();\r\n      await api.get('/health');\r\n      const latency = Date.now() - startTime;\r\n      \r\n      return {\r\n        connected: true,\r\n        latency,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        connected: false,\r\n        error: error.message,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n};\r\n\r\n// Export the configured axios instance\r\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}