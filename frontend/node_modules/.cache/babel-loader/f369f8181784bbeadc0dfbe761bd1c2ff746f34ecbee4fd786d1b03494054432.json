{"ast":null,"code":"/**\r\n * Enterprise Validation System\r\n * \r\n * Comprehensive validation utilities for the Bugema University IT Support System.\r\n * Provides robust input validation, data sanitization, and security checks.\r\n * \r\n * @module validation\r\n * @author IT Support Team\r\n * @version 2.0.0\r\n * @since 2024-01-15\r\n */\n\n/**\r\n * @typedef {Object} ValidationResult\r\n * @property {boolean} valid - Indicates if validation passed\r\n * @property {string[]} errors - Array of error messages\r\n * @property {string[]} warnings - Array of warning messages\r\n * @property {Object} sanitizedData - Cleaned and sanitized data\r\n */\n\n/**\r\n * @typedef {Object} ValidationRule\r\n * @property {string} field - Field name\r\n * @property {string} type - Data type to validate\r\n * @property {boolean} required - Whether field is required\r\n * @property {number} minLength - Minimum length for strings/arrays\r\n * @property {number} maxLength - Maximum length for strings/arrays\r\n * @property {number} min - Minimum value for numbers\r\n * @property {number} max - Maximum value for numbers\r\n * @property {RegExp} pattern - Regular expression pattern\r\n * @property {Array} enumValues - Allowed enum values\r\n * @property {Function} customValidator - Custom validation function\r\n * @property {string} errorMessage - Custom error message\r\n */\n\n/**\r\n * Ticket Data Validation\r\n * Validates all ticket-related data with strict business rules\r\n */\nclass TicketValidator {\n  /**\r\n   * Validates a complete ticket creation/update payload\r\n   * \r\n   * @param {Object} ticketData - Raw ticket data from client\r\n   * @param {boolean} isUpdate - Whether this is an update operation\r\n   * @returns {ValidationResult} Validation result with errors and sanitized data\r\n   */\n  static validateTicketData(ticketData, isUpdate = false) {\n    const result = {\n      valid: true,\n      errors: [],\n      warnings: [],\n      sanitizedData: {}\n    };\n\n    // Ensure we have data to validate\n    if (!ticketData || typeof ticketData !== 'object') {\n      result.valid = false;\n      result.errors.push('Ticket data is required and must be an object');\n      return result;\n    }\n\n    // Create a copy to avoid mutating original data\n    const data = {\n      ...ticketData\n    };\n\n    // Validate required fields for new tickets\n    if (!isUpdate) {\n      const requiredFields = ['title', 'description', 'issueType'];\n      for (const field of requiredFields) {\n        if (!data[field] || data[field].toString().trim() === '') {\n          result.valid = false;\n          result.errors.push(`${this.formatFieldName(field)} is required`);\n        }\n      }\n    }\n\n    // If we already have errors, return early to avoid further processing\n    if (result.errors.length > 0) {\n      return result;\n    }\n\n    // Validate individual fields\n    this.validateTitle(data.title, result);\n    this.validateDescription(data.description, result);\n    this.validateIssueType(data.issueType, result);\n    this.validateUrgency(data.urgency, result);\n    this.validateStatus(data.status, result, isUpdate);\n    this.validateCategory(data.category, result);\n    this.validateDepartment(data.department, result);\n    this.validateLocation(data.location, result);\n    this.validateContactInfo(data.contactInfo, result);\n    this.validateAttachments(data.attachments, result);\n    this.validateMetadata(data.metadata, result);\n\n    // Validate related entities if present\n    if (data.assignedTo) {\n      this.validateUserId(data.assignedTo, 'assignedTo', result);\n    }\n    if (data.createdBy) {\n      this.validateUserId(data.createdBy, 'createdBy', result);\n    }\n\n    // Set default values for missing optional fields\n    if (!data.urgency) {\n      result.sanitizedData.urgency = 'medium';\n    }\n    if (!data.status && !isUpdate) {\n      result.sanitizedData.status = 'open';\n    }\n\n    // Set createdAt for new tickets\n    if (!isUpdate && !data.createdAt) {\n      result.sanitizedData.createdAt = new Date().toISOString();\n    }\n\n    // Set updatedAt for all tickets\n    result.sanitizedData.updatedAt = new Date().toISOString();\n\n    // Only return sanitized data if validation passed\n    if (result.valid) {\n      var _data$title, _data$description;\n      result.sanitizedData = {\n        ...result.sanitizedData,\n        title: (_data$title = data.title) === null || _data$title === void 0 ? void 0 : _data$title.trim(),\n        description: (_data$description = data.description) === null || _data$description === void 0 ? void 0 : _data$description.trim(),\n        issueType: data.issueType,\n        urgency: data.urgency || 'medium',\n        status: data.status || 'open',\n        ...(data.category && {\n          category: data.category.trim()\n        }),\n        ...(data.department && {\n          department: data.department.trim()\n        }),\n        ...(data.location && {\n          location: data.location.trim()\n        }),\n        ...(data.contactInfo && {\n          contactInfo: this.sanitizeContactInfo(data.contactInfo)\n        }),\n        ...(data.assignedTo && {\n          assignedTo: data.assignedTo\n        }),\n        ...(data.createdBy && {\n          createdBy: data.createdBy\n        }),\n        ...(data.metadata && {\n          metadata: this.sanitizeMetadata(data.metadata)\n        })\n      };\n    }\n    return result;\n  }\n\n  /**\r\n   * Validates ticket title\r\n   * \r\n   * @param {string} title - Ticket title\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   */\n  static validateTitle(title, result) {\n    if (!title) return;\n    const trimmedTitle = title.toString().trim();\n    if (trimmedTitle.length < 5) {\n      result.valid = false;\n      result.errors.push('Title must be at least 5 characters long');\n    }\n    if (trimmedTitle.length > 200) {\n      result.valid = false;\n      result.errors.push('Title cannot exceed 200 characters');\n    }\n\n    // Check for malicious content\n    if (this.containsMaliciousContent(trimmedTitle)) {\n      result.valid = false;\n      result.errors.push('Title contains suspicious content');\n    }\n  }\n\n  /**\r\n   * Validates ticket description\r\n   * \r\n   * @param {string} description - Ticket description\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   */\n  static validateDescription(description, result) {\n    if (!description) return;\n    const trimmedDescription = description.toString().trim();\n    if (trimmedDescription.length < 10) {\n      result.valid = false;\n      result.errors.push('Description must be at least 10 characters long');\n    }\n    if (trimmedDescription.length > 5000) {\n      result.valid = false;\n      result.errors.push('Description cannot exceed 5000 characters');\n    }\n\n    // Check for malicious content\n    if (this.containsMaliciousContent(trimmedDescription)) {\n      result.valid = false;\n      result.errors.push('Description contains suspicious content');\n    }\n\n    // Check for minimum information\n    const wordCount = trimmedDescription.split(/\\s+/).length;\n    if (wordCount < 5) {\n      result.warnings.push('Description seems brief. Please provide more details for better support.');\n    }\n  }\n\n  /**\r\n   * Validates issue type\r\n   * \r\n   * @param {string} issueType - Issue type\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   */\n  static validateIssueType(issueType, result) {\n    if (!issueType) return;\n    if (!this.VALID_ISSUE_TYPES.includes(issueType.toLowerCase())) {\n      result.valid = false;\n      result.errors.push(`Issue type must be one of: ${this.VALID_ISSUE_TYPES.join(', ')}`);\n    }\n  }\n\n  /**\r\n   * Validates urgency level\r\n   * \r\n   * @param {string} urgency - Urgency level\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   */\n  static validateUrgency(urgency, result) {\n    if (!urgency) return;\n    const lowerUrgency = urgency.toLowerCase();\n    if (!this.VALID_URGENCIES.includes(lowerUrgency)) {\n      result.valid = false;\n      result.errors.push(`Urgency must be one of: ${this.VALID_URGENCIES.join(', ')}`);\n    }\n\n    // Log warning for critical urgency (requires review)\n    if (lowerUrgency === 'critical') {\n      result.warnings.push('Critical urgency tickets require immediate attention and supervisor approval.');\n    }\n  }\n\n  /**\r\n   * Validates ticket status\r\n   * \r\n   * @param {string} status - Ticket status\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   * @param {boolean} isUpdate - Whether this is an update operation\r\n   */\n  static validateStatus(status, result, isUpdate) {\n    if (!status) return;\n    const lowerStatus = status.toLowerCase();\n    if (!this.VALID_STATUSES.includes(lowerStatus)) {\n      result.valid = false;\n      result.errors.push(`Status must be one of: ${this.VALID_STATUSES.join(', ')}`);\n    }\n\n    // Business rule: Cannot reopen closed tickets without authorization\n    if (isUpdate && lowerStatus === 'open') {\n      result.warnings.push('Reopening a closed ticket requires additional authorization.');\n    }\n  }\n\n  /**\r\n   * Validates ticket category\r\n   * \r\n   * @param {string} category - Ticket category\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   */\n  static validateCategory(category, result) {\n    if (!category) return;\n    const trimmedCategory = category.toString().trim();\n    if (trimmedCategory.length > 100) {\n      result.valid = false;\n      result.errors.push('Category cannot exceed 100 characters');\n    }\n  }\n\n  /**\r\n   * Validates department\r\n   * \r\n   * @param {string} department - Department name\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   */\n  static validateDepartment(department, result) {\n    if (!department) return;\n    const trimmedDepartment = department.toString().trim();\n    if (trimmedDepartment.length > 100) {\n      result.valid = false;\n      result.errors.push('Department cannot exceed 100 characters');\n    }\n\n    // Validate against known departments\n    const validDepartments = ['IT Support', 'Academic Affairs', 'Administration', 'Finance', 'Human Resources', 'Student Services', 'Facilities', 'Library'];\n    if (!validDepartments.includes(trimmedDepartment)) {\n      result.warnings.push(`Department \"${trimmedDepartment}\" is not in the standard list.`);\n    }\n  }\n\n  /**\r\n   * Validates location information\r\n   * \r\n   * @param {string} location - Location details\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   */\n  static validateLocation(location, result) {\n    if (!location) return;\n    const trimmedLocation = location.toString().trim();\n    if (trimmedLocation.length > 200) {\n      result.valid = false;\n      result.errors.push('Location cannot exceed 200 characters');\n    }\n  }\n\n  /**\r\n   * Validates contact information\r\n   * \r\n   * @param {Object|string} contactInfo - Contact information\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   */\n  static validateContactInfo(contactInfo, result) {\n    if (!contactInfo) return;\n    if (typeof contactInfo === 'string') {\n      const trimmedContact = contactInfo.trim();\n      if (trimmedContact.length > 100) {\n        result.valid = false;\n        result.errors.push('Contact information cannot exceed 100 characters');\n      }\n\n      // Basic email validation if it looks like an email\n      if (trimmedContact.includes('@')) {\n        if (!this.isValidEmail(trimmedContact)) {\n          result.warnings.push('Contact information appears to be an email but format is invalid');\n        }\n      }\n    } else if (typeof contactInfo === 'object') {\n      // Validate structured contact info\n      if (contactInfo.email && !this.isValidEmail(contactInfo.email)) {\n        result.valid = false;\n        result.errors.push('Invalid email address in contact information');\n      }\n      if (contactInfo.phone) {\n        const phoneRegex = /^[\\+]?[1-9][\\d]{0,15}$/;\n        if (!phoneRegex.test(contactInfo.phone.replace(/\\D/g, ''))) {\n          result.warnings.push('Phone number format appears invalid');\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Validates file attachments\r\n   * \r\n   * @param {Array} attachments - File attachments\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   */\n  static validateAttachments(attachments, result) {\n    if (!attachments || !Array.isArray(attachments)) return;\n\n    // Limit number of attachments\n    if (attachments.length > 10) {\n      result.valid = false;\n      result.errors.push('Cannot attach more than 10 files');\n      return;\n    }\n    attachments.forEach((attachment, index) => {\n      if (!attachment || typeof attachment !== 'object') {\n        result.errors.push(`Attachment ${index + 1} is invalid`);\n        return;\n      }\n\n      // Validate file name\n      if (!attachment.name || attachment.name.trim() === '') {\n        result.errors.push(`Attachment ${index + 1} has no file name`);\n      }\n\n      // Validate file size\n      if (attachment.size > this.MAX_FILE_SIZE) {\n        result.valid = false;\n        result.errors.push(`Attachment \"${attachment.name}\" exceeds maximum file size of 10MB`);\n      }\n\n      // Validate file type\n      if (attachment.type && !this.ALLOWED_FILE_TYPES.includes(attachment.type)) {\n        result.valid = false;\n        result.errors.push(`File type \"${attachment.type}\" is not allowed for attachment \"${attachment.name}\"`);\n      }\n\n      // Check for malicious file names\n      if (attachment.name && this.containsMaliciousContent(attachment.name)) {\n        result.valid = false;\n        result.errors.push(`Attachment name \"${attachment.name}\" contains suspicious characters`);\n      }\n    });\n  }\n\n  /**\r\n   * Validates metadata object\r\n   * \r\n   * @param {Object} metadata - Metadata object\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   */\n  static validateMetadata(metadata, result) {\n    if (!metadata || typeof metadata !== 'object') return;\n\n    // Limit metadata size\n    const metadataStr = JSON.stringify(metadata);\n    if (metadataStr.length > 5000) {\n      result.valid = false;\n      result.errors.push('Metadata exceeds maximum size of 5KB');\n      return;\n    }\n\n    // Validate metadata keys\n    const reservedKeys = ['_id', 'createdAt', 'updatedAt', '__v'];\n    for (const key in metadata) {\n      if (reservedKeys.includes(key)) {\n        result.valid = false;\n        result.errors.push(`Metadata key \"${key}\" is reserved`);\n      }\n\n      // Check for suspicious key names\n      if (this.containsMaliciousContent(key)) {\n        result.valid = false;\n        result.errors.push(`Metadata key \"${key}\" contains suspicious characters`);\n      }\n\n      // Limit value size\n      if (typeof metadata[key] === 'string' && metadata[key].length > 1000) {\n        result.valid = false;\n        result.errors.push(`Metadata value for \"${key}\" exceeds maximum length of 1000 characters`);\n      }\n    }\n  }\n\n  /**\r\n   * Validates user ID format\r\n   * \r\n   * @param {string} userId - User ID to validate\r\n   * @param {string} fieldName - Field name for error messages\r\n   * @param {ValidationResult} result - Validation result object to update\r\n   */\n  static validateUserId(userId, fieldName, result) {\n    if (!userId) return;\n    const userIdStr = userId.toString().trim();\n\n    // MongoDB ObjectId pattern (24 hex characters)\n    const objectIdPattern = /^[0-9a-fA-F]{24}$/;\n\n    // UUID v4 pattern\n    const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n    if (!objectIdPattern.test(userIdStr) && !uuidPattern.test(userIdStr)) {\n      result.valid = false;\n      result.errors.push(`${this.formatFieldName(fieldName)} must be a valid user ID`);\n    }\n  }\n\n  /**\r\n   * Validates ticket filters for search and listing\r\n   * \r\n   * @param {Object} filters - Filter parameters\r\n   * @returns {ValidationResult} Validation result\r\n   */\n  static validateTicketFilters(filters) {\n    const result = {\n      valid: true,\n      errors: [],\n      warnings: [],\n      sanitizedData: {}\n    };\n    if (!filters || typeof filters !== 'object') {\n      return result;\n    }\n    const sanitizedFilters = {};\n\n    // Validate and sanitize each filter\n    if (filters.status) {\n      if (this.VALID_STATUSES.includes(filters.status.toLowerCase())) {\n        sanitizedFilters.status = filters.status.toLowerCase();\n      } else {\n        result.errors.push(`Invalid status filter: ${filters.status}`);\n      }\n    }\n    if (filters.urgency) {\n      if (this.VALID_URGENCIES.includes(filters.urgency.toLowerCase())) {\n        sanitizedFilters.urgency = filters.urgency.toLowerCase();\n      } else {\n        result.errors.push(`Invalid urgency filter: ${filters.urgency}`);\n      }\n    }\n    if (filters.issueType) {\n      if (this.VALID_ISSUE_TYPES.includes(filters.issueType.toLowerCase())) {\n        sanitizedFilters.issueType = filters.issueType.toLowerCase();\n      } else {\n        result.errors.push(`Invalid issue type filter: ${filters.issueType}`);\n      }\n    }\n    if (filters.search) {\n      const searchTerm = filters.search.toString().trim();\n      if (searchTerm.length > 100) {\n        result.errors.push('Search term cannot exceed 100 characters');\n      } else if (searchTerm.length > 0) {\n        sanitizedFilters.search = searchTerm;\n      }\n    }\n    if (filters.dateFrom) {\n      const dateFrom = new Date(filters.dateFrom);\n      if (!isNaN(dateFrom.getTime())) {\n        sanitizedFilters.dateFrom = dateFrom.toISOString();\n      } else {\n        result.errors.push('Invalid start date format');\n      }\n    }\n    if (filters.dateTo) {\n      const dateTo = new Date(filters.dateTo);\n      if (!isNaN(dateTo.getTime())) {\n        sanitizedFilters.dateTo = dateTo.toISOString();\n\n        // Validate date range\n        if (sanitizedFilters.dateFrom && dateTo < new Date(sanitizedFilters.dateFrom)) {\n          result.errors.push('End date cannot be before start date');\n        }\n      } else {\n        result.errors.push('Invalid end date format');\n      }\n    }\n    if (filters.page) {\n      const page = parseInt(filters.page);\n      if (!isNaN(page) && page > 0) {\n        sanitizedFilters.page = page;\n      } else {\n        result.errors.push('Page must be a positive number');\n      }\n    }\n    if (filters.limit) {\n      const limit = parseInt(filters.limit);\n      if (!isNaN(limit) && limit > 0 && limit <= 100) {\n        sanitizedFilters.limit = limit;\n      } else {\n        result.errors.push('Limit must be between 1 and 100');\n      }\n    }\n    if (filters.sortBy) {\n      const validSortFields = ['createdAt', 'updatedAt', 'title', 'urgency', 'status'];\n      if (validSortFields.includes(filters.sortBy)) {\n        sanitizedFilters.sortBy = filters.sortBy;\n      } else {\n        result.errors.push(`Invalid sort field: ${filters.sortBy}`);\n      }\n    }\n    if (filters.sortOrder) {\n      const lowerOrder = filters.sortOrder.toLowerCase();\n      if (lowerOrder === 'asc' || lowerOrder === 'desc') {\n        sanitizedFilters.sortOrder = lowerOrder;\n      } else {\n        result.errors.push('Sort order must be \"asc\" or \"desc\"');\n      }\n    }\n\n    // Set default values\n    if (!sanitizedFilters.page) sanitizedFilters.page = 1;\n    if (!sanitizedFilters.limit) sanitizedFilters.limit = 10;\n    if (!sanitizedFilters.sortBy) sanitizedFilters.sortBy = 'createdAt';\n    if (!sanitizedFilters.sortOrder) sanitizedFilters.sortOrder = 'desc';\n    result.valid = result.errors.length === 0;\n    result.sanitizedData = sanitizedFilters;\n    return result;\n  }\n\n  /**\r\n   * Validates ticket comment data\r\n   * \r\n   * @param {Object} commentData - Comment data\r\n   * @returns {ValidationResult} Validation result\r\n   */\n  static validateComment(commentData) {\n    const result = {\n      valid: true,\n      errors: [],\n      warnings: [],\n      sanitizedData: {}\n    };\n    if (!commentData || typeof commentData !== 'object') {\n      result.valid = false;\n      result.errors.push('Comment data is required');\n      return result;\n    }\n\n    // Validate content\n    if (!commentData.content || commentData.content.toString().trim() === '') {\n      result.valid = false;\n      result.errors.push('Comment content is required');\n    } else {\n      const content = commentData.content.toString().trim();\n      if (content.length < 1) {\n        result.valid = false;\n        result.errors.push('Comment cannot be empty');\n      }\n      if (content.length > 2000) {\n        result.valid = false;\n        result.errors.push('Comment cannot exceed 2000 characters');\n      }\n      if (this.containsMaliciousContent(content)) {\n        result.valid = false;\n        result.errors.push('Comment contains suspicious content');\n      }\n      result.sanitizedData.content = content;\n    }\n\n    // Validate author if provided\n    if (commentData.author) {\n      this.validateUserId(commentData.author, 'author', result);\n      if (result.valid) {\n        result.sanitizedData.author = commentData.author;\n      }\n    }\n\n    // Validate internal flag\n    if (commentData.isInternal !== undefined) {\n      if (typeof commentData.isInternal !== 'boolean') {\n        result.valid = false;\n        result.errors.push('isInternal must be a boolean value');\n      } else {\n        result.sanitizedData.isInternal = commentData.isInternal;\n      }\n    }\n\n    // Set timestamps\n    result.sanitizedData.createdAt = new Date().toISOString();\n    result.sanitizedData.updatedAt = new Date().toISOString();\n    return result;\n  }\n\n  /**\r\n   * Validates bulk operation data\r\n   * \r\n   * @param {Object} bulkData - Bulk operation data\r\n   * @returns {ValidationResult} Validation result\r\n   */\n  static validateBulkOperation(bulkData) {\n    const result = {\n      valid: true,\n      errors: [],\n      warnings: [],\n      sanitizedData: {}\n    };\n    if (!bulkData || typeof bulkData !== 'object') {\n      result.valid = false;\n      result.errors.push('Bulk operation data is required');\n      return result;\n    }\n\n    // Validate ticket IDs\n    if (!bulkData.ticketIds || !Array.isArray(bulkData.ticketIds)) {\n      result.valid = false;\n      result.errors.push('ticketIds must be an array');\n    } else if (bulkData.ticketIds.length === 0) {\n      result.valid = false;\n      result.errors.push('At least one ticket ID is required');\n    } else if (bulkData.ticketIds.length > 100) {\n      result.valid = false;\n      result.errors.push('Cannot process more than 100 tickets at once');\n    } else {\n      // Validate each ticket ID\n      const validTicketIds = [];\n      bulkData.ticketIds.forEach((id, index) => {\n        if (!id || typeof id !== 'string') {\n          result.errors.push(`Ticket ID at position ${index} is invalid`);\n        } else {\n          const objectIdPattern = /^[0-9a-fA-F]{24}$/;\n          if (!objectIdPattern.test(id)) {\n            result.errors.push(`Invalid ticket ID format at position ${index}`);\n          } else {\n            validTicketIds.push(id);\n          }\n        }\n      });\n      result.sanitizedData.ticketIds = validTicketIds;\n    }\n\n    // Validate action\n    if (!bulkData.action || typeof bulkData.action !== 'string') {\n      result.valid = false;\n      result.errors.push('Action is required');\n    } else {\n      const validActions = ['in-progress', 'resolved', 'closed', 'reopen'];\n      if (!validActions.includes(bulkData.action.toLowerCase())) {\n        result.valid = false;\n        result.errors.push(`Action must be one of: ${validActions.join(', ')}`);\n      } else {\n        result.sanitizedData.action = bulkData.action.toLowerCase();\n      }\n    }\n\n    // Validate notes (optional)\n    if (bulkData.notes) {\n      const notes = bulkData.notes.toString().trim();\n      if (notes.length > 500) {\n        result.valid = false;\n        result.errors.push('Notes cannot exceed 500 characters');\n      } else if (this.containsMaliciousContent(notes)) {\n        result.valid = false;\n        result.errors.push('Notes contain suspicious content');\n      } else {\n        result.sanitizedData.notes = notes;\n      }\n    }\n\n    // Set performer and timestamp\n    result.sanitizedData.performedAt = new Date().toISOString();\n    return result;\n  }\n\n  /**\r\n   * Utility Methods\r\n   */\n\n  /**\r\n   * Formats field names for display in error messages\r\n   * \r\n   * @param {string} fieldName - Raw field name\r\n   * @returns {string} Formatted field name\r\n   */\n  static formatFieldName(fieldName) {\n    return fieldName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).trim();\n  }\n\n  /**\r\n   * Checks if text contains potentially malicious content\r\n   * \r\n   * @param {string} text - Text to check\r\n   * @returns {boolean} True if malicious content detected\r\n   */\n  static containsMaliciousContent(text) {\n    if (!text || typeof text !== 'string') return false;\n    const maliciousPatterns = [/<script\\b[^>]*>/i,\n    // Script tags\n    /javascript:/i,\n    // JavaScript protocol\n    /on\\w+\\s*=/i,\n    // Event handlers\n    /data:/i,\n    // Data URIs\n    /vbscript:/i,\n    // VBScript\n    /expression\\s*\\(/i,\n    // CSS expressions\n    /eval\\s*\\(/i,\n    // Eval function\n    /alert\\s*\\(/i,\n    // Alert function\n    /document\\./i,\n    // Document object\n    /window\\./i,\n    // Window object\n    /localStorage\\./i,\n    // Local storage\n    /sessionStorage\\./i,\n    // Session storage\n    /\\.innerHTML/i,\n    // InnerHTML\n    /\\.outerHTML/i,\n    // OuterHTML\n    /\\.write\\s*\\(/i,\n    // Document write\n    /fromCharCode\\s*\\(/i,\n    // FromCharCode\n    /base64_decode/i,\n    // Base64 decode\n    /union\\s+select/i,\n    // SQL injection\n    /select\\s+\\*\\s+from/i,\n    // SQL injection\n    /insert\\s+into/i,\n    // SQL injection\n    /drop\\s+table/i,\n    // SQL injection\n    /delete\\s+from/i,\n    // SQL injection\n    /or\\s+1=1/i,\n    // SQL injection\n    /';/i,\n    // SQL injection\n    /\\/\\*.*\\*\\//i,\n    // SQL comments\n    /--/i,\n    // SQL comments\n    /<\\?php/i,\n    // PHP tags\n    /<\\?=/i,\n    // PHP short tags\n    /<\\?.*\\?>/i,\n    // PHP tags\n    /system\\s*\\(/i,\n    // System calls\n    /exec\\s*\\(/i,\n    // Exec calls\n    /shell_exec\\s*\\(/i,\n    // Shell exec\n    /passthru\\s*\\(/i,\n    // Passthru\n    /proc_open\\s*\\(/i,\n    // Proc open\n    /popen\\s*\\(/i // Popen\n    ];\n    for (const pattern of maliciousPatterns) {\n      if (pattern.test(text)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\r\n   * Validates email address format\r\n   * \r\n   * @param {string} email - Email address to validate\r\n   * @returns {boolean} True if email is valid\r\n   */\n  static isValidEmail(email) {\n    if (!email || typeof email !== 'string') return false;\n    const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n    if (!emailRegex.test(email)) {\n      return false;\n    }\n\n    // Additional checks\n    if (email.length > 254) return false; // RFC 5321 limit\n\n    const parts = email.split('@');\n    if (parts[0].length > 64) return false; // Local part limit\n\n    const domain = parts[1];\n    if (domain.length > 253) return false; // Domain limit\n\n    // Check for consecutive dots\n    if (email.includes('..')) return false;\n\n    // Check for spaces\n    if (email.includes(' ')) return false;\n    return true;\n  }\n\n  /**\r\n   * Sanitizes contact information object\r\n   * \r\n   * @param {Object} contactInfo - Contact information\r\n   * @returns {Object} Sanitized contact information\r\n   */\n  static sanitizeContactInfo(contactInfo) {\n    if (!contactInfo || typeof contactInfo !== 'object') {\n      return {};\n    }\n    const sanitized = {};\n    if (contactInfo.email && this.isValidEmail(contactInfo.email)) {\n      sanitized.email = contactInfo.email.trim().toLowerCase();\n    }\n    if (contactInfo.phone) {\n      // Remove all non-digit characters except leading +\n      sanitized.phone = contactInfo.phone.toString().replace(/[^\\d+]/g, '');\n    }\n    if (contactInfo.name) {\n      sanitized.name = contactInfo.name.toString().trim().substring(0, 100);\n    }\n    if (contactInfo.department) {\n      sanitized.department = contactInfo.department.toString().trim().substring(0, 100);\n    }\n    return sanitized;\n  }\n\n  /**\r\n   * Sanitizes metadata object\r\n   * \r\n   * @param {Object} metadata - Metadata object\r\n   * @returns {Object} Sanitized metadata\r\n   */\n  static sanitizeMetadata(metadata) {\n    if (!metadata || typeof metadata !== 'object') {\n      return {};\n    }\n    const sanitized = {};\n    const reservedKeys = ['_id', 'createdAt', 'updatedAt', '__v'];\n    for (const key in metadata) {\n      if (reservedKeys.includes(key)) continue;\n\n      // Skip if key contains malicious content\n      if (this.containsMaliciousContent(key)) continue;\n      const value = metadata[key];\n\n      // Only allow primitive values and simple arrays/objects\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) {\n        if (typeof value === 'string') {\n          const sanitizedValue = value.trim().substring(0, 1000);\n          if (!this.containsMaliciousContent(sanitizedValue)) {\n            sanitized[key] = sanitizedValue;\n          }\n        } else {\n          sanitized[key] = value;\n        }\n      }\n    }\n    return sanitized;\n  }\n\n  /**\r\n   * Calculates SLA due date based on urgency\r\n   * \r\n   * @param {string} urgency - Urgency level\r\n   * @param {Date} startDate - Start date (defaults to now)\r\n   * @returns {Date|null} Due date or null if invalid urgency\r\n   */\n  static calculateSLADueDate(urgency, startDate = new Date()) {\n    if (!this.PRIORITY_TIMEFRAMES[urgency]) {\n      return null;\n    }\n    const dueDate = new Date(startDate);\n    dueDate.setHours(dueDate.getHours() + this.PRIORITY_TIMEFRAMES[urgency]);\n    return dueDate;\n  }\n\n  /**\r\n   * Validates if a due date is reasonable\r\n   * \r\n   * @param {Date} dueDate - Proposed due date\r\n   * @param {string} urgency - Ticket urgency\r\n   * @returns {ValidationResult} Validation result\r\n   */\n  static validateDueDate(dueDate, urgency) {\n    const result = {\n      valid: true,\n      errors: [],\n      warnings: [],\n      sanitizedData: {}\n    };\n    if (!dueDate) {\n      return result;\n    }\n    const date = new Date(dueDate);\n    const now = new Date();\n    if (isNaN(date.getTime())) {\n      result.valid = false;\n      result.errors.push('Invalid due date format');\n      return result;\n    }\n\n    // Due date cannot be in the past\n    if (date < now) {\n      result.valid = false;\n      result.errors.push('Due date cannot be in the past');\n    }\n\n    // Due date should be within reasonable timeframe\n    const maxDays = 30;\n    const maxDate = new Date();\n    maxDate.setDate(maxDate.getDate() + maxDays);\n    if (date > maxDate) {\n      result.warnings.push('Due date is set more than 30 days in advance');\n    }\n\n    // Check against SLA guidelines\n    const slaDueDate = this.calculateSLADueDate(urgency, now);\n    if (slaDueDate && date > slaDueDate) {\n      result.warnings.push(`Due date exceeds recommended SLA timeframe for ${urgency} priority`);\n    }\n    if (result.valid) {\n      result.sanitizedData.dueDate = date.toISOString();\n    }\n    return result;\n  }\n}\n\n/**\r\n * Export the validator class and utility functions\r\n */\n/**\r\n * Ticket status enumeration\r\n * Defines all valid ticket statuses in the system\r\n */\nTicketValidator.VALID_STATUSES = ['open', 'in-progress', 'awaiting-user', 'resolved', 'closed'];\n/**\r\n * Ticket urgency levels\r\n * Defines all valid urgency levels\r\n */\nTicketValidator.VALID_URGENCIES = ['low', 'medium', 'high', 'critical'];\n/**\r\n * Ticket issue types\r\n * Defines all valid issue types in the system\r\n */\nTicketValidator.VALID_ISSUE_TYPES = ['hardware', 'software', 'network', 'account', 'security', 'other'];\n/**\r\n * Priority levels mapping\r\n * Maps urgency levels to SLA timeframes (hours)\r\n */\nTicketValidator.PRIORITY_TIMEFRAMES = {\n  'low': 72,\n  'medium': 48,\n  'high': 24,\n  'critical': 4\n};\n/**\r\n * Maximum file size for attachments (10MB)\r\n */\nTicketValidator.MAX_FILE_SIZE = 10 * 1024 * 1024;\n// 10MB\n/**\r\n * Allowed file types for attachments\r\n */\nTicketValidator.ALLOWED_FILE_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/plain', 'text/csv'];\nexport { TicketValidator };\nexport default TicketValidator;","map":{"version":3,"names":["TicketValidator","validateTicketData","ticketData","isUpdate","result","valid","errors","warnings","sanitizedData","push","data","requiredFields","field","toString","trim","formatFieldName","length","validateTitle","title","validateDescription","description","validateIssueType","issueType","validateUrgency","urgency","validateStatus","status","validateCategory","category","validateDepartment","department","validateLocation","location","validateContactInfo","contactInfo","validateAttachments","attachments","validateMetadata","metadata","assignedTo","validateUserId","createdBy","createdAt","Date","toISOString","updatedAt","_data$title","_data$description","sanitizeContactInfo","sanitizeMetadata","trimmedTitle","containsMaliciousContent","trimmedDescription","wordCount","split","VALID_ISSUE_TYPES","includes","toLowerCase","join","lowerUrgency","VALID_URGENCIES","lowerStatus","VALID_STATUSES","trimmedCategory","trimmedDepartment","validDepartments","trimmedLocation","trimmedContact","isValidEmail","email","phone","phoneRegex","test","replace","Array","isArray","forEach","attachment","index","name","size","MAX_FILE_SIZE","type","ALLOWED_FILE_TYPES","metadataStr","JSON","stringify","reservedKeys","key","userId","fieldName","userIdStr","objectIdPattern","uuidPattern","validateTicketFilters","filters","sanitizedFilters","search","searchTerm","dateFrom","isNaN","getTime","dateTo","page","parseInt","limit","sortBy","validSortFields","sortOrder","lowerOrder","validateComment","commentData","content","author","isInternal","undefined","validateBulkOperation","bulkData","ticketIds","validTicketIds","id","action","validActions","notes","performedAt","str","toUpperCase","text","maliciousPatterns","pattern","emailRegex","parts","domain","sanitized","substring","value","sanitizedValue","calculateSLADueDate","startDate","PRIORITY_TIMEFRAMES","dueDate","setHours","getHours","validateDueDate","date","now","maxDays","maxDate","setDate","getDate","slaDueDate"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/utils/validation.js"],"sourcesContent":["/**\r\n * Enterprise Validation System\r\n * \r\n * Comprehensive validation utilities for the Bugema University IT Support System.\r\n * Provides robust input validation, data sanitization, and security checks.\r\n * \r\n * @module validation\r\n * @author IT Support Team\r\n * @version 2.0.0\r\n * @since 2024-01-15\r\n */\r\n\r\n/**\r\n * @typedef {Object} ValidationResult\r\n * @property {boolean} valid - Indicates if validation passed\r\n * @property {string[]} errors - Array of error messages\r\n * @property {string[]} warnings - Array of warning messages\r\n * @property {Object} sanitizedData - Cleaned and sanitized data\r\n */\r\n\r\n/**\r\n * @typedef {Object} ValidationRule\r\n * @property {string} field - Field name\r\n * @property {string} type - Data type to validate\r\n * @property {boolean} required - Whether field is required\r\n * @property {number} minLength - Minimum length for strings/arrays\r\n * @property {number} maxLength - Maximum length for strings/arrays\r\n * @property {number} min - Minimum value for numbers\r\n * @property {number} max - Maximum value for numbers\r\n * @property {RegExp} pattern - Regular expression pattern\r\n * @property {Array} enumValues - Allowed enum values\r\n * @property {Function} customValidator - Custom validation function\r\n * @property {string} errorMessage - Custom error message\r\n */\r\n\r\n/**\r\n * Ticket Data Validation\r\n * Validates all ticket-related data with strict business rules\r\n */\r\nclass TicketValidator {\r\n    /**\r\n     * Ticket status enumeration\r\n     * Defines all valid ticket statuses in the system\r\n     */\r\n    static VALID_STATUSES = [\r\n        'open',\r\n        'in-progress',\r\n        'awaiting-user',\r\n        'resolved',\r\n        'closed'\r\n    ];\r\n\r\n    /**\r\n     * Ticket urgency levels\r\n     * Defines all valid urgency levels\r\n     */\r\n    static VALID_URGENCIES = [\r\n        'low',\r\n        'medium',\r\n        'high',\r\n        'critical'\r\n    ];\r\n\r\n    /**\r\n     * Ticket issue types\r\n     * Defines all valid issue types in the system\r\n     */\r\n    static VALID_ISSUE_TYPES = [\r\n        'hardware',\r\n        'software',\r\n        'network',\r\n        'account',\r\n        'security',\r\n        'other'\r\n    ];\r\n\r\n    /**\r\n     * Priority levels mapping\r\n     * Maps urgency levels to SLA timeframes (hours)\r\n     */\r\n    static PRIORITY_TIMEFRAMES = {\r\n        'low': 72,\r\n        'medium': 48,\r\n        'high': 24,\r\n        'critical': 4\r\n    };\r\n\r\n    /**\r\n     * Maximum file size for attachments (10MB)\r\n     */\r\n    static MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\r\n\r\n    /**\r\n     * Allowed file types for attachments\r\n     */\r\n    static ALLOWED_FILE_TYPES = [\r\n        'image/jpeg',\r\n        'image/png',\r\n        'image/gif',\r\n        'application/pdf',\r\n        'application/msword',\r\n        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n        'application/vnd.ms-excel',\r\n        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\r\n        'text/plain',\r\n        'text/csv'\r\n    ];\r\n\r\n    /**\r\n     * Validates a complete ticket creation/update payload\r\n     * \r\n     * @param {Object} ticketData - Raw ticket data from client\r\n     * @param {boolean} isUpdate - Whether this is an update operation\r\n     * @returns {ValidationResult} Validation result with errors and sanitized data\r\n     */\r\n    static validateTicketData(ticketData, isUpdate = false) {\r\n        const result = {\r\n            valid: true,\r\n            errors: [],\r\n            warnings: [],\r\n            sanitizedData: {}\r\n        };\r\n\r\n        // Ensure we have data to validate\r\n        if (!ticketData || typeof ticketData !== 'object') {\r\n            result.valid = false;\r\n            result.errors.push('Ticket data is required and must be an object');\r\n            return result;\r\n        }\r\n\r\n        // Create a copy to avoid mutating original data\r\n        const data = { ...ticketData };\r\n\r\n        // Validate required fields for new tickets\r\n        if (!isUpdate) {\r\n            const requiredFields = ['title', 'description', 'issueType'];\r\n            for (const field of requiredFields) {\r\n                if (!data[field] || data[field].toString().trim() === '') {\r\n                    result.valid = false;\r\n                    result.errors.push(`${this.formatFieldName(field)} is required`);\r\n                }\r\n            }\r\n        }\r\n\r\n        // If we already have errors, return early to avoid further processing\r\n        if (result.errors.length > 0) {\r\n            return result;\r\n        }\r\n\r\n        // Validate individual fields\r\n        this.validateTitle(data.title, result);\r\n        this.validateDescription(data.description, result);\r\n        this.validateIssueType(data.issueType, result);\r\n        this.validateUrgency(data.urgency, result);\r\n        this.validateStatus(data.status, result, isUpdate);\r\n        this.validateCategory(data.category, result);\r\n        this.validateDepartment(data.department, result);\r\n        this.validateLocation(data.location, result);\r\n        this.validateContactInfo(data.contactInfo, result);\r\n        this.validateAttachments(data.attachments, result);\r\n        this.validateMetadata(data.metadata, result);\r\n\r\n        // Validate related entities if present\r\n        if (data.assignedTo) {\r\n            this.validateUserId(data.assignedTo, 'assignedTo', result);\r\n        }\r\n\r\n        if (data.createdBy) {\r\n            this.validateUserId(data.createdBy, 'createdBy', result);\r\n        }\r\n\r\n        // Set default values for missing optional fields\r\n        if (!data.urgency) {\r\n            result.sanitizedData.urgency = 'medium';\r\n        }\r\n\r\n        if (!data.status && !isUpdate) {\r\n            result.sanitizedData.status = 'open';\r\n        }\r\n\r\n        // Set createdAt for new tickets\r\n        if (!isUpdate && !data.createdAt) {\r\n            result.sanitizedData.createdAt = new Date().toISOString();\r\n        }\r\n\r\n        // Set updatedAt for all tickets\r\n        result.sanitizedData.updatedAt = new Date().toISOString();\r\n\r\n        // Only return sanitized data if validation passed\r\n        if (result.valid) {\r\n            result.sanitizedData = {\r\n                ...result.sanitizedData,\r\n                title: data.title?.trim(),\r\n                description: data.description?.trim(),\r\n                issueType: data.issueType,\r\n                urgency: data.urgency || 'medium',\r\n                status: data.status || 'open',\r\n                ...(data.category && { category: data.category.trim() }),\r\n                ...(data.department && { department: data.department.trim() }),\r\n                ...(data.location && { location: data.location.trim() }),\r\n                ...(data.contactInfo && { contactInfo: this.sanitizeContactInfo(data.contactInfo) }),\r\n                ...(data.assignedTo && { assignedTo: data.assignedTo }),\r\n                ...(data.createdBy && { createdBy: data.createdBy }),\r\n                ...(data.metadata && { metadata: this.sanitizeMetadata(data.metadata) })\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Validates ticket title\r\n     * \r\n     * @param {string} title - Ticket title\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     */\r\n    static validateTitle(title, result) {\r\n        if (!title) return;\r\n\r\n        const trimmedTitle = title.toString().trim();\r\n        \r\n        if (trimmedTitle.length < 5) {\r\n            result.valid = false;\r\n            result.errors.push('Title must be at least 5 characters long');\r\n        }\r\n\r\n        if (trimmedTitle.length > 200) {\r\n            result.valid = false;\r\n            result.errors.push('Title cannot exceed 200 characters');\r\n        }\r\n\r\n        // Check for malicious content\r\n        if (this.containsMaliciousContent(trimmedTitle)) {\r\n            result.valid = false;\r\n            result.errors.push('Title contains suspicious content');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates ticket description\r\n     * \r\n     * @param {string} description - Ticket description\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     */\r\n    static validateDescription(description, result) {\r\n        if (!description) return;\r\n\r\n        const trimmedDescription = description.toString().trim();\r\n        \r\n        if (trimmedDescription.length < 10) {\r\n            result.valid = false;\r\n            result.errors.push('Description must be at least 10 characters long');\r\n        }\r\n\r\n        if (trimmedDescription.length > 5000) {\r\n            result.valid = false;\r\n            result.errors.push('Description cannot exceed 5000 characters');\r\n        }\r\n\r\n        // Check for malicious content\r\n        if (this.containsMaliciousContent(trimmedDescription)) {\r\n            result.valid = false;\r\n            result.errors.push('Description contains suspicious content');\r\n        }\r\n\r\n        // Check for minimum information\r\n        const wordCount = trimmedDescription.split(/\\s+/).length;\r\n        if (wordCount < 5) {\r\n            result.warnings.push('Description seems brief. Please provide more details for better support.');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates issue type\r\n     * \r\n     * @param {string} issueType - Issue type\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     */\r\n    static validateIssueType(issueType, result) {\r\n        if (!issueType) return;\r\n\r\n        if (!this.VALID_ISSUE_TYPES.includes(issueType.toLowerCase())) {\r\n            result.valid = false;\r\n            result.errors.push(\r\n                `Issue type must be one of: ${this.VALID_ISSUE_TYPES.join(', ')}`\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates urgency level\r\n     * \r\n     * @param {string} urgency - Urgency level\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     */\r\n    static validateUrgency(urgency, result) {\r\n        if (!urgency) return;\r\n\r\n        const lowerUrgency = urgency.toLowerCase();\r\n        \r\n        if (!this.VALID_URGENCIES.includes(lowerUrgency)) {\r\n            result.valid = false;\r\n            result.errors.push(\r\n                `Urgency must be one of: ${this.VALID_URGENCIES.join(', ')}`\r\n            );\r\n        }\r\n\r\n        // Log warning for critical urgency (requires review)\r\n        if (lowerUrgency === 'critical') {\r\n            result.warnings.push(\r\n                'Critical urgency tickets require immediate attention and supervisor approval.'\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates ticket status\r\n     * \r\n     * @param {string} status - Ticket status\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     * @param {boolean} isUpdate - Whether this is an update operation\r\n     */\r\n    static validateStatus(status, result, isUpdate) {\r\n        if (!status) return;\r\n\r\n        const lowerStatus = status.toLowerCase();\r\n        \r\n        if (!this.VALID_STATUSES.includes(lowerStatus)) {\r\n            result.valid = false;\r\n            result.errors.push(\r\n                `Status must be one of: ${this.VALID_STATUSES.join(', ')}`\r\n            );\r\n        }\r\n\r\n        // Business rule: Cannot reopen closed tickets without authorization\r\n        if (isUpdate && lowerStatus === 'open') {\r\n            result.warnings.push(\r\n                'Reopening a closed ticket requires additional authorization.'\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates ticket category\r\n     * \r\n     * @param {string} category - Ticket category\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     */\r\n    static validateCategory(category, result) {\r\n        if (!category) return;\r\n\r\n        const trimmedCategory = category.toString().trim();\r\n        \r\n        if (trimmedCategory.length > 100) {\r\n            result.valid = false;\r\n            result.errors.push('Category cannot exceed 100 characters');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates department\r\n     * \r\n     * @param {string} department - Department name\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     */\r\n    static validateDepartment(department, result) {\r\n        if (!department) return;\r\n\r\n        const trimmedDepartment = department.toString().trim();\r\n        \r\n        if (trimmedDepartment.length > 100) {\r\n            result.valid = false;\r\n            result.errors.push('Department cannot exceed 100 characters');\r\n        }\r\n\r\n        // Validate against known departments\r\n        const validDepartments = [\r\n            'IT Support',\r\n            'Academic Affairs',\r\n            'Administration',\r\n            'Finance',\r\n            'Human Resources',\r\n            'Student Services',\r\n            'Facilities',\r\n            'Library'\r\n        ];\r\n\r\n        if (!validDepartments.includes(trimmedDepartment)) {\r\n            result.warnings.push(\r\n                `Department \"${trimmedDepartment}\" is not in the standard list.`\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates location information\r\n     * \r\n     * @param {string} location - Location details\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     */\r\n    static validateLocation(location, result) {\r\n        if (!location) return;\r\n\r\n        const trimmedLocation = location.toString().trim();\r\n        \r\n        if (trimmedLocation.length > 200) {\r\n            result.valid = false;\r\n            result.errors.push('Location cannot exceed 200 characters');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates contact information\r\n     * \r\n     * @param {Object|string} contactInfo - Contact information\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     */\r\n    static validateContactInfo(contactInfo, result) {\r\n        if (!contactInfo) return;\r\n\r\n        if (typeof contactInfo === 'string') {\r\n            const trimmedContact = contactInfo.trim();\r\n            \r\n            if (trimmedContact.length > 100) {\r\n                result.valid = false;\r\n                result.errors.push('Contact information cannot exceed 100 characters');\r\n            }\r\n\r\n            // Basic email validation if it looks like an email\r\n            if (trimmedContact.includes('@')) {\r\n                if (!this.isValidEmail(trimmedContact)) {\r\n                    result.warnings.push('Contact information appears to be an email but format is invalid');\r\n                }\r\n            }\r\n        } else if (typeof contactInfo === 'object') {\r\n            // Validate structured contact info\r\n            if (contactInfo.email && !this.isValidEmail(contactInfo.email)) {\r\n                result.valid = false;\r\n                result.errors.push('Invalid email address in contact information');\r\n            }\r\n\r\n            if (contactInfo.phone) {\r\n                const phoneRegex = /^[\\+]?[1-9][\\d]{0,15}$/;\r\n                if (!phoneRegex.test(contactInfo.phone.replace(/\\D/g, ''))) {\r\n                    result.warnings.push('Phone number format appears invalid');\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates file attachments\r\n     * \r\n     * @param {Array} attachments - File attachments\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     */\r\n    static validateAttachments(attachments, result) {\r\n        if (!attachments || !Array.isArray(attachments)) return;\r\n\r\n        // Limit number of attachments\r\n        if (attachments.length > 10) {\r\n            result.valid = false;\r\n            result.errors.push('Cannot attach more than 10 files');\r\n            return;\r\n        }\r\n\r\n        attachments.forEach((attachment, index) => {\r\n            if (!attachment || typeof attachment !== 'object') {\r\n                result.errors.push(`Attachment ${index + 1} is invalid`);\r\n                return;\r\n            }\r\n\r\n            // Validate file name\r\n            if (!attachment.name || attachment.name.trim() === '') {\r\n                result.errors.push(`Attachment ${index + 1} has no file name`);\r\n            }\r\n\r\n            // Validate file size\r\n            if (attachment.size > this.MAX_FILE_SIZE) {\r\n                result.valid = false;\r\n                result.errors.push(\r\n                    `Attachment \"${attachment.name}\" exceeds maximum file size of 10MB`\r\n                );\r\n            }\r\n\r\n            // Validate file type\r\n            if (attachment.type && !this.ALLOWED_FILE_TYPES.includes(attachment.type)) {\r\n                result.valid = false;\r\n                result.errors.push(\r\n                    `File type \"${attachment.type}\" is not allowed for attachment \"${attachment.name}\"`\r\n                );\r\n            }\r\n\r\n            // Check for malicious file names\r\n            if (attachment.name && this.containsMaliciousContent(attachment.name)) {\r\n                result.valid = false;\r\n                result.errors.push(`Attachment name \"${attachment.name}\" contains suspicious characters`);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Validates metadata object\r\n     * \r\n     * @param {Object} metadata - Metadata object\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     */\r\n    static validateMetadata(metadata, result) {\r\n        if (!metadata || typeof metadata !== 'object') return;\r\n\r\n        // Limit metadata size\r\n        const metadataStr = JSON.stringify(metadata);\r\n        if (metadataStr.length > 5000) {\r\n            result.valid = false;\r\n            result.errors.push('Metadata exceeds maximum size of 5KB');\r\n            return;\r\n        }\r\n\r\n        // Validate metadata keys\r\n        const reservedKeys = ['_id', 'createdAt', 'updatedAt', '__v'];\r\n        for (const key in metadata) {\r\n            if (reservedKeys.includes(key)) {\r\n                result.valid = false;\r\n                result.errors.push(`Metadata key \"${key}\" is reserved`);\r\n            }\r\n\r\n            // Check for suspicious key names\r\n            if (this.containsMaliciousContent(key)) {\r\n                result.valid = false;\r\n                result.errors.push(`Metadata key \"${key}\" contains suspicious characters`);\r\n            }\r\n\r\n            // Limit value size\r\n            if (typeof metadata[key] === 'string' && metadata[key].length > 1000) {\r\n                result.valid = false;\r\n                result.errors.push(`Metadata value for \"${key}\" exceeds maximum length of 1000 characters`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates user ID format\r\n     * \r\n     * @param {string} userId - User ID to validate\r\n     * @param {string} fieldName - Field name for error messages\r\n     * @param {ValidationResult} result - Validation result object to update\r\n     */\r\n    static validateUserId(userId, fieldName, result) {\r\n        if (!userId) return;\r\n\r\n        const userIdStr = userId.toString().trim();\r\n        \r\n        // MongoDB ObjectId pattern (24 hex characters)\r\n        const objectIdPattern = /^[0-9a-fA-F]{24}$/;\r\n        \r\n        // UUID v4 pattern\r\n        const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n\r\n        if (!objectIdPattern.test(userIdStr) && !uuidPattern.test(userIdStr)) {\r\n            result.valid = false;\r\n            result.errors.push(`${this.formatFieldName(fieldName)} must be a valid user ID`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates ticket filters for search and listing\r\n     * \r\n     * @param {Object} filters - Filter parameters\r\n     * @returns {ValidationResult} Validation result\r\n     */\r\n    static validateTicketFilters(filters) {\r\n        const result = {\r\n            valid: true,\r\n            errors: [],\r\n            warnings: [],\r\n            sanitizedData: {}\r\n        };\r\n\r\n        if (!filters || typeof filters !== 'object') {\r\n            return result;\r\n        }\r\n\r\n        const sanitizedFilters = {};\r\n\r\n        // Validate and sanitize each filter\r\n        if (filters.status) {\r\n            if (this.VALID_STATUSES.includes(filters.status.toLowerCase())) {\r\n                sanitizedFilters.status = filters.status.toLowerCase();\r\n            } else {\r\n                result.errors.push(`Invalid status filter: ${filters.status}`);\r\n            }\r\n        }\r\n\r\n        if (filters.urgency) {\r\n            if (this.VALID_URGENCIES.includes(filters.urgency.toLowerCase())) {\r\n                sanitizedFilters.urgency = filters.urgency.toLowerCase();\r\n            } else {\r\n                result.errors.push(`Invalid urgency filter: ${filters.urgency}`);\r\n            }\r\n        }\r\n\r\n        if (filters.issueType) {\r\n            if (this.VALID_ISSUE_TYPES.includes(filters.issueType.toLowerCase())) {\r\n                sanitizedFilters.issueType = filters.issueType.toLowerCase();\r\n            } else {\r\n                result.errors.push(`Invalid issue type filter: ${filters.issueType}`);\r\n            }\r\n        }\r\n\r\n        if (filters.search) {\r\n            const searchTerm = filters.search.toString().trim();\r\n            \r\n            if (searchTerm.length > 100) {\r\n                result.errors.push('Search term cannot exceed 100 characters');\r\n            } else if (searchTerm.length > 0) {\r\n                sanitizedFilters.search = searchTerm;\r\n            }\r\n        }\r\n\r\n        if (filters.dateFrom) {\r\n            const dateFrom = new Date(filters.dateFrom);\r\n            if (!isNaN(dateFrom.getTime())) {\r\n                sanitizedFilters.dateFrom = dateFrom.toISOString();\r\n            } else {\r\n                result.errors.push('Invalid start date format');\r\n            }\r\n        }\r\n\r\n        if (filters.dateTo) {\r\n            const dateTo = new Date(filters.dateTo);\r\n            if (!isNaN(dateTo.getTime())) {\r\n                sanitizedFilters.dateTo = dateTo.toISOString();\r\n                \r\n                // Validate date range\r\n                if (sanitizedFilters.dateFrom && dateTo < new Date(sanitizedFilters.dateFrom)) {\r\n                    result.errors.push('End date cannot be before start date');\r\n                }\r\n            } else {\r\n                result.errors.push('Invalid end date format');\r\n            }\r\n        }\r\n\r\n        if (filters.page) {\r\n            const page = parseInt(filters.page);\r\n            if (!isNaN(page) && page > 0) {\r\n                sanitizedFilters.page = page;\r\n            } else {\r\n                result.errors.push('Page must be a positive number');\r\n            }\r\n        }\r\n\r\n        if (filters.limit) {\r\n            const limit = parseInt(filters.limit);\r\n            if (!isNaN(limit) && limit > 0 && limit <= 100) {\r\n                sanitizedFilters.limit = limit;\r\n            } else {\r\n                result.errors.push('Limit must be between 1 and 100');\r\n            }\r\n        }\r\n\r\n        if (filters.sortBy) {\r\n            const validSortFields = ['createdAt', 'updatedAt', 'title', 'urgency', 'status'];\r\n            if (validSortFields.includes(filters.sortBy)) {\r\n                sanitizedFilters.sortBy = filters.sortBy;\r\n            } else {\r\n                result.errors.push(`Invalid sort field: ${filters.sortBy}`);\r\n            }\r\n        }\r\n\r\n        if (filters.sortOrder) {\r\n            const lowerOrder = filters.sortOrder.toLowerCase();\r\n            if (lowerOrder === 'asc' || lowerOrder === 'desc') {\r\n                sanitizedFilters.sortOrder = lowerOrder;\r\n            } else {\r\n                result.errors.push('Sort order must be \"asc\" or \"desc\"');\r\n            }\r\n        }\r\n\r\n        // Set default values\r\n        if (!sanitizedFilters.page) sanitizedFilters.page = 1;\r\n        if (!sanitizedFilters.limit) sanitizedFilters.limit = 10;\r\n        if (!sanitizedFilters.sortBy) sanitizedFilters.sortBy = 'createdAt';\r\n        if (!sanitizedFilters.sortOrder) sanitizedFilters.sortOrder = 'desc';\r\n\r\n        result.valid = result.errors.length === 0;\r\n        result.sanitizedData = sanitizedFilters;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Validates ticket comment data\r\n     * \r\n     * @param {Object} commentData - Comment data\r\n     * @returns {ValidationResult} Validation result\r\n     */\r\n    static validateComment(commentData) {\r\n        const result = {\r\n            valid: true,\r\n            errors: [],\r\n            warnings: [],\r\n            sanitizedData: {}\r\n        };\r\n\r\n        if (!commentData || typeof commentData !== 'object') {\r\n            result.valid = false;\r\n            result.errors.push('Comment data is required');\r\n            return result;\r\n        }\r\n\r\n        // Validate content\r\n        if (!commentData.content || commentData.content.toString().trim() === '') {\r\n            result.valid = false;\r\n            result.errors.push('Comment content is required');\r\n        } else {\r\n            const content = commentData.content.toString().trim();\r\n            \r\n            if (content.length < 1) {\r\n                result.valid = false;\r\n                result.errors.push('Comment cannot be empty');\r\n            }\r\n\r\n            if (content.length > 2000) {\r\n                result.valid = false;\r\n                result.errors.push('Comment cannot exceed 2000 characters');\r\n            }\r\n\r\n            if (this.containsMaliciousContent(content)) {\r\n                result.valid = false;\r\n                result.errors.push('Comment contains suspicious content');\r\n            }\r\n\r\n            result.sanitizedData.content = content;\r\n        }\r\n\r\n        // Validate author if provided\r\n        if (commentData.author) {\r\n            this.validateUserId(commentData.author, 'author', result);\r\n            if (result.valid) {\r\n                result.sanitizedData.author = commentData.author;\r\n            }\r\n        }\r\n\r\n        // Validate internal flag\r\n        if (commentData.isInternal !== undefined) {\r\n            if (typeof commentData.isInternal !== 'boolean') {\r\n                result.valid = false;\r\n                result.errors.push('isInternal must be a boolean value');\r\n            } else {\r\n                result.sanitizedData.isInternal = commentData.isInternal;\r\n            }\r\n        }\r\n\r\n        // Set timestamps\r\n        result.sanitizedData.createdAt = new Date().toISOString();\r\n        result.sanitizedData.updatedAt = new Date().toISOString();\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Validates bulk operation data\r\n     * \r\n     * @param {Object} bulkData - Bulk operation data\r\n     * @returns {ValidationResult} Validation result\r\n     */\r\n    static validateBulkOperation(bulkData) {\r\n        const result = {\r\n            valid: true,\r\n            errors: [],\r\n            warnings: [],\r\n            sanitizedData: {}\r\n        };\r\n\r\n        if (!bulkData || typeof bulkData !== 'object') {\r\n            result.valid = false;\r\n            result.errors.push('Bulk operation data is required');\r\n            return result;\r\n        }\r\n\r\n        // Validate ticket IDs\r\n        if (!bulkData.ticketIds || !Array.isArray(bulkData.ticketIds)) {\r\n            result.valid = false;\r\n            result.errors.push('ticketIds must be an array');\r\n        } else if (bulkData.ticketIds.length === 0) {\r\n            result.valid = false;\r\n            result.errors.push('At least one ticket ID is required');\r\n        } else if (bulkData.ticketIds.length > 100) {\r\n            result.valid = false;\r\n            result.errors.push('Cannot process more than 100 tickets at once');\r\n        } else {\r\n            // Validate each ticket ID\r\n            const validTicketIds = [];\r\n            bulkData.ticketIds.forEach((id, index) => {\r\n                if (!id || typeof id !== 'string') {\r\n                    result.errors.push(`Ticket ID at position ${index} is invalid`);\r\n                } else {\r\n                    const objectIdPattern = /^[0-9a-fA-F]{24}$/;\r\n                    if (!objectIdPattern.test(id)) {\r\n                        result.errors.push(`Invalid ticket ID format at position ${index}`);\r\n                    } else {\r\n                        validTicketIds.push(id);\r\n                    }\r\n                }\r\n            });\r\n\r\n            result.sanitizedData.ticketIds = validTicketIds;\r\n        }\r\n\r\n        // Validate action\r\n        if (!bulkData.action || typeof bulkData.action !== 'string') {\r\n            result.valid = false;\r\n            result.errors.push('Action is required');\r\n        } else {\r\n            const validActions = ['in-progress', 'resolved', 'closed', 'reopen'];\r\n            if (!validActions.includes(bulkData.action.toLowerCase())) {\r\n                result.valid = false;\r\n                result.errors.push(\r\n                    `Action must be one of: ${validActions.join(', ')}`\r\n                );\r\n            } else {\r\n                result.sanitizedData.action = bulkData.action.toLowerCase();\r\n            }\r\n        }\r\n\r\n        // Validate notes (optional)\r\n        if (bulkData.notes) {\r\n            const notes = bulkData.notes.toString().trim();\r\n            if (notes.length > 500) {\r\n                result.valid = false;\r\n                result.errors.push('Notes cannot exceed 500 characters');\r\n            } else if (this.containsMaliciousContent(notes)) {\r\n                result.valid = false;\r\n                result.errors.push('Notes contain suspicious content');\r\n            } else {\r\n                result.sanitizedData.notes = notes;\r\n            }\r\n        }\r\n\r\n        // Set performer and timestamp\r\n        result.sanitizedData.performedAt = new Date().toISOString();\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Utility Methods\r\n     */\r\n\r\n    /**\r\n     * Formats field names for display in error messages\r\n     * \r\n     * @param {string} fieldName - Raw field name\r\n     * @returns {string} Formatted field name\r\n     */\r\n    static formatFieldName(fieldName) {\r\n        return fieldName\r\n            .replace(/([A-Z])/g, ' $1')\r\n            .replace(/^./, str => str.toUpperCase())\r\n            .trim();\r\n    }\r\n\r\n    /**\r\n     * Checks if text contains potentially malicious content\r\n     * \r\n     * @param {string} text - Text to check\r\n     * @returns {boolean} True if malicious content detected\r\n     */\r\n    static containsMaliciousContent(text) {\r\n        if (!text || typeof text !== 'string') return false;\r\n\r\n        const maliciousPatterns = [\r\n            /<script\\b[^>]*>/i,                    // Script tags\r\n            /javascript:/i,                        // JavaScript protocol\r\n            /on\\w+\\s*=/i,                          // Event handlers\r\n            /data:/i,                              // Data URIs\r\n            /vbscript:/i,                          // VBScript\r\n            /expression\\s*\\(/i,                    // CSS expressions\r\n            /eval\\s*\\(/i,                          // Eval function\r\n            /alert\\s*\\(/i,                         // Alert function\r\n            /document\\./i,                         // Document object\r\n            /window\\./i,                           // Window object\r\n            /localStorage\\./i,                     // Local storage\r\n            /sessionStorage\\./i,                   // Session storage\r\n            /\\.innerHTML/i,                        // InnerHTML\r\n            /\\.outerHTML/i,                        // OuterHTML\r\n            /\\.write\\s*\\(/i,                       // Document write\r\n            /fromCharCode\\s*\\(/i,                  // FromCharCode\r\n            /base64_decode/i,                      // Base64 decode\r\n            /union\\s+select/i,                     // SQL injection\r\n            /select\\s+\\*\\s+from/i,                 // SQL injection\r\n            /insert\\s+into/i,                      // SQL injection\r\n            /drop\\s+table/i,                       // SQL injection\r\n            /delete\\s+from/i,                      // SQL injection\r\n            /or\\s+1=1/i,                           // SQL injection\r\n            /';/i,                                 // SQL injection\r\n            /\\/\\*.*\\*\\//i,                         // SQL comments\r\n            /--/i,                                 // SQL comments\r\n            /<\\?php/i,                             // PHP tags\r\n            /<\\?=/i,                               // PHP short tags\r\n            /<\\?.*\\?>/i,                           // PHP tags\r\n            /system\\s*\\(/i,                        // System calls\r\n            /exec\\s*\\(/i,                          // Exec calls\r\n            /shell_exec\\s*\\(/i,                    // Shell exec\r\n            /passthru\\s*\\(/i,                      // Passthru\r\n            /proc_open\\s*\\(/i,                     // Proc open\r\n            /popen\\s*\\(/i                          // Popen\r\n        ];\r\n\r\n        for (const pattern of maliciousPatterns) {\r\n            if (pattern.test(text)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Validates email address format\r\n     * \r\n     * @param {string} email - Email address to validate\r\n     * @returns {boolean} True if email is valid\r\n     */\r\n    static isValidEmail(email) {\r\n        if (!email || typeof email !== 'string') return false;\r\n\r\n        const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\r\n        \r\n        if (!emailRegex.test(email)) {\r\n            return false;\r\n        }\r\n\r\n        // Additional checks\r\n        if (email.length > 254) return false; // RFC 5321 limit\r\n        \r\n        const parts = email.split('@');\r\n        if (parts[0].length > 64) return false; // Local part limit\r\n        \r\n        const domain = parts[1];\r\n        if (domain.length > 253) return false; // Domain limit\r\n        \r\n        // Check for consecutive dots\r\n        if (email.includes('..')) return false;\r\n        \r\n        // Check for spaces\r\n        if (email.includes(' ')) return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sanitizes contact information object\r\n     * \r\n     * @param {Object} contactInfo - Contact information\r\n     * @returns {Object} Sanitized contact information\r\n     */\r\n    static sanitizeContactInfo(contactInfo) {\r\n        if (!contactInfo || typeof contactInfo !== 'object') {\r\n            return {};\r\n        }\r\n\r\n        const sanitized = {};\r\n\r\n        if (contactInfo.email && this.isValidEmail(contactInfo.email)) {\r\n            sanitized.email = contactInfo.email.trim().toLowerCase();\r\n        }\r\n\r\n        if (contactInfo.phone) {\r\n            // Remove all non-digit characters except leading +\r\n            sanitized.phone = contactInfo.phone.toString().replace(/[^\\d+]/g, '');\r\n        }\r\n\r\n        if (contactInfo.name) {\r\n            sanitized.name = contactInfo.name.toString().trim().substring(0, 100);\r\n        }\r\n\r\n        if (contactInfo.department) {\r\n            sanitized.department = contactInfo.department.toString().trim().substring(0, 100);\r\n        }\r\n\r\n        return sanitized;\r\n    }\r\n\r\n    /**\r\n     * Sanitizes metadata object\r\n     * \r\n     * @param {Object} metadata - Metadata object\r\n     * @returns {Object} Sanitized metadata\r\n     */\r\n    static sanitizeMetadata(metadata) {\r\n        if (!metadata || typeof metadata !== 'object') {\r\n            return {};\r\n        }\r\n\r\n        const sanitized = {};\r\n        const reservedKeys = ['_id', 'createdAt', 'updatedAt', '__v'];\r\n\r\n        for (const key in metadata) {\r\n            if (reservedKeys.includes(key)) continue;\r\n            \r\n            // Skip if key contains malicious content\r\n            if (this.containsMaliciousContent(key)) continue;\r\n\r\n            const value = metadata[key];\r\n            \r\n            // Only allow primitive values and simple arrays/objects\r\n            if (\r\n                typeof value === 'string' ||\r\n                typeof value === 'number' ||\r\n                typeof value === 'boolean' ||\r\n                value === null\r\n            ) {\r\n                if (typeof value === 'string') {\r\n                    const sanitizedValue = value.trim().substring(0, 1000);\r\n                    if (!this.containsMaliciousContent(sanitizedValue)) {\r\n                        sanitized[key] = sanitizedValue;\r\n                    }\r\n                } else {\r\n                    sanitized[key] = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        return sanitized;\r\n    }\r\n\r\n    /**\r\n     * Calculates SLA due date based on urgency\r\n     * \r\n     * @param {string} urgency - Urgency level\r\n     * @param {Date} startDate - Start date (defaults to now)\r\n     * @returns {Date|null} Due date or null if invalid urgency\r\n     */\r\n    static calculateSLADueDate(urgency, startDate = new Date()) {\r\n        if (!this.PRIORITY_TIMEFRAMES[urgency]) {\r\n            return null;\r\n        }\r\n\r\n        const dueDate = new Date(startDate);\r\n        dueDate.setHours(dueDate.getHours() + this.PRIORITY_TIMEFRAMES[urgency]);\r\n        \r\n        return dueDate;\r\n    }\r\n\r\n    /**\r\n     * Validates if a due date is reasonable\r\n     * \r\n     * @param {Date} dueDate - Proposed due date\r\n     * @param {string} urgency - Ticket urgency\r\n     * @returns {ValidationResult} Validation result\r\n     */\r\n    static validateDueDate(dueDate, urgency) {\r\n        const result = {\r\n            valid: true,\r\n            errors: [],\r\n            warnings: [],\r\n            sanitizedData: {}\r\n        };\r\n\r\n        if (!dueDate) {\r\n            return result;\r\n        }\r\n\r\n        const date = new Date(dueDate);\r\n        const now = new Date();\r\n\r\n        if (isNaN(date.getTime())) {\r\n            result.valid = false;\r\n            result.errors.push('Invalid due date format');\r\n            return result;\r\n        }\r\n\r\n        // Due date cannot be in the past\r\n        if (date < now) {\r\n            result.valid = false;\r\n            result.errors.push('Due date cannot be in the past');\r\n        }\r\n\r\n        // Due date should be within reasonable timeframe\r\n        const maxDays = 30;\r\n        const maxDate = new Date();\r\n        maxDate.setDate(maxDate.getDate() + maxDays);\r\n        \r\n        if (date > maxDate) {\r\n            result.warnings.push('Due date is set more than 30 days in advance');\r\n        }\r\n\r\n        // Check against SLA guidelines\r\n        const slaDueDate = this.calculateSLADueDate(urgency, now);\r\n        if (slaDueDate && date > slaDueDate) {\r\n            result.warnings.push(\r\n                `Due date exceeds recommended SLA timeframe for ${urgency} priority`\r\n            );\r\n        }\r\n\r\n        if (result.valid) {\r\n            result.sanitizedData.dueDate = date.toISOString();\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Export the validator class and utility functions\r\n */\r\nexport {\r\n    TicketValidator\r\n};\r\n\r\nexport default TicketValidator;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}