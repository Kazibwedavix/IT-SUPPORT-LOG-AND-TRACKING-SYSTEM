{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\KADZ-TECH\\\\Documents\\\\dev\\\\it-support-system\\\\frontend\\\\src\\\\components\\\\ProtectedRoute.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { useAuth } from '../context/AuthContext';\nimport LoadingSpinner from '../components/LoadingSpinner';\nimport '../styles/ProtectedRoute.css';\n\n/**\r\n * ProtectedRoute Component\r\n * \r\n * Enterprise-grade route protection with:\r\n * - Authentication verification\r\n * - Role-based access control (RBAC)\r\n * - Session monitoring\r\n * - Activity logging\r\n * - Graceful error handling\r\n * - Audit trail\r\n * \r\n * @param {Object} props - Component properties\r\n * @param {ReactNode} props.children - Child components to render\r\n * @param {string|Array} props.requireRole - Required role(s) to access the route\r\n * @param {Array} props.permissions - Required permissions (fine-grained access)\r\n * @param {boolean} props.requireActiveSession - Require active session (not expired)\r\n * @param {boolean} props.logAccess - Log access attempts for auditing\r\n * @param {string} props.redirectPath - Custom redirect path when access denied\r\n * @param {Function} props.onAccessDenied - Callback when access is denied\r\n * \r\n * @version 3.0.0\r\n * @author IT Support Team\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ProtectedRoute = ({\n  children,\n  requireRole = null,\n  permissions = [],\n  requireActiveSession = true,\n  logAccess = true,\n  redirectPath = null,\n  onAccessDenied = null\n}) => {\n  _s();\n  const {\n    user,\n    loading,\n    isAuthenticated,\n    sessionValid,\n    refreshSession\n  } = useAuth();\n  const location = useLocation();\n  const [accessChecked, setAccessChecked] = useState(false);\n  const [sessionRefreshed, setSessionRefreshed] = useState(false);\n\n  // Session monitoring and refresh\n  useEffect(() => {\n    const checkAndRefreshSession = async () => {\n      if (requireActiveSession && isAuthenticated && !sessionValid) {\n        try {\n          await refreshSession();\n          setSessionRefreshed(true);\n        } catch (error) {\n          console.warn('Session refresh failed:', error);\n        }\n      }\n    };\n    checkAndRefreshSession();\n  }, [requireActiveSession, isAuthenticated, sessionValid, refreshSession]);\n\n  // Log access attempts for security auditing\n  useEffect(() => {\n    if (!loading && logAccess) {\n      logAccessAttempt();\n    }\n  }, [loading, logAccess]);\n\n  /**\r\n   * Logs access attempts for security auditing\r\n   */\n  const logAccessAttempt = () => {\n    const accessLog = {\n      timestamp: new Date().toISOString(),\n      path: location.pathname,\n      user: user ? {\n        id: user.id || user._id,\n        role: user.role,\n        email: user.email\n      } : null,\n      authenticated: isAuthenticated,\n      sessionValid: sessionValid,\n      userAgent: navigator.userAgent,\n      ip: 'client-ip-not-available' // In production, get from headers\n    };\n\n    // Log to console in development\n    if (process.env.NODE_ENV === 'development') {\n      console.log('ðŸ”’ Access Attempt:', accessLog);\n    }\n\n    // Send to logging service (Splunk, ELK, etc.)\n    sendToAuditLog(accessLog);\n  };\n\n  /**\r\n   * Sends access logs to audit service\r\n   */\n  const sendToAuditLog = logData => {\n    // Implement your audit logging service here\n    // Example: Sentry, LogRocket, custom API endpoint\n\n    try {\n      // Store in localStorage for debugging (remove in production)\n      const existingLogs = JSON.parse(localStorage.getItem('access_logs') || '[]');\n      existingLogs.push(logData);\n\n      // Keep only last 100 logs\n      if (existingLogs.length > 100) {\n        existingLogs.shift();\n      }\n      localStorage.setItem('access_logs', JSON.stringify(existingLogs));\n    } catch (e) {\n      // Silently fail if localStorage is not available\n    }\n  };\n\n  /**\r\n   * Checks if user has required role(s)\r\n   */\n  const checkRoleAccess = () => {\n    if (!requireRole) return true;\n    const requiredRoles = Array.isArray(requireRole) ? requireRole : [requireRole];\n    if (!user || !user.role) return false;\n\n    // Check role hierarchy (admin > technician > staff > student)\n    const roleHierarchy = {\n      'admin': ['admin', 'technician', 'staff', 'student'],\n      'technician': ['technician', 'staff', 'student'],\n      'staff': ['staff', 'student'],\n      'student': ['student']\n    };\n\n    // Check exact match first\n    if (requiredRoles.includes(user.role)) {\n      return true;\n    }\n\n    // Check role hierarchy\n    return requiredRoles.some(requiredRole => {\n      const allowedRoles = roleHierarchy[requiredRole] || [];\n      return allowedRoles.includes(user.role);\n    });\n  };\n\n  /**\r\n   * Checks if user has required permissions\r\n   */\n  const checkPermissionAccess = () => {\n    if (permissions.length === 0) return true;\n    if (!user || !user.permissions) return false;\n\n    // Check if user has all required permissions\n    return permissions.every(permission => user.permissions.includes(permission));\n  };\n\n  /**\r\n   * Gets appropriate redirect path based on access denial reason\r\n   */\n  const getRedirectPath = reason => {\n    if (redirectPath) return redirectPath;\n    switch (reason) {\n      case 'unauthenticated':\n        return '/login';\n      case 'session_expired':\n        return '/login?session=expired';\n      case 'insufficient_role':\n        return getRoleBasedRedirect();\n      case 'insufficient_permissions':\n        return '/dashboard?error=insufficient_permissions';\n      case 'inactive_session':\n        return '/login?session=inactive';\n      default:\n        return '/login';\n    }\n  };\n\n  /**\r\n   * Gets role-based redirect path\r\n   */\n  const getRoleBasedRedirect = () => {\n    if (!user) return '/login';\n    const roleRedirects = {\n      'admin': '/admin',\n      'technician': '/technician',\n      'staff': '/staff',\n      'student': '/student'\n    };\n    return roleRedirects[user.role] || '/dashboard';\n  };\n\n  /**\r\n   * Handles access denied scenario\r\n   */\n  const handleAccessDenied = reason => {\n    // Log access denial\n    const denialLog = {\n      timestamp: new Date().toISOString(),\n      path: location.pathname,\n      user: user ? {\n        id: user.id || user._id,\n        role: user.role,\n        email: user.email\n      } : null,\n      reason: reason,\n      requiredRole: requireRole,\n      requiredPermissions: permissions\n    };\n    console.warn('ðŸš« Access Denied:', denialLog);\n\n    // Callback for custom handling\n    if (onAccessDenied && typeof onAccessDenied === 'function') {\n      onAccessDenied(reason, location.pathname);\n    }\n\n    // Return redirect\n    return /*#__PURE__*/_jsxDEV(Navigate, {\n      to: getRedirectPath(reason),\n      replace: true,\n      state: {\n        from: location\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 225,\n      columnNumber: 12\n    }, this);\n  };\n\n  // Show loading spinner while checking authentication\n  if (loading || !sessionRefreshed && requireActiveSession && !sessionValid) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"auth-loading-container\",\n      children: /*#__PURE__*/_jsxDEV(LoadingSpinner, {\n        message: sessionRefreshed ? \"Verifying session...\" : \"Checking authentication...\",\n        fullPage: true,\n        size: \"medium\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 232,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 231,\n      columnNumber: 7\n    }, this);\n  }\n\n  // Check authentication\n  if (!isAuthenticated || !user) {\n    return handleAccessDenied('unauthenticated');\n  }\n\n  // Check session validity\n  if (requireActiveSession && !sessionValid) {\n    return handleAccessDenied('session_expired');\n  }\n\n  // Check role-based access\n  if (!checkRoleAccess()) {\n    return handleAccessDenied('insufficient_role');\n  }\n\n  // Check permission-based access\n  if (!checkPermissionAccess()) {\n    return handleAccessDenied('insufficient_permissions');\n  }\n\n  // Mark access as checked\n  if (!accessChecked) {\n    setAccessChecked(true);\n\n    // Log successful access\n    if (logAccess) {\n      console.log('âœ… Access Granted:', {\n        path: location.pathname,\n        user: user.email,\n        role: user.role,\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n\n  // Render protected content\n  return children;\n};\n\n// PropTypes for better development experience\n_s(ProtectedRoute, \"XeGfyAealnHvBWrqR+x3Tasvid0=\", false, function () {\n  return [useAuth, useLocation];\n});\n_c = ProtectedRoute;\nProtectedRoute.propTypes = {\n  children: PropTypes.node.isRequired,\n  requireRole: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n  permissions: PropTypes.arrayOf(PropTypes.string),\n  requireActiveSession: PropTypes.bool,\n  logAccess: PropTypes.bool,\n  redirectPath: PropTypes.string,\n  onAccessDenied: PropTypes.func\n};\nexport default ProtectedRoute;\nvar _c;\n$RefreshReg$(_c, \"ProtectedRoute\");","map":{"version":3,"names":["React","useEffect","useState","Navigate","useLocation","useAuth","LoadingSpinner","jsxDEV","_jsxDEV","ProtectedRoute","children","requireRole","permissions","requireActiveSession","logAccess","redirectPath","onAccessDenied","_s","user","loading","isAuthenticated","sessionValid","refreshSession","location","accessChecked","setAccessChecked","sessionRefreshed","setSessionRefreshed","checkAndRefreshSession","error","console","warn","logAccessAttempt","accessLog","timestamp","Date","toISOString","path","pathname","id","_id","role","email","authenticated","userAgent","navigator","ip","process","env","NODE_ENV","log","sendToAuditLog","logData","existingLogs","JSON","parse","localStorage","getItem","push","length","shift","setItem","stringify","e","checkRoleAccess","requiredRoles","Array","isArray","roleHierarchy","includes","some","requiredRole","allowedRoles","checkPermissionAccess","every","permission","getRedirectPath","reason","getRoleBasedRedirect","roleRedirects","handleAccessDenied","denialLog","requiredPermissions","to","replace","state","from","fileName","_jsxFileName","lineNumber","columnNumber","className","message","fullPage","size","_c","propTypes","PropTypes","node","isRequired","oneOfType","string","arrayOf","bool","func","$RefreshReg$"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/components/ProtectedRoute.js"],"sourcesContent":["import React, { useEffect, useState } from 'react';\r\nimport { Navigate, useLocation } from 'react-router-dom';\r\nimport { useAuth } from '../context/AuthContext';\r\nimport LoadingSpinner from '../components/LoadingSpinner';\r\nimport '../styles/ProtectedRoute.css';\r\n\r\n/**\r\n * ProtectedRoute Component\r\n * \r\n * Enterprise-grade route protection with:\r\n * - Authentication verification\r\n * - Role-based access control (RBAC)\r\n * - Session monitoring\r\n * - Activity logging\r\n * - Graceful error handling\r\n * - Audit trail\r\n * \r\n * @param {Object} props - Component properties\r\n * @param {ReactNode} props.children - Child components to render\r\n * @param {string|Array} props.requireRole - Required role(s) to access the route\r\n * @param {Array} props.permissions - Required permissions (fine-grained access)\r\n * @param {boolean} props.requireActiveSession - Require active session (not expired)\r\n * @param {boolean} props.logAccess - Log access attempts for auditing\r\n * @param {string} props.redirectPath - Custom redirect path when access denied\r\n * @param {Function} props.onAccessDenied - Callback when access is denied\r\n * \r\n * @version 3.0.0\r\n * @author IT Support Team\r\n */\r\nconst ProtectedRoute = ({ \r\n  children, \r\n  requireRole = null,\r\n  permissions = [],\r\n  requireActiveSession = true,\r\n  logAccess = true,\r\n  redirectPath = null,\r\n  onAccessDenied = null\r\n}) => {\r\n  const { user, loading, isAuthenticated, sessionValid, refreshSession } = useAuth();\r\n  const location = useLocation();\r\n  const [accessChecked, setAccessChecked] = useState(false);\r\n  const [sessionRefreshed, setSessionRefreshed] = useState(false);\r\n\r\n  // Session monitoring and refresh\r\n  useEffect(() => {\r\n    const checkAndRefreshSession = async () => {\r\n      if (requireActiveSession && isAuthenticated && !sessionValid) {\r\n        try {\r\n          await refreshSession();\r\n          setSessionRefreshed(true);\r\n        } catch (error) {\r\n          console.warn('Session refresh failed:', error);\r\n        }\r\n      }\r\n    };\r\n\r\n    checkAndRefreshSession();\r\n  }, [requireActiveSession, isAuthenticated, sessionValid, refreshSession]);\r\n\r\n  // Log access attempts for security auditing\r\n  useEffect(() => {\r\n    if (!loading && logAccess) {\r\n      logAccessAttempt();\r\n    }\r\n  }, [loading, logAccess]);\r\n\r\n  /**\r\n   * Logs access attempts for security auditing\r\n   */\r\n  const logAccessAttempt = () => {\r\n    const accessLog = {\r\n      timestamp: new Date().toISOString(),\r\n      path: location.pathname,\r\n      user: user ? {\r\n        id: user.id || user._id,\r\n        role: user.role,\r\n        email: user.email\r\n      } : null,\r\n      authenticated: isAuthenticated,\r\n      sessionValid: sessionValid,\r\n      userAgent: navigator.userAgent,\r\n      ip: 'client-ip-not-available' // In production, get from headers\r\n    };\r\n\r\n    // Log to console in development\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log('ðŸ”’ Access Attempt:', accessLog);\r\n    }\r\n\r\n    // Send to logging service (Splunk, ELK, etc.)\r\n    sendToAuditLog(accessLog);\r\n  };\r\n\r\n  /**\r\n   * Sends access logs to audit service\r\n   */\r\n  const sendToAuditLog = (logData) => {\r\n    // Implement your audit logging service here\r\n    // Example: Sentry, LogRocket, custom API endpoint\r\n    \r\n    try {\r\n      // Store in localStorage for debugging (remove in production)\r\n      const existingLogs = JSON.parse(localStorage.getItem('access_logs') || '[]');\r\n      existingLogs.push(logData);\r\n      \r\n      // Keep only last 100 logs\r\n      if (existingLogs.length > 100) {\r\n        existingLogs.shift();\r\n      }\r\n      \r\n      localStorage.setItem('access_logs', JSON.stringify(existingLogs));\r\n    } catch (e) {\r\n      // Silently fail if localStorage is not available\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Checks if user has required role(s)\r\n   */\r\n  const checkRoleAccess = () => {\r\n    if (!requireRole) return true;\r\n    \r\n    const requiredRoles = Array.isArray(requireRole) ? requireRole : [requireRole];\r\n    \r\n    if (!user || !user.role) return false;\r\n    \r\n    // Check role hierarchy (admin > technician > staff > student)\r\n    const roleHierarchy = {\r\n      'admin': ['admin', 'technician', 'staff', 'student'],\r\n      'technician': ['technician', 'staff', 'student'],\r\n      'staff': ['staff', 'student'],\r\n      'student': ['student']\r\n    };\r\n    \r\n    // Check exact match first\r\n    if (requiredRoles.includes(user.role)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check role hierarchy\r\n    return requiredRoles.some(requiredRole => {\r\n      const allowedRoles = roleHierarchy[requiredRole] || [];\r\n      return allowedRoles.includes(user.role);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Checks if user has required permissions\r\n   */\r\n  const checkPermissionAccess = () => {\r\n    if (permissions.length === 0) return true;\r\n    \r\n    if (!user || !user.permissions) return false;\r\n    \r\n    // Check if user has all required permissions\r\n    return permissions.every(permission => \r\n      user.permissions.includes(permission)\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Gets appropriate redirect path based on access denial reason\r\n   */\r\n  const getRedirectPath = (reason) => {\r\n    if (redirectPath) return redirectPath;\r\n    \r\n    switch (reason) {\r\n      case 'unauthenticated':\r\n        return '/login';\r\n      case 'session_expired':\r\n        return '/login?session=expired';\r\n      case 'insufficient_role':\r\n        return getRoleBasedRedirect();\r\n      case 'insufficient_permissions':\r\n        return '/dashboard?error=insufficient_permissions';\r\n      case 'inactive_session':\r\n        return '/login?session=inactive';\r\n      default:\r\n        return '/login';\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Gets role-based redirect path\r\n   */\r\n  const getRoleBasedRedirect = () => {\r\n    if (!user) return '/login';\r\n    \r\n    const roleRedirects = {\r\n      'admin': '/admin',\r\n      'technician': '/technician',\r\n      'staff': '/staff',\r\n      'student': '/student'\r\n    };\r\n    \r\n    return roleRedirects[user.role] || '/dashboard';\r\n  };\r\n\r\n  /**\r\n   * Handles access denied scenario\r\n   */\r\n  const handleAccessDenied = (reason) => {\r\n    // Log access denial\r\n    const denialLog = {\r\n      timestamp: new Date().toISOString(),\r\n      path: location.pathname,\r\n      user: user ? {\r\n        id: user.id || user._id,\r\n        role: user.role,\r\n        email: user.email\r\n      } : null,\r\n      reason: reason,\r\n      requiredRole: requireRole,\r\n      requiredPermissions: permissions\r\n    };\r\n    \r\n    console.warn('ðŸš« Access Denied:', denialLog);\r\n    \r\n    // Callback for custom handling\r\n    if (onAccessDenied && typeof onAccessDenied === 'function') {\r\n      onAccessDenied(reason, location.pathname);\r\n    }\r\n    \r\n    // Return redirect\r\n    return <Navigate to={getRedirectPath(reason)} replace state={{ from: location }} />;\r\n  };\r\n\r\n  // Show loading spinner while checking authentication\r\n  if (loading || (!sessionRefreshed && requireActiveSession && !sessionValid)) {\r\n    return (\r\n      <div className=\"auth-loading-container\">\r\n        <LoadingSpinner \r\n          message={sessionRefreshed ? \"Verifying session...\" : \"Checking authentication...\"} \r\n          fullPage={true}\r\n          size=\"medium\"\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Check authentication\r\n  if (!isAuthenticated || !user) {\r\n    return handleAccessDenied('unauthenticated');\r\n  }\r\n\r\n  // Check session validity\r\n  if (requireActiveSession && !sessionValid) {\r\n    return handleAccessDenied('session_expired');\r\n  }\r\n\r\n  // Check role-based access\r\n  if (!checkRoleAccess()) {\r\n    return handleAccessDenied('insufficient_role');\r\n  }\r\n\r\n  // Check permission-based access\r\n  if (!checkPermissionAccess()) {\r\n    return handleAccessDenied('insufficient_permissions');\r\n  }\r\n\r\n  // Mark access as checked\r\n  if (!accessChecked) {\r\n    setAccessChecked(true);\r\n    \r\n    // Log successful access\r\n    if (logAccess) {\r\n      console.log('âœ… Access Granted:', {\r\n        path: location.pathname,\r\n        user: user.email,\r\n        role: user.role,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n    }\r\n  }\r\n\r\n  // Render protected content\r\n  return children;\r\n};\r\n\r\n// PropTypes for better development experience\r\nProtectedRoute.propTypes = {\r\n  children: PropTypes.node.isRequired,\r\n  requireRole: PropTypes.oneOfType([\r\n    PropTypes.string,\r\n    PropTypes.arrayOf(PropTypes.string)\r\n  ]),\r\n  permissions: PropTypes.arrayOf(PropTypes.string),\r\n  requireActiveSession: PropTypes.bool,\r\n  logAccess: PropTypes.bool,\r\n  redirectPath: PropTypes.string,\r\n  onAccessDenied: PropTypes.func\r\n};\r\n\r\nexport default ProtectedRoute;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}