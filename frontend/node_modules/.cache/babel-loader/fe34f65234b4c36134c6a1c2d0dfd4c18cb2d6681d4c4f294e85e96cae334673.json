{"ast":null,"code":"// frontend/src/services/authService.js\n/**\r\n * Enterprise Authentication Service\r\n * \r\n * Production-grade authentication service with comprehensive\r\n * security features, monitoring, and enterprise patterns.\r\n * \r\n * Features:\r\n * - JWT token management with refresh tokens\r\n * - Secure HTTP-only cookie handling\r\n * - Comprehensive error handling\r\n * - Security event tracking\r\n * - Rate limiting awareness\r\n * - Audit logging\r\n * - Session management\r\n * - Token refresh automation\r\n * - Offline detection\r\n * - Network retry logic\r\n * - Cache management\r\n * \r\n * @version 4.0.1\r\n * @author Bugema University IT Support System\r\n */\n\nimport api from './api';\n\n// Constants\nconst TOKEN_REFRESH_THRESHOLD = 5 * 60 * 1000; // 5 minutes before expiry\nconst MAX_RETRY_ATTEMPTS = 3;\nconst RETRY_DELAY = 1000; // 1 second\nconst OFFLINE_CHECK_INTERVAL = 30000; // 30 seconds\n\n// Security event tracking\nclass SecurityMonitor {\n  constructor() {\n    this.events = [];\n    this.maxEvents = 100;\n  }\n  log(eventType, data = {}) {\n    const event = {\n      id: crypto.randomUUID(),\n      timestamp: new Date().toISOString(),\n      type: eventType,\n      ...data,\n      userAgent: navigator.userAgent,\n      url: window.location.href\n    };\n\n    // Development logging\n    if (process.env.NODE_ENV === 'development') {\n      console.group('ðŸ” Security Event');\n      console.log('Type:', eventType);\n      console.log('Data:', data);\n      console.log('Timestamp:', event.timestamp);\n      console.groupEnd();\n    }\n\n    // Store event\n    this.events.unshift(event);\n    if (this.events.length > this.maxEvents) {\n      this.events.pop();\n    }\n\n    // Persist to localStorage for debugging\n    this.persistEvents();\n\n    // Send to security monitoring in production\n    if (process.env.NODE_ENV === 'production') {\n      this.sendToMonitoring(event);\n    }\n  }\n  persistEvents() {\n    try {\n      localStorage.setItem('auth_security_events', JSON.stringify(this.events));\n    } catch (e) {\n      // Silently fail if localStorage is not available\n    }\n  }\n  sendToMonitoring(event) {\n    // Implement with your security monitoring service\n    // Example: Sentry, LogRocket, custom API\n    console.log('[Security Monitor]', event);\n  }\n  getEvents(limit = 50) {\n    return this.events.slice(0, limit);\n  }\n  clearEvents() {\n    this.events = [];\n    localStorage.removeItem('auth_security_events');\n  }\n}\n\n// Initialize security monitor\nconst securityMonitor = new SecurityMonitor();\n\n// Token management\nclass TokenManager {\n  constructor() {\n    this.accessToken = null;\n    this.refreshToken = null;\n    this.tokenExpiry = null;\n    this.isRefreshing = false;\n    this.refreshQueue = [];\n  }\n  async getAccessToken() {\n    // Check if token is expired or about to expire\n    if (this.accessToken && this.tokenExpiry) {\n      const timeToExpiry = this.tokenExpiry - Date.now();\n      if (timeToExpiry < TOKEN_REFRESH_THRESHOLD) {\n        await this.refreshAccessToken();\n      }\n    }\n    return this.accessToken;\n  }\n  async refreshAccessToken() {\n    if (this.isRefreshing) {\n      // Wait for the ongoing refresh to complete\n      return new Promise((resolve, reject) => {\n        this.refreshQueue.push({\n          resolve,\n          reject\n        });\n      });\n    }\n    this.isRefreshing = true;\n    try {\n      const response = await api.post('/auth/refresh', {}, {\n        withCredentials: true // Important for HTTP-only cookies\n      });\n      const {\n        accessToken\n      } = response.data;\n      if (accessToken) {\n        this.setTokens(accessToken, this.refreshToken);\n\n        // Resolve all queued requests\n        this.refreshQueue.forEach(({\n          resolve\n        }) => resolve(accessToken));\n      }\n      return accessToken;\n    } catch (error) {\n      // Reject all queued requests\n      this.refreshQueue.forEach(({\n        reject\n      }) => reject(error));\n      throw error;\n    } finally {\n      this.isRefreshing = false;\n      this.refreshQueue = [];\n    }\n  }\n  setTokens(accessToken, refreshToken) {\n    this.accessToken = accessToken;\n    this.refreshToken = refreshToken;\n\n    // Calculate token expiry (assuming 15 minutes from now)\n    this.tokenExpiry = Date.now() + 15 * 60 * 1000;\n\n    // Store in memory only (cookies are HTTP-only)\n    sessionStorage.setItem('token_refresh_time', Date.now().toString());\n  }\n  clearTokens() {\n    this.accessToken = null;\n    this.refreshToken = null;\n    this.tokenExpiry = null;\n    sessionStorage.removeItem('token_refresh_time');\n  }\n}\n\n// Initialize token manager\nconst tokenManager = new TokenManager();\n\n// Request interceptor\napi.interceptors.request.use(async config => {\n  // Skip token for auth endpoints except logout\n  if (config.url.includes('/auth/') && !config.url.includes('/auth/logout')) {\n    return config;\n  }\n\n  // Add access token if available\n  const accessToken = await tokenManager.getAccessToken();\n  if (accessToken) {\n    config.headers.Authorization = `Bearer ${accessToken}`;\n  }\n\n  // Add request ID for tracking\n  config.headers['X-Request-ID'] = crypto.randomUUID();\n\n  // Add timestamp for monitoring\n  config.metadata = {\n    startTime: Date.now(),\n    url: config.url,\n    method: config.method\n  };\n  return config;\n}, error => {\n  var _error$config;\n  securityMonitor.log('request_interceptor_error', {\n    error: error.message,\n    url: (_error$config = error.config) === null || _error$config === void 0 ? void 0 : _error$config.url\n  });\n  return Promise.reject(error);\n});\n\n// Response interceptor\napi.interceptors.response.use(response => {\n  var _config$metadata;\n  const {\n    config,\n    data\n  } = response;\n  const duration = Date.now() - (((_config$metadata = config.metadata) === null || _config$metadata === void 0 ? void 0 : _config$metadata.startTime) || Date.now());\n\n  // Log successful requests\n  if (config.url.includes('/auth/')) {\n    securityMonitor.log('auth_request_success', {\n      endpoint: config.url,\n      method: config.method,\n      duration: `${duration}ms`,\n      status: response.status\n    });\n  }\n\n  // Handle token in response for login/register\n  if (config.url.includes('/auth/login') || config.url.includes('/auth/register')) {\n    var _data$data;\n    if ((_data$data = data.data) !== null && _data$data !== void 0 && _data$data.accessToken) {\n      tokenManager.setTokens(data.data.accessToken, data.data.refreshToken);\n    }\n  }\n  return response;\n}, async error => {\n  var _config$url;\n  const {\n    config,\n    response\n  } = error;\n  const originalRequest = config;\n\n  // Log failed requests\n  if (config !== null && config !== void 0 && (_config$url = config.url) !== null && _config$url !== void 0 && _config$url.includes('/auth/')) {\n    securityMonitor.log('auth_request_failed', {\n      endpoint: config.url,\n      method: config.method,\n      status: response === null || response === void 0 ? void 0 : response.status,\n      error: error.message,\n      retryCount: originalRequest._retryCount || 0\n    });\n  }\n\n  // Handle 401 - Unauthorized (token expired)\n  if ((response === null || response === void 0 ? void 0 : response.status) === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    try {\n      // Attempt to refresh token\n      await tokenManager.refreshAccessToken();\n\n      // Retry the original request\n      return api(originalRequest);\n    } catch (refreshError) {\n      // Refresh failed, clear tokens and redirect to login\n      tokenManager.clearTokens();\n      window.location.href = '/login?session=expired';\n      return Promise.reject(refreshError);\n    }\n  }\n\n  // Handle 429 - Rate limited\n  if ((response === null || response === void 0 ? void 0 : response.status) === 429) {\n    const retryAfter = response.headers['retry-after'] || 60;\n    securityMonitor.log('rate_limited', {\n      endpoint: config.url,\n      retryAfter,\n      timestamp: new Date().toISOString()\n    });\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve(api(originalRequest));\n      }, retryAfter * 1000);\n    });\n  }\n\n  // Handle network errors with retry logic\n  if (!response && originalRequest._retryCount < MAX_RETRY_ATTEMPTS) {\n    originalRequest._retryCount = (originalRequest._retryCount || 0) + 1;\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve(api(originalRequest));\n      }, RETRY_DELAY * Math.pow(2, originalRequest._retryCount - 1));\n    });\n  }\n  return Promise.reject(error);\n});\n\n// Offline detection\nclass NetworkMonitor {\n  constructor() {\n    this.isOnline = navigator.onLine;\n    this.listeners = [];\n    window.addEventListener('online', () => this.handleOnline());\n    window.addEventListener('offline', () => this.handleOffline());\n\n    // Periodic connectivity check\n    setInterval(() => this.checkConnectivity(), OFFLINE_CHECK_INTERVAL);\n  }\n  handleOnline() {\n    this.isOnline = true;\n    securityMonitor.log('network_online');\n    this.notifyListeners(true);\n  }\n  handleOffline() {\n    this.isOnline = false;\n    securityMonitor.log('network_offline');\n    this.notifyListeners(false);\n  }\n  checkConnectivity() {\n    // Implement custom connectivity check if needed\n    const wasOnline = this.isOnline;\n    this.isOnline = navigator.onLine;\n    if (wasOnline !== this.isOnline) {\n      securityMonitor.log(this.isOnline ? 'network_restored' : 'network_lost');\n      this.notifyListeners(this.isOnline);\n    }\n  }\n  addListener(listener) {\n    this.listeners.push(listener);\n  }\n  notifyListeners(isOnline) {\n    this.listeners.forEach(listener => listener(isOnline));\n  }\n  isConnected() {\n    return this.isOnline;\n  }\n}\n\n// Initialize network monitor\nconst networkMonitor = new NetworkMonitor();\n\n// Main auth service\nconst authService = {\n  /**\r\n   * Register new user with comprehensive validation\r\n   * \r\n   * @param {Object} userData - User registration data\r\n   * @returns {Promise<Object>} Registration response\r\n   */\n  register: async userData => {\n    try {\n      var _userData$firstName, _userData$lastName, _data$user, _data$user2, _data$user3;\n      securityMonitor.log('registration_attempt', {\n        email: userData.email,\n        role: userData.role,\n        hasStudentId: !!userData.studentId\n      });\n      console.log('ðŸ” Received registration data:', userData);\n\n      // Validate required fields\n      const requiredFields = ['username', 'email', 'password', 'role'];\n      const missingFields = requiredFields.filter(field => !userData[field]);\n      if (missingFields.length > 0) {\n        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n      }\n\n      // Prepare registration data\n      const registrationData = {\n        username: userData.username.trim(),\n        email: userData.email.toLowerCase().trim(),\n        password: userData.password,\n        role: userData.role,\n        firstName: (_userData$firstName = userData.firstName) === null || _userData$firstName === void 0 ? void 0 : _userData$firstName.trim(),\n        lastName: (_userData$lastName = userData.lastName) === null || _userData$lastName === void 0 ? void 0 : _userData$lastName.trim(),\n        phone: userData.phone,\n        metadata: {\n          registrationSource: 'web',\n          userAgent: navigator.userAgent,\n          screenResolution: `${window.screen.width}x${window.screen.height}`,\n          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n          isPersonalEmail: userData.isPersonalEmail || false\n        }\n      };\n\n      // Add role-specific fields with proper department mapping\n      if (userData.role === 'student') {\n        // For students - use academicInfo with lowercase department\n        if (userData.department) {\n          var _userData$studentId;\n          registrationData.academicInfo = {\n            studentId: (_userData$studentId = userData.studentId) === null || _userData$studentId === void 0 ? void 0 : _userData$studentId.trim().toUpperCase(),\n            department: userData.department.trim(),\n            // lowercase for academicInfo.department\n            campus: userData.campus || 'BU',\n            yearOfEntry: userData.yearOfEntry || new Date().getFullYear(),\n            semester: userData.semester || 1,\n            academicStatus: 'active'\n          };\n        } else {\n          throw new Error('Department is required for student accounts');\n        }\n      } else {\n        // For staff, technician, admin - use professionalInfo with UPPERCASE department\n        if (userData.department) {\n          // Convert department to UPPERCASE for professional roles\n          const professionalDepartment = userData.department.toUpperCase();\n          registrationData.professionalInfo = {\n            department: professionalDepartment,\n            // UPPERCASE for professionalInfo.department\n            employmentType: 'FULL_TIME'\n          };\n\n          // Add employee ID if provided\n          if (userData.employeeId) {\n            registrationData.professionalInfo.employeeId = userData.employeeId.trim().toUpperCase();\n          }\n        } else {\n          throw new Error('Department is required for staff/technician/admin accounts');\n        }\n      }\n\n      // Add student-specific fields at root level if they exist\n      if (userData.studentId && userData.role === 'student') {\n        registrationData.studentId = userData.studentId.trim().toUpperCase();\n      }\n      console.log('ðŸ” Final registration payload:', JSON.stringify(registrationData, null, 2));\n      const response = await api.post('/auth/register', registrationData);\n      console.log('ðŸ” Registration response:', response.data);\n      if (!response.data.success) {\n        console.error('âŒ Backend returned success: false', response.data);\n        throw new Error(response.data.message || 'Registration failed');\n      }\n      const {\n        data\n      } = response.data;\n      securityMonitor.log('registration_success', {\n        userId: (_data$user = data.user) === null || _data$user === void 0 ? void 0 : _data$user.id,\n        email: (_data$user2 = data.user) === null || _data$user2 === void 0 ? void 0 : _data$user2.email,\n        role: (_data$user3 = data.user) === null || _data$user3 === void 0 ? void 0 : _data$user3.role,\n        requiresEmailVerification: data.requiresEmailVerification\n      });\n      return {\n        success: true,\n        message: response.data.message,\n        data: {\n          user: data.user,\n          accessToken: data.accessToken,\n          requiresEmailVerification: data.requiresEmailVerification\n        }\n      };\n    } catch (error) {\n      var _error$response, _error$response2, _error$response3, _error$response4, _error$response5;\n      console.error('ðŸ”¥ REGISTRATION API ERROR DETAILS:');\n      console.error('ðŸ”¥ Error:', error.message);\n      console.error('ðŸ”¥ Error response:', (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data);\n      console.error('ðŸ”¥ Error status:', (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status);\n      securityMonitor.log('registration_failed', {\n        email: userData === null || userData === void 0 ? void 0 : userData.email,\n        role: userData === null || userData === void 0 ? void 0 : userData.role,\n        error: error.message,\n        response: (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data,\n        status: (_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status\n      });\n      let errorMessage = 'Registration failed. Please try again.';\n      if ((_error$response5 = error.response) !== null && _error$response5 !== void 0 && _error$response5.data) {\n        const {\n          message,\n          code,\n          errors\n        } = error.response.data;\n        console.error('ðŸ”¥ Backend error details:', {\n          message,\n          code,\n          errors\n        });\n        if (code === 'EMAIL_EXISTS') {\n          errorMessage = 'An account with this email already exists.';\n        } else if (code === 'USERNAME_EXISTS') {\n          errorMessage = 'This username is already taken.';\n        } else if (code === 'STUDENT_ID_EXISTS') {\n          errorMessage = 'This student ID is already registered.';\n        } else if (code === 'EMPLOYEE_ID_EXISTS') {\n          errorMessage = 'This employee ID is already registered.';\n        } else if (code === 'VALIDATION_ERROR') {\n          // Handle Mongoose validation errors\n          if (errors !== null && errors !== void 0 && errors.length) {\n            errorMessage = errors.map(e => e.message || e.msg).join('. ');\n          } else if (message) {\n            errorMessage = message;\n          }\n        } else if (message) {\n          errorMessage = message;\n        }\n      } else if (error.message.includes('Network Error')) {\n        errorMessage = 'Cannot connect to server. Please check your internet connection.';\n      } else if (error.request) {\n        console.error('ðŸ”¥ No response received:', error.request);\n        errorMessage = 'No response from server. Please try again.';\n      }\n      throw new Error(errorMessage);\n    }\n  },\n  /**\r\n   * User login with credentials\r\n   * \r\n   * @param {string} email - User email\r\n   * @param {string} password - User password\r\n   * @param {boolean} rememberMe - Remember login\r\n   * @returns {Promise<Object>} Authentication response\r\n   */\n  login: async (email, password, rememberMe = false) => {\n    try {\n      var _data$user4, _data$user5, _data$user6;\n      securityMonitor.log('login_attempt', {\n        email,\n        rememberMe\n      });\n      if (!email || !password) {\n        throw new Error('Email and password are required');\n      }\n      const response = await api.post('/auth/login', {\n        email: email.toLowerCase().trim(),\n        password: password.trim(),\n        rememberMe\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Login failed');\n      }\n      const {\n        data\n      } = response.data;\n      securityMonitor.log('login_success', {\n        userId: (_data$user4 = data.user) === null || _data$user4 === void 0 ? void 0 : _data$user4.id,\n        email: (_data$user5 = data.user) === null || _data$user5 === void 0 ? void 0 : _data$user5.email,\n        role: (_data$user6 = data.user) === null || _data$user6 === void 0 ? void 0 : _data$user6.role,\n        requiresEmailVerification: data.requiresEmailVerification\n      });\n      return {\n        success: true,\n        message: response.data.message,\n        data: {\n          user: data.user,\n          accessToken: data.accessToken,\n          refreshToken: data.refreshToken,\n          requiresEmailVerification: data.requiresEmailVerification\n        }\n      };\n    } catch (error) {\n      var _error$response6, _error$response7, _error$response7$data, _error$response8;\n      securityMonitor.log('login_failed', {\n        email,\n        error: error.message,\n        status: (_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status,\n        code: (_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : (_error$response7$data = _error$response7.data) === null || _error$response7$data === void 0 ? void 0 : _error$response7$data.code\n      });\n      let errorMessage = 'Login failed. Please check your credentials.';\n      if ((_error$response8 = error.response) !== null && _error$response8 !== void 0 && _error$response8.data) {\n        const {\n          message,\n          code,\n          attemptsLeft,\n          locked\n        } = error.response.data;\n        if (code === 'ACCOUNT_LOCKED') {\n          errorMessage = `Account is locked. Try again in ${error.response.data.lockDuration} minutes.`;\n        } else if (code === 'ACCOUNT_INACTIVE') {\n          errorMessage = 'Account is deactivated. Please contact support.';\n        } else if (code === 'INVALID_CREDENTIALS') {\n          if (attemptsLeft > 0) {\n            errorMessage = `Invalid credentials. ${attemptsLeft} attempts remaining.`;\n          } else if (locked) {\n            errorMessage = 'Account locked due to too many failed attempts.';\n          }\n        } else if (message) {\n          errorMessage = message;\n        }\n      } else if (error.message.includes('Network Error')) {\n        errorMessage = 'Cannot connect to server. Please check your internet connection.';\n      }\n      throw new Error(errorMessage);\n    }\n  },\n  /**\r\n   * Logout user and clear tokens\r\n   * \r\n   * @returns {Promise<Object>} Logout response\r\n   */\n  logout: async () => {\n    try {\n      securityMonitor.log('logout_attempt');\n      await api.post('/auth/logout', {}, {\n        withCredentials: true\n      });\n\n      // Clear local tokens\n      tokenManager.clearTokens();\n\n      // Clear any stored user data\n      sessionStorage.clear();\n      localStorage.removeItem('user_data');\n      securityMonitor.log('logout_success');\n      return {\n        success: true,\n        message: 'Logged out successfully'\n      };\n    } catch (error) {\n      securityMonitor.log('logout_failed', {\n        error: error.message\n      });\n\n      // Still clear tokens even if API call fails\n      tokenManager.clearTokens();\n      sessionStorage.clear();\n      localStorage.removeItem('user_data');\n      return {\n        success: true,\n        message: 'Logged out locally'\n      };\n    }\n  },\n  /**\r\n   * Get current authenticated user\r\n   * \r\n   * @returns {Promise<Object>} Current user data\r\n   */\n  getCurrentUser: async () => {\n    try {\n      const response = await api.get('/auth/me', {\n        withCredentials: true\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Failed to get user data');\n      }\n      return {\n        success: true,\n        data: response.data.data.user\n      };\n    } catch (error) {\n      var _error$response9;\n      securityMonitor.log('get_current_user_failed', {\n        error: error.message\n      });\n      if (((_error$response9 = error.response) === null || _error$response9 === void 0 ? void 0 : _error$response9.status) === 401) {\n        tokenManager.clearTokens();\n        throw new Error('Session expired. Please login again.');\n      }\n      throw new Error('Failed to get user data');\n    }\n  },\n  /**\r\n   * Update user profile\r\n   * \r\n   * @param {Object} updates - Profile updates\r\n   * @returns {Promise<Object>} Updated user data\r\n   */\n  updateProfile: async updates => {\n    try {\n      securityMonitor.log('profile_update_attempt', {\n        fields: Object.keys(updates)\n      });\n      const response = await api.put('/auth/me', updates, {\n        withCredentials: true\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Update failed');\n      }\n      securityMonitor.log('profile_update_success', {\n        fields: Object.keys(updates)\n      });\n      return {\n        success: true,\n        message: response.data.message,\n        data: response.data.data.user\n      };\n    } catch (error) {\n      var _error$response0, _error$response0$data, _error$response0$data2;\n      securityMonitor.log('profile_update_failed', {\n        error: error.message,\n        fields: Object.keys(updates)\n      });\n      let errorMessage = 'Failed to update profile.';\n      if ((_error$response0 = error.response) !== null && _error$response0 !== void 0 && (_error$response0$data = _error$response0.data) !== null && _error$response0$data !== void 0 && (_error$response0$data2 = _error$response0$data.errors) !== null && _error$response0$data2 !== void 0 && _error$response0$data2.length) {\n        errorMessage = error.response.data.errors.map(e => e.message).join('. ');\n      }\n      throw new Error(errorMessage);\n    }\n  },\n  /**\r\n   * Change password for authenticated user\r\n   * \r\n   * @param {string} currentPassword - Current password\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  changePassword: async (currentPassword, newPassword) => {\n    try {\n      securityMonitor.log('password_change_attempt');\n\n      // Validate password strength\n      if (newPassword.length < 8) {\n        throw new Error('Password must be at least 8 characters');\n      }\n      const response = await api.post('/auth/change-password', {\n        currentPassword: currentPassword.trim(),\n        newPassword: newPassword.trim()\n      }, {\n        withCredentials: true\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Password change failed');\n      }\n      securityMonitor.log('password_change_success');\n      return {\n        success: true,\n        message: response.data.message\n      };\n    } catch (error) {\n      var _error$response1, _error$response1$data;\n      securityMonitor.log('password_change_failed', {\n        error: error.message\n      });\n      throw new Error(((_error$response1 = error.response) === null || _error$response1 === void 0 ? void 0 : (_error$response1$data = _error$response1.data) === null || _error$response1$data === void 0 ? void 0 : _error$response1$data.message) || 'Failed to change password');\n    }\n  },\n  /**\r\n   * Request password reset\r\n   * \r\n   * @param {string} email - User email\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  forgotPassword: async email => {\n    try {\n      securityMonitor.log('password_reset_request', {\n        email\n      });\n      const response = await api.post('/auth/forgot-password', {\n        email: email.toLowerCase().trim()\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Request failed');\n      }\n      securityMonitor.log('password_reset_request_success', {\n        email\n      });\n      return {\n        success: true,\n        message: response.data.message\n      };\n    } catch (error) {\n      securityMonitor.log('password_reset_request_failed', {\n        email,\n        error: error.message\n      });\n\n      // Always return success for security (don't reveal if email exists)\n      return {\n        success: true,\n        message: 'If an account exists with this email, you will receive reset instructions.'\n      };\n    }\n  },\n  /**\r\n   * Reset password with token\r\n   * \r\n   * @param {string} token - Reset token\r\n   * @param {string} userId - User ID\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  resetPassword: async (token, userId, newPassword) => {\n    try {\n      securityMonitor.log('password_reset_attempt', {\n        token: token.substring(0, 10) + '...',\n        userId\n      });\n      if (newPassword.length < 8) {\n        throw new Error('Password must be at least 8 characters');\n      }\n      const response = await api.post('/auth/reset-password', {\n        token: token.trim(),\n        userId: userId.trim(),\n        password: newPassword.trim()\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Password reset failed');\n      }\n      securityMonitor.log('password_reset_success', {\n        userId\n      });\n      return {\n        success: true,\n        message: response.data.message\n      };\n    } catch (error) {\n      var _error$response10, _error$response10$dat;\n      securityMonitor.log('password_reset_failed', {\n        userId,\n        error: error.message\n      });\n      throw new Error(((_error$response10 = error.response) === null || _error$response10 === void 0 ? void 0 : (_error$response10$dat = _error$response10.data) === null || _error$response10$dat === void 0 ? void 0 : _error$response10$dat.message) || 'Failed to reset password');\n    }\n  },\n  /**\r\n   * Verify email with token\r\n   *\r\n   * @param {string} token - Verification token\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  verifyEmail: async token => {\n    try {\n      securityMonitor.log('email_verification_attempt', {\n        token: token.substring(0, 10) + '...'\n      });\n      const response = await api.get(`/auth/verify-email/${token.trim()}`);\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Verification failed');\n      }\n      securityMonitor.log('email_verification_success');\n      return {\n        success: true,\n        message: response.data.message\n      };\n    } catch (error) {\n      var _error$response11, _error$response11$dat;\n      securityMonitor.log('email_verification_failed', {\n        error: error.message\n      });\n      throw new Error(((_error$response11 = error.response) === null || _error$response11 === void 0 ? void 0 : (_error$response11$dat = _error$response11.data) === null || _error$response11$dat === void 0 ? void 0 : _error$response11$dat.message) || 'Failed to verify email');\n    }\n  },\n  /**\r\n   * Resend verification email\r\n   * \r\n   * @returns {Promise<Object>} Success response\r\n   */\n  resendVerification: async () => {\n    try {\n      securityMonitor.log('verification_resend_attempt');\n      const response = await api.post('/auth/resend-verification', {}, {\n        withCredentials: true\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Failed to resend verification');\n      }\n      securityMonitor.log('verification_resend_success');\n      return {\n        success: true,\n        message: response.data.message\n      };\n    } catch (error) {\n      var _error$response12, _error$response12$dat;\n      securityMonitor.log('verification_resend_failed', {\n        error: error.message\n      });\n      throw new Error(((_error$response12 = error.response) === null || _error$response12 === void 0 ? void 0 : (_error$response12$dat = _error$response12.data) === null || _error$response12$dat === void 0 ? void 0 : _error$response12$dat.message) || 'Failed to resend verification');\n    }\n  },\n  /**\r\n   * Check if email is available\r\n   * \r\n   * @param {string} email - Email to check\r\n   * @returns {Promise<Object>} Availability result\r\n   */\n  checkEmail: async email => {\n    try {\n      const response = await api.post('/auth/check-email', {\n        email: email.toLowerCase().trim()\n      });\n      return {\n        success: true,\n        data: response.data.data\n      };\n    } catch (error) {\n      securityMonitor.log('check_email_failed', {\n        email,\n        error: error.message\n      });\n      throw new Error('Failed to check email availability');\n    }\n  },\n  /**\r\n   * Check if username is available\r\n   * \r\n   * @param {string} username - Username to check\r\n   * @returns {Promise<Object>} Availability result\r\n   */\n  checkUsername: async username => {\n    try {\n      const response = await api.post('/auth/check-username', {\n        username: username.trim()\n      });\n      return {\n        success: true,\n        data: response.data.data\n      };\n    } catch (error) {\n      securityMonitor.log('check_username_failed', {\n        username,\n        error: error.message\n      });\n      throw new Error('Failed to check username availability');\n    }\n  },\n  /**\r\n   * Get authentication statistics (admin only)\r\n   * \r\n   * @returns {Promise<Object>} Authentication statistics\r\n   */\n  getAuthStats: async () => {\n    try {\n      const response = await api.get('/auth/stats', {\n        withCredentials: true\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Failed to get stats');\n      }\n      return {\n        success: true,\n        data: response.data.data\n      };\n    } catch (error) {\n      securityMonitor.log('get_auth_stats_failed', {\n        error: error.message\n      });\n      throw new Error('Failed to get authentication statistics');\n    }\n  },\n  /**\r\n   * Get security events (for debugging/admin)\r\n   * \r\n   * @param {number} limit - Maximum number of events\r\n   * @returns {Array} Security events\r\n   */\n  getSecurityEvents: (limit = 50) => {\n    return securityMonitor.getEvents(limit);\n  },\n  /**\r\n   * Clear security events\r\n   */\n  clearSecurityEvents: () => {\n    securityMonitor.clearEvents();\n  },\n  /**\r\n   * Check if user is authenticated\r\n   * \r\n   * @returns {Promise<boolean>} Authentication status\r\n   */\n  isAuthenticated: async () => {\n    try {\n      await this.getCurrentUser();\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n  /**\r\n   * Check network connectivity\r\n   * \r\n   * @returns {boolean} Network status\r\n   */\n  isOnline: () => {\n    return networkMonitor.isConnected();\n  },\n  /**\r\n   * Add network status listener\r\n   * \r\n   * @param {Function} listener - Listener function\r\n   */\n  onNetworkChange: listener => {\n    networkMonitor.addListener(listener);\n  }\n};\nexport default authService;","map":{"version":3,"names":["api","TOKEN_REFRESH_THRESHOLD","MAX_RETRY_ATTEMPTS","RETRY_DELAY","OFFLINE_CHECK_INTERVAL","SecurityMonitor","constructor","events","maxEvents","log","eventType","data","event","id","crypto","randomUUID","timestamp","Date","toISOString","type","userAgent","navigator","url","window","location","href","process","env","NODE_ENV","console","group","groupEnd","unshift","length","pop","persistEvents","sendToMonitoring","localStorage","setItem","JSON","stringify","e","getEvents","limit","slice","clearEvents","removeItem","securityMonitor","TokenManager","accessToken","refreshToken","tokenExpiry","isRefreshing","refreshQueue","getAccessToken","timeToExpiry","now","refreshAccessToken","Promise","resolve","reject","push","response","post","withCredentials","setTokens","forEach","error","sessionStorage","toString","clearTokens","tokenManager","interceptors","request","use","config","includes","headers","Authorization","metadata","startTime","method","_error$config","message","_config$metadata","duration","endpoint","status","_data$data","_config$url","originalRequest","retryCount","_retryCount","_retry","refreshError","retryAfter","setTimeout","Math","pow","NetworkMonitor","isOnline","onLine","listeners","addEventListener","handleOnline","handleOffline","setInterval","checkConnectivity","notifyListeners","wasOnline","addListener","listener","isConnected","networkMonitor","authService","register","userData","_userData$firstName","_userData$lastName","_data$user","_data$user2","_data$user3","email","role","hasStudentId","studentId","requiredFields","missingFields","filter","field","Error","join","registrationData","username","trim","toLowerCase","password","firstName","lastName","phone","registrationSource","screenResolution","screen","width","height","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","isPersonalEmail","department","_userData$studentId","academicInfo","toUpperCase","campus","yearOfEntry","getFullYear","semester","academicStatus","professionalDepartment","professionalInfo","employmentType","employeeId","success","userId","user","requiresEmailVerification","_error$response","_error$response2","_error$response3","_error$response4","_error$response5","errorMessage","code","errors","map","msg","login","rememberMe","_data$user4","_data$user5","_data$user6","_error$response6","_error$response7","_error$response7$data","_error$response8","attemptsLeft","locked","lockDuration","logout","clear","getCurrentUser","get","_error$response9","updateProfile","updates","fields","Object","keys","put","_error$response0","_error$response0$data","_error$response0$data2","changePassword","currentPassword","newPassword","_error$response1","_error$response1$data","forgotPassword","resetPassword","token","substring","_error$response10","_error$response10$dat","verifyEmail","_error$response11","_error$response11$dat","resendVerification","_error$response12","_error$response12$dat","checkEmail","checkUsername","getAuthStats","getSecurityEvents","clearSecurityEvents","isAuthenticated","onNetworkChange"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/services/authService.js"],"sourcesContent":["// frontend/src/services/authService.js\r\n/**\r\n * Enterprise Authentication Service\r\n * \r\n * Production-grade authentication service with comprehensive\r\n * security features, monitoring, and enterprise patterns.\r\n * \r\n * Features:\r\n * - JWT token management with refresh tokens\r\n * - Secure HTTP-only cookie handling\r\n * - Comprehensive error handling\r\n * - Security event tracking\r\n * - Rate limiting awareness\r\n * - Audit logging\r\n * - Session management\r\n * - Token refresh automation\r\n * - Offline detection\r\n * - Network retry logic\r\n * - Cache management\r\n * \r\n * @version 4.0.1\r\n * @author Bugema University IT Support System\r\n */\r\n\r\nimport api from './api';\r\n\r\n// Constants\r\nconst TOKEN_REFRESH_THRESHOLD = 5 * 60 * 1000; // 5 minutes before expiry\r\nconst MAX_RETRY_ATTEMPTS = 3;\r\nconst RETRY_DELAY = 1000; // 1 second\r\nconst OFFLINE_CHECK_INTERVAL = 30000; // 30 seconds\r\n\r\n// Security event tracking\r\nclass SecurityMonitor {\r\n  constructor() {\r\n    this.events = [];\r\n    this.maxEvents = 100;\r\n  }\r\n\r\n  log(eventType, data = {}) {\r\n    const event = {\r\n      id: crypto.randomUUID(),\r\n      timestamp: new Date().toISOString(),\r\n      type: eventType,\r\n      ...data,\r\n      userAgent: navigator.userAgent,\r\n      url: window.location.href\r\n    };\r\n\r\n    // Development logging\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.group('ðŸ” Security Event');\r\n      console.log('Type:', eventType);\r\n      console.log('Data:', data);\r\n      console.log('Timestamp:', event.timestamp);\r\n      console.groupEnd();\r\n    }\r\n\r\n    // Store event\r\n    this.events.unshift(event);\r\n    if (this.events.length > this.maxEvents) {\r\n      this.events.pop();\r\n    }\r\n\r\n    // Persist to localStorage for debugging\r\n    this.persistEvents();\r\n\r\n    // Send to security monitoring in production\r\n    if (process.env.NODE_ENV === 'production') {\r\n      this.sendToMonitoring(event);\r\n    }\r\n  }\r\n\r\n  persistEvents() {\r\n    try {\r\n      localStorage.setItem('auth_security_events', JSON.stringify(this.events));\r\n    } catch (e) {\r\n      // Silently fail if localStorage is not available\r\n    }\r\n  }\r\n\r\n  sendToMonitoring(event) {\r\n    // Implement with your security monitoring service\r\n    // Example: Sentry, LogRocket, custom API\r\n    console.log('[Security Monitor]', event);\r\n  }\r\n\r\n  getEvents(limit = 50) {\r\n    return this.events.slice(0, limit);\r\n  }\r\n\r\n  clearEvents() {\r\n    this.events = [];\r\n    localStorage.removeItem('auth_security_events');\r\n  }\r\n}\r\n\r\n// Initialize security monitor\r\nconst securityMonitor = new SecurityMonitor();\r\n\r\n// Token management\r\nclass TokenManager {\r\n  constructor() {\r\n    this.accessToken = null;\r\n    this.refreshToken = null;\r\n    this.tokenExpiry = null;\r\n    this.isRefreshing = false;\r\n    this.refreshQueue = [];\r\n  }\r\n\r\n  async getAccessToken() {\r\n    // Check if token is expired or about to expire\r\n    if (this.accessToken && this.tokenExpiry) {\r\n      const timeToExpiry = this.tokenExpiry - Date.now();\r\n      \r\n      if (timeToExpiry < TOKEN_REFRESH_THRESHOLD) {\r\n        await this.refreshAccessToken();\r\n      }\r\n    }\r\n    \r\n    return this.accessToken;\r\n  }\r\n\r\n  async refreshAccessToken() {\r\n    if (this.isRefreshing) {\r\n      // Wait for the ongoing refresh to complete\r\n      return new Promise((resolve, reject) => {\r\n        this.refreshQueue.push({ resolve, reject });\r\n      });\r\n    }\r\n\r\n    this.isRefreshing = true;\r\n\r\n    try {\r\n      const response = await api.post('/auth/refresh', {}, {\r\n        withCredentials: true // Important for HTTP-only cookies\r\n      });\r\n\r\n      const { accessToken } = response.data;\r\n      \r\n      if (accessToken) {\r\n        this.setTokens(accessToken, this.refreshToken);\r\n        \r\n        // Resolve all queued requests\r\n        this.refreshQueue.forEach(({ resolve }) => resolve(accessToken));\r\n      }\r\n      \r\n      return accessToken;\r\n    } catch (error) {\r\n      // Reject all queued requests\r\n      this.refreshQueue.forEach(({ reject }) => reject(error));\r\n      throw error;\r\n    } finally {\r\n      this.isRefreshing = false;\r\n      this.refreshQueue = [];\r\n    }\r\n  }\r\n\r\n  setTokens(accessToken, refreshToken) {\r\n    this.accessToken = accessToken;\r\n    this.refreshToken = refreshToken;\r\n    \r\n    // Calculate token expiry (assuming 15 minutes from now)\r\n    this.tokenExpiry = Date.now() + 15 * 60 * 1000;\r\n    \r\n    // Store in memory only (cookies are HTTP-only)\r\n    sessionStorage.setItem('token_refresh_time', Date.now().toString());\r\n  }\r\n\r\n  clearTokens() {\r\n    this.accessToken = null;\r\n    this.refreshToken = null;\r\n    this.tokenExpiry = null;\r\n    sessionStorage.removeItem('token_refresh_time');\r\n  }\r\n}\r\n\r\n// Initialize token manager\r\nconst tokenManager = new TokenManager();\r\n\r\n// Request interceptor\r\napi.interceptors.request.use(\r\n  async (config) => {\r\n    // Skip token for auth endpoints except logout\r\n    if (config.url.includes('/auth/') && !config.url.includes('/auth/logout')) {\r\n      return config;\r\n    }\r\n\r\n    // Add access token if available\r\n    const accessToken = await tokenManager.getAccessToken();\r\n    if (accessToken) {\r\n      config.headers.Authorization = `Bearer ${accessToken}`;\r\n    }\r\n\r\n    // Add request ID for tracking\r\n    config.headers['X-Request-ID'] = crypto.randomUUID();\r\n    \r\n    // Add timestamp for monitoring\r\n    config.metadata = { \r\n      startTime: Date.now(),\r\n      url: config.url,\r\n      method: config.method \r\n    };\r\n\r\n    return config;\r\n  },\r\n  (error) => {\r\n    securityMonitor.log('request_interceptor_error', {\r\n      error: error.message,\r\n      url: error.config?.url\r\n    });\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Response interceptor\r\napi.interceptors.response.use(\r\n  (response) => {\r\n    const { config, data } = response;\r\n    const duration = Date.now() - (config.metadata?.startTime || Date.now());\r\n\r\n    // Log successful requests\r\n    if (config.url.includes('/auth/')) {\r\n      securityMonitor.log('auth_request_success', {\r\n        endpoint: config.url,\r\n        method: config.method,\r\n        duration: `${duration}ms`,\r\n        status: response.status\r\n      });\r\n    }\r\n\r\n    // Handle token in response for login/register\r\n    if (config.url.includes('/auth/login') || config.url.includes('/auth/register')) {\r\n      if (data.data?.accessToken) {\r\n        tokenManager.setTokens(data.data.accessToken, data.data.refreshToken);\r\n      }\r\n    }\r\n\r\n    return response;\r\n  },\r\n  async (error) => {\r\n    const { config, response } = error;\r\n    const originalRequest = config;\r\n\r\n    // Log failed requests\r\n    if (config?.url?.includes('/auth/')) {\r\n      securityMonitor.log('auth_request_failed', {\r\n        endpoint: config.url,\r\n        method: config.method,\r\n        status: response?.status,\r\n        error: error.message,\r\n        retryCount: originalRequest._retryCount || 0\r\n      });\r\n    }\r\n\r\n    // Handle 401 - Unauthorized (token expired)\r\n    if (response?.status === 401 && !originalRequest._retry) {\r\n      originalRequest._retry = true;\r\n      \r\n      try {\r\n        // Attempt to refresh token\r\n        await tokenManager.refreshAccessToken();\r\n        \r\n        // Retry the original request\r\n        return api(originalRequest);\r\n      } catch (refreshError) {\r\n        // Refresh failed, clear tokens and redirect to login\r\n        tokenManager.clearTokens();\r\n        window.location.href = '/login?session=expired';\r\n        return Promise.reject(refreshError);\r\n      }\r\n    }\r\n\r\n    // Handle 429 - Rate limited\r\n    if (response?.status === 429) {\r\n      const retryAfter = response.headers['retry-after'] || 60;\r\n      securityMonitor.log('rate_limited', {\r\n        endpoint: config.url,\r\n        retryAfter,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n          resolve(api(originalRequest));\r\n        }, retryAfter * 1000);\r\n      });\r\n    }\r\n\r\n    // Handle network errors with retry logic\r\n    if (!response && originalRequest._retryCount < MAX_RETRY_ATTEMPTS) {\r\n      originalRequest._retryCount = (originalRequest._retryCount || 0) + 1;\r\n      \r\n      return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n          resolve(api(originalRequest));\r\n        }, RETRY_DELAY * Math.pow(2, originalRequest._retryCount - 1));\r\n      });\r\n    }\r\n\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Offline detection\r\nclass NetworkMonitor {\r\n  constructor() {\r\n    this.isOnline = navigator.onLine;\r\n    this.listeners = [];\r\n    \r\n    window.addEventListener('online', () => this.handleOnline());\r\n    window.addEventListener('offline', () => this.handleOffline());\r\n    \r\n    // Periodic connectivity check\r\n    setInterval(() => this.checkConnectivity(), OFFLINE_CHECK_INTERVAL);\r\n  }\r\n\r\n  handleOnline() {\r\n    this.isOnline = true;\r\n    securityMonitor.log('network_online');\r\n    this.notifyListeners(true);\r\n  }\r\n\r\n  handleOffline() {\r\n    this.isOnline = false;\r\n    securityMonitor.log('network_offline');\r\n    this.notifyListeners(false);\r\n  }\r\n\r\n  checkConnectivity() {\r\n    // Implement custom connectivity check if needed\r\n    const wasOnline = this.isOnline;\r\n    this.isOnline = navigator.onLine;\r\n    \r\n    if (wasOnline !== this.isOnline) {\r\n      securityMonitor.log(this.isOnline ? 'network_restored' : 'network_lost');\r\n      this.notifyListeners(this.isOnline);\r\n    }\r\n  }\r\n\r\n  addListener(listener) {\r\n    this.listeners.push(listener);\r\n  }\r\n\r\n  notifyListeners(isOnline) {\r\n    this.listeners.forEach(listener => listener(isOnline));\r\n  }\r\n\r\n  isConnected() {\r\n    return this.isOnline;\r\n  }\r\n}\r\n\r\n// Initialize network monitor\r\nconst networkMonitor = new NetworkMonitor();\r\n\r\n// Main auth service\r\nconst authService = {\r\n  /**\r\n   * Register new user with comprehensive validation\r\n   * \r\n   * @param {Object} userData - User registration data\r\n   * @returns {Promise<Object>} Registration response\r\n   */\r\n  register: async (userData) => {\r\n    try {\r\n      securityMonitor.log('registration_attempt', {\r\n        email: userData.email,\r\n        role: userData.role,\r\n        hasStudentId: !!userData.studentId\r\n      });\r\n\r\n      console.log('ðŸ” Received registration data:', userData);\r\n\r\n      // Validate required fields\r\n      const requiredFields = ['username', 'email', 'password', 'role'];\r\n      const missingFields = requiredFields.filter(field => !userData[field]);\r\n      \r\n      if (missingFields.length > 0) {\r\n        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\r\n      }\r\n\r\n      // Prepare registration data\r\n      const registrationData = {\r\n        username: userData.username.trim(),\r\n        email: userData.email.toLowerCase().trim(),\r\n        password: userData.password,\r\n        role: userData.role,\r\n        firstName: userData.firstName?.trim(),\r\n        lastName: userData.lastName?.trim(),\r\n        phone: userData.phone,\r\n        metadata: {\r\n          registrationSource: 'web',\r\n          userAgent: navigator.userAgent,\r\n          screenResolution: `${window.screen.width}x${window.screen.height}`,\r\n          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\r\n          isPersonalEmail: userData.isPersonalEmail || false\r\n        }\r\n      };\r\n\r\n      // Add role-specific fields with proper department mapping\r\n      if (userData.role === 'student') {\r\n        // For students - use academicInfo with lowercase department\r\n        if (userData.department) {\r\n          registrationData.academicInfo = {\r\n            studentId: userData.studentId?.trim().toUpperCase(),\r\n            department: userData.department.trim(), // lowercase for academicInfo.department\r\n            campus: userData.campus || 'BU',\r\n            yearOfEntry: userData.yearOfEntry || new Date().getFullYear(),\r\n            semester: userData.semester || 1,\r\n            academicStatus: 'active'\r\n          };\r\n        } else {\r\n          throw new Error('Department is required for student accounts');\r\n        }\r\n      } else {\r\n        // For staff, technician, admin - use professionalInfo with UPPERCASE department\r\n        if (userData.department) {\r\n          // Convert department to UPPERCASE for professional roles\r\n          const professionalDepartment = userData.department.toUpperCase();\r\n          \r\n          registrationData.professionalInfo = {\r\n            department: professionalDepartment, // UPPERCASE for professionalInfo.department\r\n            employmentType: 'FULL_TIME'\r\n          };\r\n\r\n          // Add employee ID if provided\r\n          if (userData.employeeId) {\r\n            registrationData.professionalInfo.employeeId = userData.employeeId.trim().toUpperCase();\r\n          }\r\n        } else {\r\n          throw new Error('Department is required for staff/technician/admin accounts');\r\n        }\r\n      }\r\n\r\n      // Add student-specific fields at root level if they exist\r\n      if (userData.studentId && userData.role === 'student') {\r\n        registrationData.studentId = userData.studentId.trim().toUpperCase();\r\n      }\r\n\r\n      console.log('ðŸ” Final registration payload:', JSON.stringify(registrationData, null, 2));\r\n\r\n      const response = await api.post('/auth/register', registrationData);\r\n      \r\n      console.log('ðŸ” Registration response:', response.data);\r\n      \r\n      if (!response.data.success) {\r\n        console.error('âŒ Backend returned success: false', response.data);\r\n        throw new Error(response.data.message || 'Registration failed');\r\n      }\r\n\r\n      const { data } = response.data;\r\n\r\n      securityMonitor.log('registration_success', {\r\n        userId: data.user?.id,\r\n        email: data.user?.email,\r\n        role: data.user?.role,\r\n        requiresEmailVerification: data.requiresEmailVerification\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message,\r\n        data: {\r\n          user: data.user,\r\n          accessToken: data.accessToken,\r\n          requiresEmailVerification: data.requiresEmailVerification\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('ðŸ”¥ REGISTRATION API ERROR DETAILS:');\r\n      console.error('ðŸ”¥ Error:', error.message);\r\n      console.error('ðŸ”¥ Error response:', error.response?.data);\r\n      console.error('ðŸ”¥ Error status:', error.response?.status);\r\n      \r\n      securityMonitor.log('registration_failed', {\r\n        email: userData?.email,\r\n        role: userData?.role,\r\n        error: error.message,\r\n        response: error.response?.data,\r\n        status: error.response?.status\r\n      });\r\n\r\n      let errorMessage = 'Registration failed. Please try again.';\r\n      \r\n      if (error.response?.data) {\r\n        const { message, code, errors } = error.response.data;\r\n        console.error('ðŸ”¥ Backend error details:', { message, code, errors });\r\n        \r\n        if (code === 'EMAIL_EXISTS') {\r\n          errorMessage = 'An account with this email already exists.';\r\n        } else if (code === 'USERNAME_EXISTS') {\r\n          errorMessage = 'This username is already taken.';\r\n        } else if (code === 'STUDENT_ID_EXISTS') {\r\n          errorMessage = 'This student ID is already registered.';\r\n        } else if (code === 'EMPLOYEE_ID_EXISTS') {\r\n          errorMessage = 'This employee ID is already registered.';\r\n        } else if (code === 'VALIDATION_ERROR') {\r\n          // Handle Mongoose validation errors\r\n          if (errors?.length) {\r\n            errorMessage = errors.map(e => e.message || e.msg).join('. ');\r\n          } else if (message) {\r\n            errorMessage = message;\r\n          }\r\n        } else if (message) {\r\n          errorMessage = message;\r\n        }\r\n      } else if (error.message.includes('Network Error')) {\r\n        errorMessage = 'Cannot connect to server. Please check your internet connection.';\r\n      } else if (error.request) {\r\n        console.error('ðŸ”¥ No response received:', error.request);\r\n        errorMessage = 'No response from server. Please try again.';\r\n      }\r\n\r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * User login with credentials\r\n   * \r\n   * @param {string} email - User email\r\n   * @param {string} password - User password\r\n   * @param {boolean} rememberMe - Remember login\r\n   * @returns {Promise<Object>} Authentication response\r\n   */\r\n  login: async (email, password, rememberMe = false) => {\r\n    try {\r\n      securityMonitor.log('login_attempt', { email, rememberMe });\r\n\r\n      if (!email || !password) {\r\n        throw new Error('Email and password are required');\r\n      }\r\n\r\n      const response = await api.post('/auth/login', {\r\n        email: email.toLowerCase().trim(),\r\n        password: password.trim(),\r\n        rememberMe\r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Login failed');\r\n      }\r\n\r\n      const { data } = response.data;\r\n\r\n      securityMonitor.log('login_success', {\r\n        userId: data.user?.id,\r\n        email: data.user?.email,\r\n        role: data.user?.role,\r\n        requiresEmailVerification: data.requiresEmailVerification\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message,\r\n        data: {\r\n          user: data.user,\r\n          accessToken: data.accessToken,\r\n          refreshToken: data.refreshToken,\r\n          requiresEmailVerification: data.requiresEmailVerification\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('login_failed', {\r\n        email,\r\n        error: error.message,\r\n        status: error.response?.status,\r\n        code: error.response?.data?.code\r\n      });\r\n\r\n      let errorMessage = 'Login failed. Please check your credentials.';\r\n      \r\n      if (error.response?.data) {\r\n        const { message, code, attemptsLeft, locked } = error.response.data;\r\n        \r\n        if (code === 'ACCOUNT_LOCKED') {\r\n          errorMessage = `Account is locked. Try again in ${error.response.data.lockDuration} minutes.`;\r\n        } else if (code === 'ACCOUNT_INACTIVE') {\r\n          errorMessage = 'Account is deactivated. Please contact support.';\r\n        } else if (code === 'INVALID_CREDENTIALS') {\r\n          if (attemptsLeft > 0) {\r\n            errorMessage = `Invalid credentials. ${attemptsLeft} attempts remaining.`;\r\n          } else if (locked) {\r\n            errorMessage = 'Account locked due to too many failed attempts.';\r\n          }\r\n        } else if (message) {\r\n          errorMessage = message;\r\n        }\r\n      } else if (error.message.includes('Network Error')) {\r\n        errorMessage = 'Cannot connect to server. Please check your internet connection.';\r\n      }\r\n\r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Logout user and clear tokens\r\n   * \r\n   * @returns {Promise<Object>} Logout response\r\n   */\r\n  logout: async () => {\r\n    try {\r\n      securityMonitor.log('logout_attempt');\r\n\r\n      await api.post('/auth/logout', {}, { withCredentials: true });\r\n\r\n      // Clear local tokens\r\n      tokenManager.clearTokens();\r\n      \r\n      // Clear any stored user data\r\n      sessionStorage.clear();\r\n      localStorage.removeItem('user_data');\r\n\r\n      securityMonitor.log('logout_success');\r\n\r\n      return {\r\n        success: true,\r\n        message: 'Logged out successfully'\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('logout_failed', { error: error.message });\r\n      \r\n      // Still clear tokens even if API call fails\r\n      tokenManager.clearTokens();\r\n      sessionStorage.clear();\r\n      localStorage.removeItem('user_data');\r\n\r\n      return {\r\n        success: true,\r\n        message: 'Logged out locally'\r\n      };\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get current authenticated user\r\n   * \r\n   * @returns {Promise<Object>} Current user data\r\n   */\r\n  getCurrentUser: async () => {\r\n    try {\r\n      const response = await api.get('/auth/me', { withCredentials: true });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Failed to get user data');\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        data: response.data.data.user\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('get_current_user_failed', { error: error.message });\r\n\r\n      if (error.response?.status === 401) {\r\n        tokenManager.clearTokens();\r\n        throw new Error('Session expired. Please login again.');\r\n      }\r\n\r\n      throw new Error('Failed to get user data');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update user profile\r\n   * \r\n   * @param {Object} updates - Profile updates\r\n   * @returns {Promise<Object>} Updated user data\r\n   */\r\n  updateProfile: async (updates) => {\r\n    try {\r\n      securityMonitor.log('profile_update_attempt', { \r\n        fields: Object.keys(updates) \r\n      });\r\n\r\n      const response = await api.put('/auth/me', updates, { \r\n        withCredentials: true \r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Update failed');\r\n      }\r\n\r\n      securityMonitor.log('profile_update_success', { \r\n        fields: Object.keys(updates) \r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message,\r\n        data: response.data.data.user\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('profile_update_failed', { \r\n        error: error.message,\r\n        fields: Object.keys(updates)\r\n      });\r\n\r\n      let errorMessage = 'Failed to update profile.';\r\n      \r\n      if (error.response?.data?.errors?.length) {\r\n        errorMessage = error.response.data.errors.map(e => e.message).join('. ');\r\n      }\r\n\r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Change password for authenticated user\r\n   * \r\n   * @param {string} currentPassword - Current password\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  changePassword: async (currentPassword, newPassword) => {\r\n    try {\r\n      securityMonitor.log('password_change_attempt');\r\n\r\n      // Validate password strength\r\n      if (newPassword.length < 8) {\r\n        throw new Error('Password must be at least 8 characters');\r\n      }\r\n\r\n      const response = await api.post('/auth/change-password', {\r\n        currentPassword: currentPassword.trim(),\r\n        newPassword: newPassword.trim()\r\n      }, { withCredentials: true });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Password change failed');\r\n      }\r\n\r\n      securityMonitor.log('password_change_success');\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('password_change_failed', { error: error.message });\r\n      throw new Error(error.response?.data?.message || 'Failed to change password');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Request password reset\r\n   * \r\n   * @param {string} email - User email\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  forgotPassword: async (email) => {\r\n    try {\r\n      securityMonitor.log('password_reset_request', { email });\r\n\r\n      const response = await api.post('/auth/forgot-password', {\r\n        email: email.toLowerCase().trim()\r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Request failed');\r\n      }\r\n\r\n      securityMonitor.log('password_reset_request_success', { email });\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('password_reset_request_failed', { \r\n        email,\r\n        error: error.message \r\n      });\r\n\r\n      // Always return success for security (don't reveal if email exists)\r\n      return {\r\n        success: true,\r\n        message: 'If an account exists with this email, you will receive reset instructions.'\r\n      };\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Reset password with token\r\n   * \r\n   * @param {string} token - Reset token\r\n   * @param {string} userId - User ID\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  resetPassword: async (token, userId, newPassword) => {\r\n    try {\r\n      securityMonitor.log('password_reset_attempt', { \r\n        token: token.substring(0, 10) + '...',\r\n        userId \r\n      });\r\n\r\n      if (newPassword.length < 8) {\r\n        throw new Error('Password must be at least 8 characters');\r\n      }\r\n\r\n      const response = await api.post('/auth/reset-password', {\r\n        token: token.trim(),\r\n        userId: userId.trim(),\r\n        password: newPassword.trim()\r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Password reset failed');\r\n      }\r\n\r\n      securityMonitor.log('password_reset_success', { userId });\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('password_reset_failed', { \r\n        userId,\r\n        error: error.message \r\n      });\r\n\r\n      throw new Error(error.response?.data?.message || 'Failed to reset password');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Verify email with token\r\n   *\r\n   * @param {string} token - Verification token\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  verifyEmail: async (token) => {\r\n    try {\r\n      securityMonitor.log('email_verification_attempt', {\r\n        token: token.substring(0, 10) + '...'\r\n      });\r\n\r\n      const response = await api.get(`/auth/verify-email/${token.trim()}`);\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Verification failed');\r\n      }\r\n\r\n      securityMonitor.log('email_verification_success');\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('email_verification_failed', {\r\n        error: error.message\r\n      });\r\n\r\n      throw new Error(error.response?.data?.message || 'Failed to verify email');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Resend verification email\r\n   * \r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  resendVerification: async () => {\r\n    try {\r\n      securityMonitor.log('verification_resend_attempt');\r\n\r\n      const response = await api.post('/auth/resend-verification', {}, { \r\n        withCredentials: true \r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Failed to resend verification');\r\n      }\r\n\r\n      securityMonitor.log('verification_resend_success');\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('verification_resend_failed', { error: error.message });\r\n      throw new Error(error.response?.data?.message || 'Failed to resend verification');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check if email is available\r\n   * \r\n   * @param {string} email - Email to check\r\n   * @returns {Promise<Object>} Availability result\r\n   */\r\n  checkEmail: async (email) => {\r\n    try {\r\n      const response = await api.post('/auth/check-email', {\r\n        email: email.toLowerCase().trim()\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        data: response.data.data\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('check_email_failed', { email, error: error.message });\r\n      throw new Error('Failed to check email availability');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check if username is available\r\n   * \r\n   * @param {string} username - Username to check\r\n   * @returns {Promise<Object>} Availability result\r\n   */\r\n  checkUsername: async (username) => {\r\n    try {\r\n      const response = await api.post('/auth/check-username', {\r\n        username: username.trim()\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        data: response.data.data\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('check_username_failed', { username, error: error.message });\r\n      throw new Error('Failed to check username availability');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get authentication statistics (admin only)\r\n   * \r\n   * @returns {Promise<Object>} Authentication statistics\r\n   */\r\n  getAuthStats: async () => {\r\n    try {\r\n      const response = await api.get('/auth/stats', { withCredentials: true });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Failed to get stats');\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        data: response.data.data\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('get_auth_stats_failed', { error: error.message });\r\n      throw new Error('Failed to get authentication statistics');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get security events (for debugging/admin)\r\n   * \r\n   * @param {number} limit - Maximum number of events\r\n   * @returns {Array} Security events\r\n   */\r\n  getSecurityEvents: (limit = 50) => {\r\n    return securityMonitor.getEvents(limit);\r\n  },\r\n\r\n  /**\r\n   * Clear security events\r\n   */\r\n  clearSecurityEvents: () => {\r\n    securityMonitor.clearEvents();\r\n  },\r\n\r\n  /**\r\n   * Check if user is authenticated\r\n   * \r\n   * @returns {Promise<boolean>} Authentication status\r\n   */\r\n  isAuthenticated: async () => {\r\n    try {\r\n      await this.getCurrentUser();\r\n      return true;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check network connectivity\r\n   * \r\n   * @returns {boolean} Network status\r\n   */\r\n  isOnline: () => {\r\n    return networkMonitor.isConnected();\r\n  },\r\n\r\n  /**\r\n   * Add network status listener\r\n   * \r\n   * @param {Function} listener - Listener function\r\n   */\r\n  onNetworkChange: (listener) => {\r\n    networkMonitor.addListener(listener);\r\n  }\r\n};\r\n\r\nexport default authService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}