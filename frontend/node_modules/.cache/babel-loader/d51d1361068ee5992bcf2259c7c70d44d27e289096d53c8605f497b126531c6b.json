{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\KADZ-TECH\\\\Documents\\\\dev\\\\it-support-system\\\\frontend\\\\src\\\\components\\\\ProtectedRoute.js\",\n  _s = $RefreshSig$();\n// frontend/src/components/ProtectedRoute.js\nimport React, { useContext, useEffect, useState } from 'react';\nimport { Navigate, Outlet, useLocation } from 'react-router-dom';\nimport PropTypes from 'prop-types'; // Import PropTypes\nimport { AuthContext } from '../context/AuthContext';\nimport LoadingSpinner from './common/LoadingSpinner';\nimport apiService from '../services/api'; // Import the enhanced apiService\n\n/**\r\n * Production-grade Protected Route component\r\n * Features:\r\n * - Authentication checking\r\n * - Role-based access control\r\n * - Loading states\r\n * - Session validation\r\n * - Redirect handling\r\n * - Error boundary integration\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ProtectedRoute = ({\n  children,\n  requiredRoles = [],\n  redirectPath = '/login',\n  requireVerifiedEmail = false,\n  showLoading = true\n}) => {\n  _s();\n  const {\n    user,\n    isLoading,\n    isAuthenticated,\n    logout\n  } = useContext(AuthContext);\n  const location = useLocation();\n  const [isValidatingSession, setIsValidatingSession] = useState(false);\n  const [validationError, setValidationError] = useState(null);\n\n  // Validate session with backend on component mount and when auth state changes\n  useEffect(() => {\n    let isMounted = true;\n    const validateSession = async () => {\n      // Skip validation if no token exists\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n      if (!token) {\n        if (isMounted) {\n          setValidationError('NO_TOKEN');\n        }\n        return;\n      }\n      if (isMounted) {\n        setIsValidatingSession(true);\n        setValidationError(null);\n      }\n      try {\n        // Optional: Validate session with backend\n        // This can be enabled for extra security\n        if (process.env.REACT_APP_ENABLE_SESSION_VALIDATION === 'true') {\n          await apiService.testConnection();\n          // Or call a specific session validation endpoint\n          // await apiService.get('/auth/validate-session');\n        }\n        if (isMounted) {\n          setValidationError(null);\n        }\n      } catch (error) {\n        if (isMounted) {\n          var _error$response;\n          console.error('Session validation failed:', error);\n          setValidationError('SESSION_INVALID');\n\n          // Auto-logout on session validation failure\n          if (error.code === 'AUTH_REQUIRED' || ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n            setTimeout(() => {\n              if (isMounted) {\n                logout();\n              }\n            }, 1000);\n          }\n        }\n      } finally {\n        if (isMounted) {\n          setIsValidatingSession(false);\n        }\n      }\n    };\n    if (isAuthenticated && user) {\n      validateSession();\n    }\n    return () => {\n      isMounted = false;\n    };\n  }, [isAuthenticated, user, logout]);\n\n  // Check if user has required roles\n  const hasRequiredRole = () => {\n    if (!requiredRoles || requiredRoles.length === 0) return true;\n    if (!user || !user.roles) return false;\n    return requiredRoles.some(role => user.roles.includes(role));\n  };\n\n  // Check if email verification is required and user is verified\n  const isEmailVerified = () => {\n    if (!requireVerifiedEmail) return true;\n    if (!user) return false;\n\n    // Check based on your user model structure\n    return user.isEmailVerified || user.emailVerified || user.verified || true;\n  };\n\n  // Show loading state\n  if (isLoading || isValidatingSession) {\n    if (showLoading) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"flex items-center justify-center min-h-screen bg-gray-50\",\n        \"data-testid\": \"protected-route-loading\",\n        children: /*#__PURE__*/_jsxDEV(LoadingSpinner, {\n          size: \"lg\",\n          message: isValidatingSession ? \"Validating session...\" : \"Loading...\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 115,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 114,\n        columnNumber: 9\n      }, this);\n    }\n    return null;\n  }\n\n  // Handle validation errors\n  if (validationError === 'SESSION_INVALID') {\n    // Store the attempted location for redirect after login\n    sessionStorage.setItem('redirectAfterLogin', location.pathname + location.search);\n    return /*#__PURE__*/_jsxDEV(Navigate, {\n      to: `${redirectPath}?session=invalid&redirect=${encodeURIComponent(location.pathname)}`,\n      replace: true,\n      state: {\n        from: location\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 131,\n      columnNumber: 7\n    }, this);\n  }\n\n  // Redirect to login if not authenticated\n  if (!isAuthenticated || !user) {\n    // Store the attempted location for redirect after login\n    sessionStorage.setItem('redirectAfterLogin', location.pathname + location.search);\n    return /*#__PURE__*/_jsxDEV(Navigate, {\n      to: `${redirectPath}?redirect=${encodeURIComponent(location.pathname)}`,\n      replace: true,\n      state: {\n        from: location\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 145,\n      columnNumber: 7\n    }, this);\n  }\n\n  // Check email verification\n  if (!isEmailVerified()) {\n    return /*#__PURE__*/_jsxDEV(Navigate, {\n      to: \"/verify-email\",\n      replace: true,\n      state: {\n        from: location,\n        message: \"Please verify your email address to access this page.\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 156,\n      columnNumber: 7\n    }, this);\n  }\n\n  // Check role-based access\n  if (!hasRequiredRole()) {\n    // Log unauthorized access attempt (security monitoring)\n    console.warn(`Unauthorized access attempt by user ${user.id} to ${location.pathname}`);\n\n    // Optionally send to security monitoring\n    if (process.env.NODE_ENV === 'production') {\n      // apiService.post('/security/access-denied', {\n      //   userId: user.id,\n      //   path: location.pathname,\n      //   requiredRoles,\n      //   userRoles: user.roles,\n      //   timestamp: new Date().toISOString()\n      // }).catch(() => {});\n    }\n    return /*#__PURE__*/_jsxDEV(Navigate, {\n      to: \"/unauthorized\",\n      replace: true,\n      state: {\n        from: location,\n        requiredRoles,\n        userRoles: user.roles\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 184,\n      columnNumber: 7\n    }, this);\n  }\n\n  // Render children or outlet\n  return children ? children : /*#__PURE__*/_jsxDEV(Outlet, {}, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 197,\n    columnNumber: 32\n  }, this);\n};\n\n// Production-grade PropTypes with documentation\n_s(ProtectedRoute, \"k2pfb9Dx6QKOtwJGthmEpkSDosU=\", false, function () {\n  return [useLocation];\n});\n_c = ProtectedRoute;\nProtectedRoute.propTypes = {\n  /**\r\n   * Child components to render when authenticated\r\n   */\n  children: PropTypes.node,\n  /**\r\n   * Array of required roles to access this route\r\n   * If empty array, only authentication is required\r\n   */\n  requiredRoles: PropTypes.arrayOf(PropTypes.string),\n  /**\r\n   * Path to redirect to when not authenticated\r\n   * @default '/login'\r\n   */\n  redirectPath: PropTypes.string,\n  /**\r\n   * Whether email verification is required\r\n   * @default false\r\n   */\n  requireVerifiedEmail: PropTypes.bool,\n  /**\r\n   * Whether to show loading spinner during authentication check\r\n   * @default true\r\n   */\n  showLoading: PropTypes.bool\n};\nProtectedRoute.defaultProps = {\n  requiredRoles: [],\n  redirectPath: '/login',\n  requireVerifiedEmail: false,\n  showLoading: true\n};\n\n// Export with display name for debugging\nProtectedRoute.displayName = 'ProtectedRoute';\nexport default ProtectedRoute;\nvar _c;\n$RefreshReg$(_c, \"ProtectedRoute\");","map":{"version":3,"names":["React","useContext","useEffect","useState","Navigate","Outlet","useLocation","PropTypes","AuthContext","LoadingSpinner","apiService","jsxDEV","_jsxDEV","ProtectedRoute","children","requiredRoles","redirectPath","requireVerifiedEmail","showLoading","_s","user","isLoading","isAuthenticated","logout","location","isValidatingSession","setIsValidatingSession","validationError","setValidationError","isMounted","validateSession","token","localStorage","getItem","sessionStorage","process","env","REACT_APP_ENABLE_SESSION_VALIDATION","testConnection","error","_error$response","console","code","response","status","setTimeout","hasRequiredRole","length","roles","some","role","includes","isEmailVerified","emailVerified","verified","className","size","message","fileName","_jsxFileName","lineNumber","columnNumber","setItem","pathname","search","to","encodeURIComponent","replace","state","from","warn","id","NODE_ENV","userRoles","_c","propTypes","node","arrayOf","string","bool","defaultProps","displayName","$RefreshReg$"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/components/ProtectedRoute.js"],"sourcesContent":["// frontend/src/components/ProtectedRoute.js\r\nimport React, { useContext, useEffect, useState } from 'react';\r\nimport { Navigate, Outlet, useLocation } from 'react-router-dom';\r\nimport PropTypes from 'prop-types'; // Import PropTypes\r\nimport { AuthContext } from '../context/AuthContext';\r\nimport LoadingSpinner from './common/LoadingSpinner';\r\nimport apiService from '../services/api'; // Import the enhanced apiService\r\n\r\n/**\r\n * Production-grade Protected Route component\r\n * Features:\r\n * - Authentication checking\r\n * - Role-based access control\r\n * - Loading states\r\n * - Session validation\r\n * - Redirect handling\r\n * - Error boundary integration\r\n */\r\n\r\nconst ProtectedRoute = ({ \r\n  children, \r\n  requiredRoles = [], \r\n  redirectPath = '/login',\r\n  requireVerifiedEmail = false,\r\n  showLoading = true \r\n}) => {\r\n  const { user, isLoading, isAuthenticated, logout } = useContext(AuthContext);\r\n  const location = useLocation();\r\n  const [isValidatingSession, setIsValidatingSession] = useState(false);\r\n  const [validationError, setValidationError] = useState(null);\r\n\r\n  // Validate session with backend on component mount and when auth state changes\r\n  useEffect(() => {\r\n    let isMounted = true;\r\n    \r\n    const validateSession = async () => {\r\n      // Skip validation if no token exists\r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      if (!token) {\r\n        if (isMounted) {\r\n          setValidationError('NO_TOKEN');\r\n        }\r\n        return;\r\n      }\r\n      \r\n      if (isMounted) {\r\n        setIsValidatingSession(true);\r\n        setValidationError(null);\r\n      }\r\n      \r\n      try {\r\n        // Optional: Validate session with backend\r\n        // This can be enabled for extra security\r\n        if (process.env.REACT_APP_ENABLE_SESSION_VALIDATION === 'true') {\r\n          await apiService.testConnection();\r\n          // Or call a specific session validation endpoint\r\n          // await apiService.get('/auth/validate-session');\r\n        }\r\n        \r\n        if (isMounted) {\r\n          setValidationError(null);\r\n        }\r\n      } catch (error) {\r\n        if (isMounted) {\r\n          console.error('Session validation failed:', error);\r\n          setValidationError('SESSION_INVALID');\r\n          \r\n          // Auto-logout on session validation failure\r\n          if (error.code === 'AUTH_REQUIRED' || error.response?.status === 401) {\r\n            setTimeout(() => {\r\n              if (isMounted) {\r\n                logout();\r\n              }\r\n            }, 1000);\r\n          }\r\n        }\r\n      } finally {\r\n        if (isMounted) {\r\n          setIsValidatingSession(false);\r\n        }\r\n      }\r\n    };\r\n    \r\n    if (isAuthenticated && user) {\r\n      validateSession();\r\n    }\r\n    \r\n    return () => {\r\n      isMounted = false;\r\n    };\r\n  }, [isAuthenticated, user, logout]);\r\n\r\n  // Check if user has required roles\r\n  const hasRequiredRole = () => {\r\n    if (!requiredRoles || requiredRoles.length === 0) return true;\r\n    if (!user || !user.roles) return false;\r\n    \r\n    return requiredRoles.some(role => user.roles.includes(role));\r\n  };\r\n\r\n  // Check if email verification is required and user is verified\r\n  const isEmailVerified = () => {\r\n    if (!requireVerifiedEmail) return true;\r\n    if (!user) return false;\r\n    \r\n    // Check based on your user model structure\r\n    return user.isEmailVerified || user.emailVerified || user.verified || true;\r\n  };\r\n\r\n  // Show loading state\r\n  if (isLoading || isValidatingSession) {\r\n    if (showLoading) {\r\n      return (\r\n        <div className=\"flex items-center justify-center min-h-screen bg-gray-50\" data-testid=\"protected-route-loading\">\r\n          <LoadingSpinner \r\n            size=\"lg\" \r\n            message={isValidatingSession ? \"Validating session...\" : \"Loading...\"}\r\n          />\r\n        </div>\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // Handle validation errors\r\n  if (validationError === 'SESSION_INVALID') {\r\n    // Store the attempted location for redirect after login\r\n    sessionStorage.setItem('redirectAfterLogin', location.pathname + location.search);\r\n    \r\n    return (\r\n      <Navigate \r\n        to={`${redirectPath}?session=invalid&redirect=${encodeURIComponent(location.pathname)}`} \r\n        replace \r\n        state={{ from: location }}\r\n      />\r\n    );\r\n  }\r\n\r\n  // Redirect to login if not authenticated\r\n  if (!isAuthenticated || !user) {\r\n    // Store the attempted location for redirect after login\r\n    sessionStorage.setItem('redirectAfterLogin', location.pathname + location.search);\r\n    \r\n    return (\r\n      <Navigate \r\n        to={`${redirectPath}?redirect=${encodeURIComponent(location.pathname)}`} \r\n        replace \r\n        state={{ from: location }}\r\n      />\r\n    );\r\n  }\r\n\r\n  // Check email verification\r\n  if (!isEmailVerified()) {\r\n    return (\r\n      <Navigate \r\n        to=\"/verify-email\" \r\n        replace \r\n        state={{ \r\n          from: location,\r\n          message: \"Please verify your email address to access this page.\"\r\n        }}\r\n      />\r\n    );\r\n  }\r\n\r\n  // Check role-based access\r\n  if (!hasRequiredRole()) {\r\n    // Log unauthorized access attempt (security monitoring)\r\n    console.warn(`Unauthorized access attempt by user ${user.id} to ${location.pathname}`);\r\n    \r\n    // Optionally send to security monitoring\r\n    if (process.env.NODE_ENV === 'production') {\r\n      // apiService.post('/security/access-denied', {\r\n      //   userId: user.id,\r\n      //   path: location.pathname,\r\n      //   requiredRoles,\r\n      //   userRoles: user.roles,\r\n      //   timestamp: new Date().toISOString()\r\n      // }).catch(() => {});\r\n    }\r\n    \r\n    return (\r\n      <Navigate \r\n        to=\"/unauthorized\" \r\n        replace \r\n        state={{ \r\n          from: location,\r\n          requiredRoles,\r\n          userRoles: user.roles\r\n        }}\r\n      />\r\n    );\r\n  }\r\n\r\n  // Render children or outlet\r\n  return children ? children : <Outlet />;\r\n};\r\n\r\n// Production-grade PropTypes with documentation\r\nProtectedRoute.propTypes = {\r\n  /**\r\n   * Child components to render when authenticated\r\n   */\r\n  children: PropTypes.node,\r\n  \r\n  /**\r\n   * Array of required roles to access this route\r\n   * If empty array, only authentication is required\r\n   */\r\n  requiredRoles: PropTypes.arrayOf(PropTypes.string),\r\n  \r\n  /**\r\n   * Path to redirect to when not authenticated\r\n   * @default '/login'\r\n   */\r\n  redirectPath: PropTypes.string,\r\n  \r\n  /**\r\n   * Whether email verification is required\r\n   * @default false\r\n   */\r\n  requireVerifiedEmail: PropTypes.bool,\r\n  \r\n  /**\r\n   * Whether to show loading spinner during authentication check\r\n   * @default true\r\n   */\r\n  showLoading: PropTypes.bool,\r\n};\r\n\r\nProtectedRoute.defaultProps = {\r\n  requiredRoles: [],\r\n  redirectPath: '/login',\r\n  requireVerifiedEmail: false,\r\n  showLoading: true,\r\n};\r\n\r\n// Export with display name for debugging\r\nProtectedRoute.displayName = 'ProtectedRoute';\r\n\r\nexport default ProtectedRoute;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}