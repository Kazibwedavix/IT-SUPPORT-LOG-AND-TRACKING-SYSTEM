{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\KADZ-TECH\\\\Documents\\\\dev\\\\it-support-system\\\\frontend\\\\src\\\\context\\\\AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// frontend/src/context/AuthContext.js - PRODUCTION READY FIXED VERSION\nimport React, { createContext, useState, useContext, useEffect, useCallback, useRef, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { authService } from '../services/authService';\n\n/**\r\n * Enterprise Auth Context v5.2.0 - FIXED PRODUCTION VERSION\r\n * Fixed Issues:\r\n * - Removed infinite re-render loop from logSecurityEvent\r\n * - Optimized performance with proper memoization\r\n * - Fixed cleanup dependencies\r\n * - Stable event logging without state dependencies\r\n */\n\n// Context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const AuthContext = /*#__PURE__*/createContext();\n\n// Custom hook\nexport const useAuth = () => {\n  _s();\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n};\n\n// Error boundary for auth errors\n_s(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nclass AuthErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: null\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      hasError: true,\n      error\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error('Auth Error Boundary caught:', error, errorInfo);\n\n    // Send error to monitoring service in production\n    if (process.env.NODE_ENV === 'production') {\n      try {\n        fetch('/api/monitoring/errors', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            error: error.message,\n            errorInfo,\n            component: 'AuthErrorBoundary',\n            timestamp: new Date().toISOString()\n          })\n        });\n      } catch (e) {\n        // Silent fail for monitoring errors\n      }\n    }\n  }\n  render() {\n    if (this.state.hasError) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          padding: '40px',\n          textAlign: 'center',\n          backgroundColor: '#fef2f2',\n          borderRadius: '8px',\n          margin: '20px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          style: {\n            color: '#dc2626',\n            marginBottom: '16px'\n          },\n          children: \"Authentication Error\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 70,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          style: {\n            color: '#4b5563',\n            marginBottom: '24px'\n          },\n          children: \"Something went wrong with authentication. Please try refreshing the page.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 73,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => window.location.reload(),\n          style: {\n            padding: '10px 24px',\n            backgroundColor: '#3b82f6',\n            color: 'white',\n            border: 'none',\n            borderRadius: '6px',\n            cursor: 'pointer',\n            fontSize: '14px',\n            fontWeight: '500'\n          },\n          children: \"Refresh Page\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 76,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 63,\n        columnNumber: 9\n      }, this);\n    }\n    return this.props.children;\n  }\n}\n\n// Performance monitoring - isolated from render cycles\nconst createPerformanceMonitor = () => {\n  const metrics = {\n    loginTime: null,\n    refreshTime: null,\n    sessionChecks: 0,\n    errors: [],\n    securityEvents: []\n  };\n  return {\n    startMeasurement(operation) {\n      const startTime = performance.now();\n      return () => {\n        const duration = performance.now() - startTime;\n        metrics[operation] = duration;\n        if (duration > 1000 && process.env.NODE_ENV === 'development') {\n          console.warn(`Slow auth operation: ${operation} took ${duration.toFixed(2)}ms`);\n        }\n      };\n    },\n    logError(error, operation) {\n      metrics.errors.push({\n        operation,\n        error: error.message,\n        timestamp: new Date().toISOString()\n      });\n    },\n    logSecurityEvent(eventType, details) {\n      const event = {\n        eventType,\n        details,\n        timestamp: new Date().toISOString()\n      };\n      metrics.securityEvents.push(event);\n\n      // Only log to console in development for specific events\n      if (process.env.NODE_ENV === 'development') {\n        const importantEvents = ['login_failed', 'registration_failed', 'session_expired', 'security_violation'];\n        if (importantEvents.includes(eventType)) {\n          console.log(`[SECURITY] ${eventType}:`, details);\n        }\n      }\n      return event;\n    },\n    getMetrics() {\n      return {\n        ...metrics\n      };\n    },\n    clear() {\n      metrics.errors = [];\n      metrics.securityEvents = [];\n    }\n  };\n};\n\n// Security Logger - Decoupled from React state\nconst createSecurityLogger = performanceMonitor => {\n  let queue = [];\n  let isSending = false;\n  const sendToBackend = async event => {\n    if (process.env.NODE_ENV !== 'production' || !event) return;\n    try {\n      // In production, send to backend with retry logic\n      const response = await fetch('/api/logs/security', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Client-Version': '1.0.0'\n        },\n        body: JSON.stringify(event),\n        signal: AbortSignal.timeout(5000) // 5 second timeout\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      return true;\n    } catch (error) {\n      // Store failed logs in localStorage for retry\n      try {\n        const failedLogs = JSON.parse(localStorage.getItem('failed_security_logs') || '[]');\n        failedLogs.push({\n          event,\n          error: error.message,\n          timestamp: new Date().toISOString()\n        });\n        localStorage.setItem('failed_security_logs', JSON.stringify(failedLogs.slice(-50))); // Keep last 50\n      } catch (e) {\n        // localStorage may be full or blocked\n      }\n      return false;\n    }\n  };\n  const processQueue = async () => {\n    if (isSending || queue.length === 0) return;\n    isSending = true;\n    const event = queue.shift();\n    try {\n      await sendToBackend(event);\n    } finally {\n      isSending = false;\n      if (queue.length > 0) {\n        // Process next event with delay\n        setTimeout(processQueue, 100);\n      }\n    }\n  };\n  return {\n    log(eventType, details, userData = null, sessionData = null) {\n      var _navigator$userAgent;\n      const event = {\n        eventType,\n        details,\n        timestamp: new Date().toISOString(),\n        userId: (userData === null || userData === void 0 ? void 0 : userData.id) || null,\n        userRole: (userData === null || userData === void 0 ? void 0 : userData.role) || null,\n        sessionId: (sessionData === null || sessionData === void 0 ? void 0 : sessionData.id) || null,\n        source: 'auth_context',\n        userAgent: ((_navigator$userAgent = navigator.userAgent) === null || _navigator$userAgent === void 0 ? void 0 : _navigator$userAgent.substring(0, 200)) || 'unknown',\n        url: window.location.href,\n        screenResolution: `${window.screen.width}x${window.screen.height}`,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown'\n      };\n\n      // Store in performance monitor for debugging\n      performanceMonitor.logSecurityEvent(eventType, details);\n\n      // Add to queue for backend processing\n      queue.push(event);\n\n      // Start processing if not already\n      if (!isSending) {\n        setTimeout(processQueue, 0);\n      }\n      return event;\n    },\n    flush() {\n      const events = [...queue];\n      queue = [];\n      return events;\n    },\n    getQueueSize() {\n      return queue.length;\n    }\n  };\n};\n\n// Main provider component - FIXED VERSION\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  // State management\n  const [state, setState] = useState({\n    user: null,\n    session: null,\n    loading: true,\n    error: null,\n    success: null,\n    sessionExpiresAt: null,\n    permissions: new Set()\n  });\n\n  // Refs for cleanup and stable references\n  const refreshTimerRef = useRef(null);\n  const sessionCheckRef = useRef(null);\n  const activityTimerRef = useRef(null);\n  const isMountedRef = useRef(true);\n  const performanceMonitor = useMemo(() => createPerformanceMonitor(), []);\n  const securityLogger = useMemo(() => createSecurityLogger(performanceMonitor), [performanceMonitor]);\n\n  // Store state in ref for access in callbacks without re-renders\n  const stateRef = useRef(state);\n  useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n\n  // Update state safely\n  const setAuthState = useCallback(updates => {\n    if (isMountedRef.current) {\n      setState(prev => ({\n        ...prev,\n        ...updates\n      }));\n    }\n  }, []);\n\n  // Clear all timers\n  const clearTimers = useCallback(() => {\n    if (refreshTimerRef.current) {\n      clearTimeout(refreshTimerRef.current);\n      refreshTimerRef.current = null;\n    }\n    if (sessionCheckRef.current) {\n      clearInterval(sessionCheckRef.current);\n      sessionCheckRef.current = null;\n    }\n    if (activityTimerRef.current) {\n      clearTimeout(activityTimerRef.current);\n      activityTimerRef.current = null;\n    }\n  }, []);\n\n  // Schedule token refresh\n  const scheduleTokenRefresh = useCallback(expiresAt => {\n    clearTimers();\n    if (!expiresAt) return;\n    const refreshTime = expiresAt - 5 * 60 * 1000 - Date.now();\n    if (refreshTime > 0) {\n      refreshTimerRef.current = setTimeout(async () => {\n        try {\n          const endMeasurement = performanceMonitor.startMeasurement('tokenRefresh');\n          await authService.refreshAccessToken();\n          endMeasurement();\n\n          // Update session after refresh\n          const session = authService.getCurrentSession();\n          if (session) {\n            setAuthState({\n              session,\n              sessionExpiresAt: session.expiresAt\n            });\n            scheduleTokenRefresh(session.expiresAt);\n          }\n        } catch (error) {\n          performanceMonitor.logError(error, 'tokenRefresh');\n          console.error('Token refresh failed:', error);\n        }\n      }, Math.max(refreshTime, 0)); // Ensure non-negative\n    }\n  }, [clearTimers, performanceMonitor, setAuthState]);\n\n  // Start session monitoring\n  const startSessionMonitoring = useCallback(expiresAt => {\n    clearTimers();\n\n    // Check session every minute\n    sessionCheckRef.current = setInterval(() => {\n      if (expiresAt && Date.now() > expiresAt) {\n        logout('session_expired');\n      }\n    }, 60 * 1000);\n\n    // Activity tracking\n    const activityListeners = [];\n    const trackActivity = () => {\n      if (activityTimerRef.current) {\n        clearTimeout(activityTimerRef.current);\n      }\n      activityTimerRef.current = setTimeout(() => {\n        logout('inactivity');\n      }, 30 * 60 * 1000); // 30 minutes\n    };\n\n    // Track user activity\n    ['mousemove', 'keydown', 'click', 'scroll'].forEach(event => {\n      window.addEventListener(event, trackActivity, {\n        passive: true\n      });\n      activityListeners.push({\n        event,\n        handler: trackActivity\n      });\n    });\n    trackActivity();\n\n    // Return cleanup function\n    return () => {\n      activityListeners.forEach(({\n        event,\n        handler\n      }) => {\n        window.removeEventListener(event, handler);\n      });\n    };\n  }, [clearTimers]);\n\n  // Initialize auth state\n  const initializeAuth = useCallback(async () => {\n    if (!isMountedRef.current) return;\n    try {\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const session = authService.getCurrentSession();\n      if (!session) {\n        setAuthState({\n          loading: false\n        });\n        return;\n      }\n\n      // Verify session is still valid\n      if (Date.now() > session.expiresAt) {\n        await logout('session_expired');\n        return;\n      }\n\n      // Get fresh user data\n      const userResponse = await authService.getCurrentUser();\n      if (!userResponse.success) {\n        throw new Error('Failed to get user data');\n      }\n      const permissions = new Set(userResponse.data.permissions || []);\n      setAuthState({\n        user: userResponse.data,\n        session,\n        sessionExpiresAt: session.expiresAt,\n        permissions,\n        loading: false\n      });\n\n      // Log security event (async, non-blocking)\n      securityLogger.log('session_initialized', {\n        userId: userResponse.data.id,\n        role: userResponse.data.role,\n        sessionId: session.id,\n        sessionExpiresAt: new Date(session.expiresAt).toISOString()\n      }, userResponse.data, session);\n\n      // Schedule token refresh\n      scheduleTokenRefresh(session.expiresAt);\n\n      // Start session monitoring\n      const cleanupActivityTracking = startSessionMonitoring(session.expiresAt);\n\n      // Return cleanup function\n      return cleanupActivityTracking;\n    } catch (error) {\n      performanceMonitor.logError(error, 'initializeAuth');\n      console.error('Auth initialization error:', error);\n      securityLogger.log('initialization_failed', {\n        error: error.message,\n        sessionExists: !!authService.getCurrentSession()\n      });\n      setAuthState({\n        error: 'Failed to initialize authentication',\n        loading: false\n      });\n    }\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, securityLogger]);\n\n  // Login\n  const login = useCallback(async (email, password, rememberMe = false) => {\n    try {\n      setAuthState({\n        loading: true,\n        error: null,\n        success: null\n      });\n      const endMeasurement = performanceMonitor.startMeasurement('login');\n      const response = await authService.login(email, password, rememberMe);\n      endMeasurement();\n      if (!response.success) {\n        throw new Error(response.message || 'Login failed');\n      }\n      const session = authService.getCurrentSession();\n      const permissions = new Set(response.data.user.permissions || []);\n      setAuthState({\n        user: response.data.user,\n        session,\n        sessionExpiresAt: session.expiresAt,\n        permissions,\n        loading: false,\n        success: 'Login successful'\n      });\n\n      // Log security event\n      securityLogger.log('login_success', {\n        email: email,\n        rememberMe,\n        ip: 'client-side'\n      }, response.data.user, session);\n\n      // Schedule token refresh\n      scheduleTokenRefresh(session.expiresAt);\n\n      // Start session monitoring\n      startSessionMonitoring(session.expiresAt);\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'login');\n\n      // Log failed login attempt\n      securityLogger.log('login_failed', {\n        email: email,\n        error: error.message\n      });\n      const errorMessage = error.message || 'Login failed. Please check your credentials.';\n      setAuthState({\n        error: errorMessage,\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, securityLogger]);\n\n  // Register\n  const register = useCallback(async userData => {\n    try {\n      setAuthState({\n        loading: true,\n        error: null,\n        success: null\n      });\n      const endMeasurement = performanceMonitor.startMeasurement('register');\n      const response = await authService.register(userData);\n      endMeasurement();\n      if (!response.success) {\n        throw new Error(response.message || 'Registration failed');\n      }\n\n      // Log registration attempt\n      securityLogger.log('registration_attempt', {\n        email: userData.email,\n        role: userData.role,\n        username: userData.username\n      });\n      if (response.requiresVerification) {\n        setAuthState({\n          loading: false,\n          success: response.message || 'Registration successful! Please verify your email.'\n        });\n        securityLogger.log('registration_pending_verification', {\n          email: userData.email,\n          role: userData.role\n        });\n        return response;\n      }\n\n      // Auto-login after registration\n      const session = authService.getCurrentSession();\n      const permissions = new Set(response.data.user.permissions || []);\n      setAuthState({\n        user: response.data.user,\n        session,\n        sessionExpiresAt: session.expiresAt,\n        permissions,\n        loading: false,\n        success: response.message || 'Registration successful!'\n      });\n\n      // Log registration success\n      securityLogger.log('registration_success', {\n        email: userData.email,\n        role: userData.role,\n        username: userData.username\n      }, response.data.user, session);\n\n      // Schedule token refresh\n      scheduleTokenRefresh(session.expiresAt);\n\n      // Start session monitoring\n      startSessionMonitoring(session.expiresAt);\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'register');\n\n      // Log registration failure\n      securityLogger.log('registration_failed', {\n        email: userData.email,\n        role: userData.role,\n        error: error.message\n      });\n      let errorMessage = error.message || 'Registration failed. Please try again.';\n\n      // Handle specific error types\n      if (error.isAPIError) {\n        switch (error.code) {\n          case 'EMAIL_EXISTS':\n            errorMessage = 'An account with this email already exists.';\n            break;\n          case 'USERNAME_EXISTS':\n            errorMessage = 'This username is already taken.';\n            break;\n          case 'VALIDATION_ERROR':\n            if (error.errors) {\n              errorMessage = Object.values(error.errors).join('. ');\n            }\n            break;\n        }\n      }\n      setAuthState({\n        error: errorMessage,\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, securityLogger]);\n\n  // Logout\n  const logout = useCallback(async (reason = 'user_action') => {\n    const currentUser = stateRef.current.user;\n    const currentSession = stateRef.current.session;\n    try {\n      // Log logout event before clearing state\n      securityLogger.log('logout', {\n        reason: reason,\n        sessionDuration: currentSession ? (Date.now() - new Date(currentSession.createdAt).getTime()) / 1000 : null\n      }, currentUser, currentSession);\n      await authService.logout();\n    } catch (error) {\n      console.warn('Logout error:', error);\n      securityLogger.log('logout_error', {\n        error: error.message,\n        reason: reason\n      }, currentUser, currentSession);\n    } finally {\n      clearTimers();\n      setAuthState({\n        user: null,\n        session: null,\n        sessionExpiresAt: null,\n        permissions: new Set(),\n        error: null,\n        success: null,\n        loading: false\n      });\n    }\n  }, [clearTimers, securityLogger]);\n\n  // Check username availability\n  const checkUsername = useCallback(async username => {\n    try {\n      const response = await authService.checkUsername(username);\n      securityLogger.log('username_check', {\n        username: username,\n        available: response.available\n      });\n      return response;\n    } catch (error) {\n      console.error('Check username error:', error);\n      securityLogger.log('username_check_error', {\n        username: username,\n        error: error.message\n      });\n      return {\n        success: false,\n        available: false,\n        error: error.message\n      };\n    }\n  }, [securityLogger]);\n\n  // Check email availability\n  const checkEmail = useCallback(async email => {\n    try {\n      const response = await authService.checkEmail(email);\n      securityLogger.log('email_check', {\n        email: email,\n        available: response.available,\n        isUniversityEmail: email.includes('bugemauniv.ac.ug')\n      });\n      return response;\n    } catch (error) {\n      console.error('Check email error:', error);\n      securityLogger.log('email_check_error', {\n        email: email,\n        error: error.message\n      });\n      return {\n        success: false,\n        available: false,\n        error: error.message\n      };\n    }\n  }, [securityLogger]);\n\n  // Update profile\n  const updateProfile = useCallback(async updates => {\n    const currentUser = stateRef.current.user;\n    try {\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const response = await authService.updateProfile(updates);\n      if (!response.success) {\n        throw new Error(response.message || 'Update failed');\n      }\n\n      // Log profile update\n      securityLogger.log('profile_updated', {\n        updatedFields: Object.keys(updates),\n        previousRole: currentUser === null || currentUser === void 0 ? void 0 : currentUser.role,\n        newRole: response.data.role\n      }, response.data, stateRef.current.session);\n      setAuthState({\n        user: response.data,\n        loading: false,\n        success: response.message || 'Profile updated successfully'\n      });\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'updateProfile');\n      securityLogger.log('profile_update_failed', {\n        error: error.message,\n        attemptedUpdates: Object.keys(updates)\n      }, currentUser, stateRef.current.session);\n      setAuthState({\n        error: error.message || 'Failed to update profile',\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, performanceMonitor, securityLogger]);\n\n  // Change password\n  const changePassword = useCallback(async (currentPassword, newPassword) => {\n    const currentUser = stateRef.current.user;\n    try {\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const response = await authService.changePassword(currentPassword, newPassword);\n      if (!response.success) {\n        throw new Error(response.message || 'Password change failed');\n      }\n      securityLogger.log('password_changed', {\n        passwordStrength: newPassword.length\n      }, currentUser, stateRef.current.session);\n      setAuthState({\n        loading: false,\n        success: response.message || 'Password changed successfully'\n      });\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'changePassword');\n      securityLogger.log('password_change_failed', {\n        error: error.message\n      }, currentUser, stateRef.current.session);\n      setAuthState({\n        error: error.message || 'Failed to change password',\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, performanceMonitor, securityLogger]);\n\n  // Forgot password\n  const forgotPassword = useCallback(async email => {\n    try {\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const response = await authService.forgotPassword(email);\n\n      // Security: Always log as if successful (don't reveal if email exists)\n      securityLogger.log('forgot_password_requested', {\n        email: email,\n        timestamp: new Date().toISOString()\n      });\n      setAuthState({\n        loading: false,\n        success: 'If an account exists, you will receive reset instructions.'\n      });\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'forgotPassword');\n\n      // Still show success for security\n      setAuthState({\n        loading: false,\n        success: 'If an account exists, you will receive reset instructions.'\n      });\n      return {\n        success: true,\n        message: 'If an account exists, you will receive reset instructions.'\n      };\n    }\n  }, [setAuthState, performanceMonitor, securityLogger]);\n\n  // Reset password\n  const resetPassword = useCallback(async (token, passwordData) => {\n    try {\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const response = await authService.resetPassword(token, passwordData);\n      if (!response.success) {\n        throw new Error(response.message || 'Password reset failed');\n      }\n      securityLogger.log('password_reset', {\n        tokenUsed: token.substring(0, 8) + '...'\n      });\n      setAuthState({\n        loading: false,\n        success: response.message || 'Password reset successful'\n      });\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'resetPassword');\n      securityLogger.log('password_reset_failed', {\n        tokenUsed: token ? token.substring(0, 8) + '...' : 'no-token',\n        error: error.message\n      });\n      setAuthState({\n        error: error.message || 'Failed to reset password',\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, performanceMonitor, securityLogger]);\n\n  // Verify email\n  const verifyEmail = useCallback(async token => {\n    try {\n      var _response$data;\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const response = await authService.verifyEmail(token);\n      if (!response.success) {\n        throw new Error(response.message || 'Verification failed');\n      }\n      securityLogger.log('email_verified', {\n        tokenUsed: token.substring(0, 8) + '...',\n        email: (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.email\n      }, response.data);\n      setAuthState({\n        loading: false,\n        success: response.message || 'Email verified successfully'\n      });\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'verifyEmail');\n      securityLogger.log('email_verification_failed', {\n        tokenUsed: token.substring(0, 8) + '...',\n        error: error.message\n      });\n      setAuthState({\n        error: error.message || 'Failed to verify email',\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, performanceMonitor, securityLogger]);\n\n  // Check permissions\n  const hasPermission = useCallback(permission => {\n    var _state$user;\n    const hasPerm = state.permissions.has(permission) || ((_state$user = state.user) === null || _state$user === void 0 ? void 0 : _state$user.role) === 'admin';\n    return hasPerm;\n  }, [state.permissions, state.user]);\n  const hasRole = useCallback(role => {\n    var _state$user2;\n    return ((_state$user2 = state.user) === null || _state$user2 === void 0 ? void 0 : _state$user2.role) === role;\n  }, [state.user]);\n  const hasAnyRole = useCallback(roles => {\n    var _state$user3;\n    return roles.includes((_state$user3 = state.user) === null || _state$user3 === void 0 ? void 0 : _state$user3.role);\n  }, [state.user]);\n\n  // Clear messages\n  const clearError = useCallback(() => {\n    setAuthState({\n      error: null\n    });\n  }, [setAuthState]);\n  const clearSuccess = useCallback(() => {\n    setAuthState({\n      success: null\n    });\n  }, [setAuthState]);\n\n  // Initialize on mount - FIXED: No infinite loop\n  useEffect(() => {\n    isMountedRef.current = true;\n    let activityCleanup;\n    const initAuth = async () => {\n      activityCleanup = await initializeAuth();\n    };\n    initAuth();\n    return () => {\n      isMountedRef.current = false;\n      clearTimers();\n      if (activityCleanup && typeof activityCleanup === 'function') {\n        activityCleanup();\n      }\n\n      // Clean up security logger queue\n      if (securityLogger.getQueueSize() > 0) {\n        console.log(`Flushing ${securityLogger.getQueueSize()} security logs before unmount`);\n      }\n    };\n  }, [initializeAuth, clearTimers]);\n\n  // Context value\n  const contextValue = useMemo(() => ({\n    // State\n    user: state.user,\n    session: state.session,\n    loading: state.loading,\n    error: state.error,\n    success: state.success,\n    sessionExpiresAt: state.sessionExpiresAt,\n    // Authentication methods\n    login,\n    register,\n    logout,\n    // Validation methods\n    checkUsername,\n    checkEmail,\n    // User management\n    updateProfile,\n    changePassword,\n    forgotPassword,\n    resetPassword,\n    verifyEmail,\n    // Permission checks\n    hasPermission,\n    hasRole,\n    hasAnyRole,\n    isAuthenticated: !!state.user && !!state.session,\n    // Utility methods\n    clearError,\n    clearSuccess\n  }), [state, login, register, logout, checkUsername, checkEmail, updateProfile, changePassword, forgotPassword, resetPassword, verifyEmail, hasPermission, hasRole, hasAnyRole, clearError, clearSuccess]);\n  return /*#__PURE__*/_jsxDEV(AuthErrorBoundary, {\n    children: /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n      value: contextValue,\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1005,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1004,\n    columnNumber: 5\n  }, this);\n};\n\n// PropTypes\n_s2(AuthProvider, \"GCuVYqZDJeIF3qmYg0EYeEjqatg=\");\n_c = AuthProvider;\nAuthProvider.propTypes = {\n  children: PropTypes.node.isRequired\n};\nexport default AuthContext;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useCallback","useRef","useMemo","PropTypes","authService","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","context","Error","AuthErrorBoundary","Component","constructor","props","state","hasError","error","getDerivedStateFromError","componentDidCatch","errorInfo","console","process","env","NODE_ENV","fetch","method","headers","body","JSON","stringify","message","component","timestamp","Date","toISOString","e","render","style","padding","textAlign","backgroundColor","borderRadius","margin","children","color","marginBottom","fileName","_jsxFileName","lineNumber","columnNumber","onClick","window","location","reload","border","cursor","fontSize","fontWeight","createPerformanceMonitor","metrics","loginTime","refreshTime","sessionChecks","errors","securityEvents","startMeasurement","operation","startTime","performance","now","duration","warn","toFixed","logError","push","logSecurityEvent","eventType","details","event","importantEvents","includes","log","getMetrics","clear","createSecurityLogger","performanceMonitor","queue","isSending","sendToBackend","response","signal","AbortSignal","timeout","ok","status","failedLogs","parse","localStorage","getItem","setItem","slice","processQueue","length","shift","setTimeout","userData","sessionData","_navigator$userAgent","userId","id","userRole","role","sessionId","source","userAgent","navigator","substring","url","href","screenResolution","screen","width","height","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","flush","events","getQueueSize","AuthProvider","_s2","setState","user","session","loading","success","sessionExpiresAt","permissions","Set","refreshTimerRef","sessionCheckRef","activityTimerRef","isMountedRef","securityLogger","stateRef","current","setAuthState","updates","prev","clearTimers","clearTimeout","clearInterval","scheduleTokenRefresh","expiresAt","endMeasurement","refreshAccessToken","getCurrentSession","Math","max","startSessionMonitoring","setInterval","logout","activityListeners","trackActivity","forEach","addEventListener","passive","handler","removeEventListener","initializeAuth","userResponse","getCurrentUser","data","cleanupActivityTracking","sessionExists","login","email","password","rememberMe","ip","errorMessage","register","username","requiresVerification","isAPIError","code","Object","values","join","reason","currentUser","currentSession","sessionDuration","createdAt","getTime","checkUsername","available","checkEmail","isUniversityEmail","updateProfile","updatedFields","keys","previousRole","newRole","attemptedUpdates","changePassword","currentPassword","newPassword","passwordStrength","forgotPassword","resetPassword","token","passwordData","tokenUsed","verifyEmail","_response$data","hasPermission","permission","_state$user","hasPerm","has","hasRole","_state$user2","hasAnyRole","roles","_state$user3","clearError","clearSuccess","activityCleanup","initAuth","contextValue","isAuthenticated","Provider","value","_c","propTypes","node","isRequired","$RefreshReg$"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/context/AuthContext.js"],"sourcesContent":["// frontend/src/context/AuthContext.js - PRODUCTION READY FIXED VERSION\r\nimport React, { createContext, useState, useContext, useEffect, useCallback, useRef, useMemo } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { authService } from '../services/authService';\r\n\r\n/**\r\n * Enterprise Auth Context v5.2.0 - FIXED PRODUCTION VERSION\r\n * Fixed Issues:\r\n * - Removed infinite re-render loop from logSecurityEvent\r\n * - Optimized performance with proper memoization\r\n * - Fixed cleanup dependencies\r\n * - Stable event logging without state dependencies\r\n */\r\n\r\n// Context\r\nexport const AuthContext = createContext();\r\n\r\n// Custom hook\r\nexport const useAuth = () => {\r\n  const context = useContext(AuthContext);\r\n  if (!context) {\r\n    throw new Error('useAuth must be used within AuthProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// Error boundary for auth errors\r\nclass AuthErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { hasError: false, error: null };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    return { hasError: true, error };\r\n  }\r\n\r\n  componentDidCatch(error, errorInfo) {\r\n    console.error('Auth Error Boundary caught:', error, errorInfo);\r\n    \r\n    // Send error to monitoring service in production\r\n    if (process.env.NODE_ENV === 'production') {\r\n      try {\r\n        fetch('/api/monitoring/errors', {\r\n          method: 'POST',\r\n          headers: { 'Content-Type': 'application/json' },\r\n          body: JSON.stringify({\r\n            error: error.message,\r\n            errorInfo,\r\n            component: 'AuthErrorBoundary',\r\n            timestamp: new Date().toISOString()\r\n          })\r\n        });\r\n      } catch (e) {\r\n        // Silent fail for monitoring errors\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return (\r\n        <div style={{\r\n          padding: '40px',\r\n          textAlign: 'center',\r\n          backgroundColor: '#fef2f2',\r\n          borderRadius: '8px',\r\n          margin: '20px'\r\n        }}>\r\n          <h3 style={{ color: '#dc2626', marginBottom: '16px' }}>\r\n            Authentication Error\r\n          </h3>\r\n          <p style={{ color: '#4b5563', marginBottom: '24px' }}>\r\n            Something went wrong with authentication. Please try refreshing the page.\r\n          </p>\r\n          <button\r\n            onClick={() => window.location.reload()}\r\n            style={{\r\n              padding: '10px 24px',\r\n              backgroundColor: '#3b82f6',\r\n              color: 'white',\r\n              border: 'none',\r\n              borderRadius: '6px',\r\n              cursor: 'pointer',\r\n              fontSize: '14px',\r\n              fontWeight: '500'\r\n            }}\r\n          >\r\n            Refresh Page\r\n          </button>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\n// Performance monitoring - isolated from render cycles\r\nconst createPerformanceMonitor = () => {\r\n  const metrics = {\r\n    loginTime: null,\r\n    refreshTime: null,\r\n    sessionChecks: 0,\r\n    errors: [],\r\n    securityEvents: []\r\n  };\r\n\r\n  return {\r\n    startMeasurement(operation) {\r\n      const startTime = performance.now();\r\n      return () => {\r\n        const duration = performance.now() - startTime;\r\n        metrics[operation] = duration;\r\n        \r\n        if (duration > 1000 && process.env.NODE_ENV === 'development') {\r\n          console.warn(`Slow auth operation: ${operation} took ${duration.toFixed(2)}ms`);\r\n        }\r\n      };\r\n    },\r\n\r\n    logError(error, operation) {\r\n      metrics.errors.push({\r\n        operation,\r\n        error: error.message,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n    },\r\n\r\n    logSecurityEvent(eventType, details) {\r\n      const event = {\r\n        eventType,\r\n        details,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n      \r\n      metrics.securityEvents.push(event);\r\n      \r\n      // Only log to console in development for specific events\r\n      if (process.env.NODE_ENV === 'development') {\r\n        const importantEvents = [\r\n          'login_failed',\r\n          'registration_failed',\r\n          'session_expired',\r\n          'security_violation'\r\n        ];\r\n        \r\n        if (importantEvents.includes(eventType)) {\r\n          console.log(`[SECURITY] ${eventType}:`, details);\r\n        }\r\n      }\r\n      \r\n      return event;\r\n    },\r\n\r\n    getMetrics() {\r\n      return { ...metrics };\r\n    },\r\n    \r\n    clear() {\r\n      metrics.errors = [];\r\n      metrics.securityEvents = [];\r\n    }\r\n  };\r\n};\r\n\r\n// Security Logger - Decoupled from React state\r\nconst createSecurityLogger = (performanceMonitor) => {\r\n  let queue = [];\r\n  let isSending = false;\r\n  \r\n  const sendToBackend = async (event) => {\r\n    if (process.env.NODE_ENV !== 'production' || !event) return;\r\n    \r\n    try {\r\n      // In production, send to backend with retry logic\r\n      const response = await fetch('/api/logs/security', {\r\n        method: 'POST',\r\n        headers: { \r\n          'Content-Type': 'application/json',\r\n          'X-Client-Version': '1.0.0'\r\n        },\r\n        body: JSON.stringify(event),\r\n        signal: AbortSignal.timeout(5000) // 5 second timeout\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP ${response.status}`);\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      // Store failed logs in localStorage for retry\r\n      try {\r\n        const failedLogs = JSON.parse(localStorage.getItem('failed_security_logs') || '[]');\r\n        failedLogs.push({ event, error: error.message, timestamp: new Date().toISOString() });\r\n        localStorage.setItem('failed_security_logs', JSON.stringify(failedLogs.slice(-50))); // Keep last 50\r\n      } catch (e) {\r\n        // localStorage may be full or blocked\r\n      }\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  const processQueue = async () => {\r\n    if (isSending || queue.length === 0) return;\r\n    \r\n    isSending = true;\r\n    const event = queue.shift();\r\n    \r\n    try {\r\n      await sendToBackend(event);\r\n    } finally {\r\n      isSending = false;\r\n      \r\n      if (queue.length > 0) {\r\n        // Process next event with delay\r\n        setTimeout(processQueue, 100);\r\n      }\r\n    }\r\n  };\r\n  \r\n  return {\r\n    log(eventType, details, userData = null, sessionData = null) {\r\n      const event = {\r\n        eventType,\r\n        details,\r\n        timestamp: new Date().toISOString(),\r\n        userId: userData?.id || null,\r\n        userRole: userData?.role || null,\r\n        sessionId: sessionData?.id || null,\r\n        source: 'auth_context',\r\n        userAgent: navigator.userAgent?.substring(0, 200) || 'unknown',\r\n        url: window.location.href,\r\n        screenResolution: `${window.screen.width}x${window.screen.height}`,\r\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown'\r\n      };\r\n      \r\n      // Store in performance monitor for debugging\r\n      performanceMonitor.logSecurityEvent(eventType, details);\r\n      \r\n      // Add to queue for backend processing\r\n      queue.push(event);\r\n      \r\n      // Start processing if not already\r\n      if (!isSending) {\r\n        setTimeout(processQueue, 0);\r\n      }\r\n      \r\n      return event;\r\n    },\r\n    \r\n    flush() {\r\n      const events = [...queue];\r\n      queue = [];\r\n      return events;\r\n    },\r\n    \r\n    getQueueSize() {\r\n      return queue.length;\r\n    }\r\n  };\r\n};\r\n\r\n// Main provider component - FIXED VERSION\r\nexport const AuthProvider = ({ children }) => {\r\n  // State management\r\n  const [state, setState] = useState({\r\n    user: null,\r\n    session: null,\r\n    loading: true,\r\n    error: null,\r\n    success: null,\r\n    sessionExpiresAt: null,\r\n    permissions: new Set()\r\n  });\r\n\r\n  // Refs for cleanup and stable references\r\n  const refreshTimerRef = useRef(null);\r\n  const sessionCheckRef = useRef(null);\r\n  const activityTimerRef = useRef(null);\r\n  const isMountedRef = useRef(true);\r\n  const performanceMonitor = useMemo(() => createPerformanceMonitor(), []);\r\n  const securityLogger = useMemo(() => createSecurityLogger(performanceMonitor), [performanceMonitor]);\r\n  \r\n  // Store state in ref for access in callbacks without re-renders\r\n  const stateRef = useRef(state);\r\n  useEffect(() => {\r\n    stateRef.current = state;\r\n  }, [state]);\r\n\r\n  // Update state safely\r\n  const setAuthState = useCallback((updates) => {\r\n    if (isMountedRef.current) {\r\n      setState(prev => ({ ...prev, ...updates }));\r\n    }\r\n  }, []);\r\n\r\n  // Clear all timers\r\n  const clearTimers = useCallback(() => {\r\n    if (refreshTimerRef.current) {\r\n      clearTimeout(refreshTimerRef.current);\r\n      refreshTimerRef.current = null;\r\n    }\r\n    \r\n    if (sessionCheckRef.current) {\r\n      clearInterval(sessionCheckRef.current);\r\n      sessionCheckRef.current = null;\r\n    }\r\n    \r\n    if (activityTimerRef.current) {\r\n      clearTimeout(activityTimerRef.current);\r\n      activityTimerRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  // Schedule token refresh\r\n  const scheduleTokenRefresh = useCallback((expiresAt) => {\r\n    clearTimers();\r\n    \r\n    if (!expiresAt) return;\r\n\r\n    const refreshTime = expiresAt - (5 * 60 * 1000) - Date.now();\r\n    \r\n    if (refreshTime > 0) {\r\n      refreshTimerRef.current = setTimeout(async () => {\r\n        try {\r\n          const endMeasurement = performanceMonitor.startMeasurement('tokenRefresh');\r\n          await authService.refreshAccessToken();\r\n          endMeasurement();\r\n          \r\n          // Update session after refresh\r\n          const session = authService.getCurrentSession();\r\n          if (session) {\r\n            setAuthState({\r\n              session,\r\n              sessionExpiresAt: session.expiresAt\r\n            });\r\n            scheduleTokenRefresh(session.expiresAt);\r\n          }\r\n        } catch (error) {\r\n          performanceMonitor.logError(error, 'tokenRefresh');\r\n          console.error('Token refresh failed:', error);\r\n        }\r\n      }, Math.max(refreshTime, 0)); // Ensure non-negative\r\n    }\r\n  }, [clearTimers, performanceMonitor, setAuthState]);\r\n\r\n  // Start session monitoring\r\n  const startSessionMonitoring = useCallback((expiresAt) => {\r\n    clearTimers();\r\n    \r\n    // Check session every minute\r\n    sessionCheckRef.current = setInterval(() => {\r\n      if (expiresAt && Date.now() > expiresAt) {\r\n        logout('session_expired');\r\n      }\r\n    }, 60 * 1000);\r\n\r\n    // Activity tracking\r\n    const activityListeners = [];\r\n    const trackActivity = () => {\r\n      if (activityTimerRef.current) {\r\n        clearTimeout(activityTimerRef.current);\r\n      }\r\n      \r\n      activityTimerRef.current = setTimeout(() => {\r\n        logout('inactivity');\r\n      }, 30 * 60 * 1000); // 30 minutes\r\n    };\r\n\r\n    // Track user activity\r\n    ['mousemove', 'keydown', 'click', 'scroll'].forEach(event => {\r\n      window.addEventListener(event, trackActivity, { passive: true });\r\n      activityListeners.push({ event, handler: trackActivity });\r\n    });\r\n\r\n    trackActivity();\r\n    \r\n    // Return cleanup function\r\n    return () => {\r\n      activityListeners.forEach(({ event, handler }) => {\r\n        window.removeEventListener(event, handler);\r\n      });\r\n    };\r\n  }, [clearTimers]);\r\n\r\n  // Initialize auth state\r\n  const initializeAuth = useCallback(async () => {\r\n    if (!isMountedRef.current) return;\r\n    \r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n\r\n      const session = authService.getCurrentSession();\r\n      \r\n      if (!session) {\r\n        setAuthState({ loading: false });\r\n        return;\r\n      }\r\n\r\n      // Verify session is still valid\r\n      if (Date.now() > session.expiresAt) {\r\n        await logout('session_expired');\r\n        return;\r\n      }\r\n\r\n      // Get fresh user data\r\n      const userResponse = await authService.getCurrentUser();\r\n      \r\n      if (!userResponse.success) {\r\n        throw new Error('Failed to get user data');\r\n      }\r\n\r\n      const permissions = new Set(userResponse.data.permissions || []);\r\n\r\n      setAuthState({\r\n        user: userResponse.data,\r\n        session,\r\n        sessionExpiresAt: session.expiresAt,\r\n        permissions,\r\n        loading: false\r\n      });\r\n\r\n      // Log security event (async, non-blocking)\r\n      securityLogger.log('session_initialized', {\r\n        userId: userResponse.data.id,\r\n        role: userResponse.data.role,\r\n        sessionId: session.id,\r\n        sessionExpiresAt: new Date(session.expiresAt).toISOString()\r\n      }, userResponse.data, session);\r\n\r\n      // Schedule token refresh\r\n      scheduleTokenRefresh(session.expiresAt);\r\n      \r\n      // Start session monitoring\r\n      const cleanupActivityTracking = startSessionMonitoring(session.expiresAt);\r\n      \r\n      // Return cleanup function\r\n      return cleanupActivityTracking;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'initializeAuth');\r\n      console.error('Auth initialization error:', error);\r\n      \r\n      securityLogger.log('initialization_failed', {\r\n        error: error.message,\r\n        sessionExists: !!authService.getCurrentSession()\r\n      });\r\n      \r\n      setAuthState({\r\n        error: 'Failed to initialize authentication',\r\n        loading: false\r\n      });\r\n    }\r\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, securityLogger]);\r\n\r\n  // Login\r\n  const login = useCallback(async (email, password, rememberMe = false) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null, success: null });\r\n      \r\n      const endMeasurement = performanceMonitor.startMeasurement('login');\r\n      const response = await authService.login(email, password, rememberMe);\r\n      endMeasurement();\r\n\r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Login failed');\r\n      }\r\n\r\n      const session = authService.getCurrentSession();\r\n      const permissions = new Set(response.data.user.permissions || []);\r\n\r\n      setAuthState({\r\n        user: response.data.user,\r\n        session,\r\n        sessionExpiresAt: session.expiresAt,\r\n        permissions,\r\n        loading: false,\r\n        success: 'Login successful'\r\n      });\r\n\r\n      // Log security event\r\n      securityLogger.log('login_success', {\r\n        email: email,\r\n        rememberMe,\r\n        ip: 'client-side'\r\n      }, response.data.user, session);\r\n\r\n      // Schedule token refresh\r\n      scheduleTokenRefresh(session.expiresAt);\r\n      \r\n      // Start session monitoring\r\n      startSessionMonitoring(session.expiresAt);\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'login');\r\n      \r\n      // Log failed login attempt\r\n      securityLogger.log('login_failed', {\r\n        email: email,\r\n        error: error.message\r\n      });\r\n      \r\n      const errorMessage = error.message || 'Login failed. Please check your credentials.';\r\n      \r\n      setAuthState({\r\n        error: errorMessage,\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, securityLogger]);\r\n\r\n  // Register\r\n  const register = useCallback(async (userData) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null, success: null });\r\n      \r\n      const endMeasurement = performanceMonitor.startMeasurement('register');\r\n      const response = await authService.register(userData);\r\n      endMeasurement();\r\n\r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Registration failed');\r\n      }\r\n\r\n      // Log registration attempt\r\n      securityLogger.log('registration_attempt', {\r\n        email: userData.email,\r\n        role: userData.role,\r\n        username: userData.username\r\n      });\r\n\r\n      if (response.requiresVerification) {\r\n        setAuthState({\r\n          loading: false,\r\n          success: response.message || 'Registration successful! Please verify your email.'\r\n        });\r\n        \r\n        securityLogger.log('registration_pending_verification', {\r\n          email: userData.email,\r\n          role: userData.role\r\n        });\r\n        \r\n        return response;\r\n      }\r\n\r\n      // Auto-login after registration\r\n      const session = authService.getCurrentSession();\r\n      const permissions = new Set(response.data.user.permissions || []);\r\n\r\n      setAuthState({\r\n        user: response.data.user,\r\n        session,\r\n        sessionExpiresAt: session.expiresAt,\r\n        permissions,\r\n        loading: false,\r\n        success: response.message || 'Registration successful!'\r\n      });\r\n\r\n      // Log registration success\r\n      securityLogger.log('registration_success', {\r\n        email: userData.email,\r\n        role: userData.role,\r\n        username: userData.username\r\n      }, response.data.user, session);\r\n\r\n      // Schedule token refresh\r\n      scheduleTokenRefresh(session.expiresAt);\r\n      \r\n      // Start session monitoring\r\n      startSessionMonitoring(session.expiresAt);\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'register');\r\n      \r\n      // Log registration failure\r\n      securityLogger.log('registration_failed', {\r\n        email: userData.email,\r\n        role: userData.role,\r\n        error: error.message\r\n      });\r\n      \r\n      let errorMessage = error.message || 'Registration failed. Please try again.';\r\n      \r\n      // Handle specific error types\r\n      if (error.isAPIError) {\r\n        switch (error.code) {\r\n          case 'EMAIL_EXISTS':\r\n            errorMessage = 'An account with this email already exists.';\r\n            break;\r\n          case 'USERNAME_EXISTS':\r\n            errorMessage = 'This username is already taken.';\r\n            break;\r\n          case 'VALIDATION_ERROR':\r\n            if (error.errors) {\r\n              errorMessage = Object.values(error.errors).join('. ');\r\n            }\r\n            break;\r\n        }\r\n      }\r\n\r\n      setAuthState({\r\n        error: errorMessage,\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, securityLogger]);\r\n\r\n  // Logout\r\n  const logout = useCallback(async (reason = 'user_action') => {\r\n    const currentUser = stateRef.current.user;\r\n    const currentSession = stateRef.current.session;\r\n    \r\n    try {\r\n      // Log logout event before clearing state\r\n      securityLogger.log('logout', {\r\n        reason: reason,\r\n        sessionDuration: currentSession ? \r\n          (Date.now() - new Date(currentSession.createdAt).getTime()) / 1000 : null\r\n      }, currentUser, currentSession);\r\n      \r\n      await authService.logout();\r\n    } catch (error) {\r\n      console.warn('Logout error:', error);\r\n      securityLogger.log('logout_error', {\r\n        error: error.message,\r\n        reason: reason\r\n      }, currentUser, currentSession);\r\n    } finally {\r\n      clearTimers();\r\n      \r\n      setAuthState({\r\n        user: null,\r\n        session: null,\r\n        sessionExpiresAt: null,\r\n        permissions: new Set(),\r\n        error: null,\r\n        success: null,\r\n        loading: false\r\n      });\r\n    }\r\n  }, [clearTimers, securityLogger]);\r\n\r\n  // Check username availability\r\n  const checkUsername = useCallback(async (username) => {\r\n    try {\r\n      const response = await authService.checkUsername(username);\r\n      \r\n      securityLogger.log('username_check', {\r\n        username: username,\r\n        available: response.available\r\n      });\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('Check username error:', error);\r\n      \r\n      securityLogger.log('username_check_error', {\r\n        username: username,\r\n        error: error.message\r\n      });\r\n      \r\n      return { success: false, available: false, error: error.message };\r\n    }\r\n  }, [securityLogger]);\r\n\r\n  // Check email availability\r\n  const checkEmail = useCallback(async (email) => {\r\n    try {\r\n      const response = await authService.checkEmail(email);\r\n      \r\n      securityLogger.log('email_check', {\r\n        email: email,\r\n        available: response.available,\r\n        isUniversityEmail: email.includes('bugemauniv.ac.ug')\r\n      });\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('Check email error:', error);\r\n      \r\n      securityLogger.log('email_check_error', {\r\n        email: email,\r\n        error: error.message\r\n      });\r\n      \r\n      return { success: false, available: false, error: error.message };\r\n    }\r\n  }, [securityLogger]);\r\n\r\n  // Update profile\r\n  const updateProfile = useCallback(async (updates) => {\r\n    const currentUser = stateRef.current.user;\r\n    \r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n      \r\n      const response = await authService.updateProfile(updates);\r\n      \r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Update failed');\r\n      }\r\n\r\n      // Log profile update\r\n      securityLogger.log('profile_updated', {\r\n        updatedFields: Object.keys(updates),\r\n        previousRole: currentUser?.role,\r\n        newRole: response.data.role\r\n      }, response.data, stateRef.current.session);\r\n\r\n      setAuthState({\r\n        user: response.data,\r\n        loading: false,\r\n        success: response.message || 'Profile updated successfully'\r\n      });\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'updateProfile');\r\n      \r\n      securityLogger.log('profile_update_failed', {\r\n        error: error.message,\r\n        attemptedUpdates: Object.keys(updates)\r\n      }, currentUser, stateRef.current.session);\r\n      \r\n      setAuthState({\r\n        error: error.message || 'Failed to update profile',\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, performanceMonitor, securityLogger]);\r\n\r\n  // Change password\r\n  const changePassword = useCallback(async (currentPassword, newPassword) => {\r\n    const currentUser = stateRef.current.user;\r\n    \r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n      \r\n      const response = await authService.changePassword(currentPassword, newPassword);\r\n      \r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Password change failed');\r\n      }\r\n\r\n      securityLogger.log('password_changed', {\r\n        passwordStrength: newPassword.length\r\n      }, currentUser, stateRef.current.session);\r\n\r\n      setAuthState({\r\n        loading: false,\r\n        success: response.message || 'Password changed successfully'\r\n      });\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'changePassword');\r\n      \r\n      securityLogger.log('password_change_failed', {\r\n        error: error.message\r\n      }, currentUser, stateRef.current.session);\r\n      \r\n      setAuthState({\r\n        error: error.message || 'Failed to change password',\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, performanceMonitor, securityLogger]);\r\n\r\n  // Forgot password\r\n  const forgotPassword = useCallback(async (email) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n      \r\n      const response = await authService.forgotPassword(email);\r\n      \r\n      // Security: Always log as if successful (don't reveal if email exists)\r\n      securityLogger.log('forgot_password_requested', {\r\n        email: email,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      setAuthState({\r\n        loading: false,\r\n        success: 'If an account exists, you will receive reset instructions.'\r\n      });\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'forgotPassword');\r\n      \r\n      // Still show success for security\r\n      setAuthState({\r\n        loading: false,\r\n        success: 'If an account exists, you will receive reset instructions.'\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        message: 'If an account exists, you will receive reset instructions.'\r\n      };\r\n    }\r\n  }, [setAuthState, performanceMonitor, securityLogger]);\r\n\r\n  // Reset password\r\n  const resetPassword = useCallback(async (token, passwordData) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n      \r\n      const response = await authService.resetPassword(token, passwordData);\r\n      \r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Password reset failed');\r\n      }\r\n\r\n      securityLogger.log('password_reset', {\r\n        tokenUsed: token.substring(0, 8) + '...'\r\n      });\r\n\r\n      setAuthState({\r\n        loading: false,\r\n        success: response.message || 'Password reset successful'\r\n      });\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'resetPassword');\r\n      \r\n      securityLogger.log('password_reset_failed', {\r\n        tokenUsed: token ? token.substring(0, 8) + '...' : 'no-token',\r\n        error: error.message\r\n      });\r\n      \r\n      setAuthState({\r\n        error: error.message || 'Failed to reset password',\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, performanceMonitor, securityLogger]);\r\n\r\n  // Verify email\r\n  const verifyEmail = useCallback(async (token) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n      \r\n      const response = await authService.verifyEmail(token);\r\n      \r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Verification failed');\r\n      }\r\n\r\n      securityLogger.log('email_verified', {\r\n        tokenUsed: token.substring(0, 8) + '...',\r\n        email: response.data?.email\r\n      }, response.data);\r\n\r\n      setAuthState({\r\n        loading: false,\r\n        success: response.message || 'Email verified successfully'\r\n      });\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'verifyEmail');\r\n      \r\n      securityLogger.log('email_verification_failed', {\r\n        tokenUsed: token.substring(0, 8) + '...',\r\n        error: error.message\r\n      });\r\n      \r\n      setAuthState({\r\n        error: error.message || 'Failed to verify email',\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, performanceMonitor, securityLogger]);\r\n\r\n  // Check permissions\r\n  const hasPermission = useCallback((permission) => {\r\n    const hasPerm = state.permissions.has(permission) || state.user?.role === 'admin';\r\n    return hasPerm;\r\n  }, [state.permissions, state.user]);\r\n\r\n  const hasRole = useCallback((role) => {\r\n    return state.user?.role === role;\r\n  }, [state.user]);\r\n\r\n  const hasAnyRole = useCallback((roles) => {\r\n    return roles.includes(state.user?.role);\r\n  }, [state.user]);\r\n\r\n  // Clear messages\r\n  const clearError = useCallback(() => {\r\n    setAuthState({ error: null });\r\n  }, [setAuthState]);\r\n\r\n  const clearSuccess = useCallback(() => {\r\n    setAuthState({ success: null });\r\n  }, [setAuthState]);\r\n\r\n  // Initialize on mount - FIXED: No infinite loop\r\n  useEffect(() => {\r\n    isMountedRef.current = true;\r\n    let activityCleanup;\r\n    \r\n    const initAuth = async () => {\r\n      activityCleanup = await initializeAuth();\r\n    };\r\n    \r\n    initAuth();\r\n\r\n    return () => {\r\n      isMountedRef.current = false;\r\n      clearTimers();\r\n      \r\n      if (activityCleanup && typeof activityCleanup === 'function') {\r\n        activityCleanup();\r\n      }\r\n      \r\n      // Clean up security logger queue\r\n      if (securityLogger.getQueueSize() > 0) {\r\n        console.log(`Flushing ${securityLogger.getQueueSize()} security logs before unmount`);\r\n      }\r\n    };\r\n  }, [initializeAuth, clearTimers]);\r\n\r\n  // Context value\r\n  const contextValue = useMemo(() => ({\r\n    // State\r\n    user: state.user,\r\n    session: state.session,\r\n    loading: state.loading,\r\n    error: state.error,\r\n    success: state.success,\r\n    sessionExpiresAt: state.sessionExpiresAt,\r\n    \r\n    // Authentication methods\r\n    login,\r\n    register,\r\n    logout,\r\n    \r\n    // Validation methods\r\n    checkUsername,\r\n    checkEmail,\r\n    \r\n    // User management\r\n    updateProfile,\r\n    changePassword,\r\n    forgotPassword,\r\n    resetPassword,\r\n    verifyEmail,\r\n    \r\n    // Permission checks\r\n    hasPermission,\r\n    hasRole,\r\n    hasAnyRole,\r\n    isAuthenticated: !!state.user && !!state.session,\r\n    \r\n    // Utility methods\r\n    clearError,\r\n    clearSuccess\r\n  }), [\r\n    state,\r\n    login,\r\n    register,\r\n    logout,\r\n    checkUsername,\r\n    checkEmail,\r\n    updateProfile,\r\n    changePassword,\r\n    forgotPassword,\r\n    resetPassword,\r\n    verifyEmail,\r\n    hasPermission,\r\n    hasRole,\r\n    hasAnyRole,\r\n    clearError,\r\n    clearSuccess\r\n  ]);\r\n\r\n  return (\r\n    <AuthErrorBoundary>\r\n      <AuthContext.Provider value={contextValue}>\r\n        {children}\r\n      </AuthContext.Provider>\r\n    </AuthErrorBoundary>\r\n  );\r\n};\r\n\r\n// PropTypes\r\nAuthProvider.propTypes = {\r\n  children: PropTypes.node.isRequired\r\n};\r\n\r\nexport default AuthContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}