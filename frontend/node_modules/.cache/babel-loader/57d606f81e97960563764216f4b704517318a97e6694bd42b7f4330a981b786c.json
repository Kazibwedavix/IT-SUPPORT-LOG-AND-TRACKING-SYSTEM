{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\KADZ-TECH\\\\Documents\\\\dev\\\\it-support-system\\\\frontend\\\\src\\\\context\\\\AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect, useCallback, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport authService from '../services/authService';\nimport api from '../services/api';\n\n/**\r\n * AuthContext - Optimized to avoid repeated /auth/me calls\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const AuthContext = /*#__PURE__*/createContext();\nexport const useAuth = () => {\n  _s();\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\n/* -------------------------\r\n  Helpers: Validation + Sanitization\r\n   (unchanged from your original)\r\n   ------------------------- */\n_s(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst validateUserData = userData => {\n  if (!userData || typeof userData !== 'object') {\n    return false;\n  }\n  const requiredFields = ['_id', 'email', 'role'];\n  for (const field of requiredFields) {\n    if (!userData[field]) {\n      console.warn(`Invalid user data: Missing ${field}`);\n      return false;\n    }\n  }\n  const validRoles = ['admin', 'technician', 'staff', 'student'];\n  if (!validRoles.includes(userData.role)) {\n    console.warn(`Invalid user data: Invalid role \"${userData.role}\"`);\n    return false;\n  }\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(userData.email)) {\n    console.warn(`Invalid user data: Invalid email \"${userData.email}\"`);\n    return false;\n  }\n  return true;\n};\nconst sanitizeUserData = userData => {\n  if (!userData) return null;\n  const sanitized = {\n    ...userData\n  };\n  delete sanitized.password;\n  delete sanitized.tempPassword;\n  delete sanitized.resetToken;\n  delete sanitized.verificationToken;\n  delete sanitized.__v;\n  if (sanitized.role) sanitized.role = sanitized.role.toLowerCase();\n  return sanitized;\n};\nconst sendToSecurityLog = eventData => {\n  try {\n    const existingEvents = JSON.parse(localStorage.getItem('security_events') || '[]');\n    existingEvents.push(eventData);\n    if (existingEvents.length > 50) existingEvents.shift();\n    localStorage.setItem('security_events', JSON.stringify(existingEvents));\n  } catch (e) {\n    // ignore\n  }\n};\n\n/* -------------------------\r\n  Caching / Deduplication Globals\r\n  - Keeps things at module scope so multiple mounts share cache\r\n  ------------------------- */\n\nlet authCheckPromise = null; // in-flight GET /auth/me promise\nlet lastAuthCheck = null; // { data, timestamp }\nconst AUTH_CACHE_TIME = 5000; // 5 seconds cache\n\nlet authInitPromise = null; // protects initializeAuth from running multiple times\n\n/* Cached GET current user:\r\n   - returns cached data if recent\r\n   - dedupes in-flight requests\r\n   - console.trace() on new network calls to help debugging\r\n*/\nconst getCurrentUserCached = async () => {\n  const now = Date.now();\n\n  // Return cached result if still fresh\n  if (lastAuthCheck && now - lastAuthCheck.timestamp < AUTH_CACHE_TIME) {\n    return lastAuthCheck.data;\n  }\n\n  // If an in-flight promise exists, reuse it\n  if (authCheckPromise) {\n    return authCheckPromise;\n  }\n\n  // Make new request and store the promise\n  authCheckPromise = (async () => {\n    // Helpful trace to find callers (only when we truly call the network)\n    try {\n      console.trace('ðŸ” getCurrentUserCached network call stack:');\n    } catch (e) {}\n    try {\n      var _response$data;\n      const response = await authService.getCurrentUser();\n      // Normalize expected shape: your authService likely returns { success: true, data: user }\n      const user = (_response$data = response === null || response === void 0 ? void 0 : response.data) !== null && _response$data !== void 0 ? _response$data : response;\n      lastAuthCheck = {\n        data: user,\n        timestamp: Date.now()\n      };\n      return user;\n    } finally {\n      // Clear in-flight promise after resolution (success or failure)\n      authCheckPromise = null;\n    }\n  })();\n  return authCheckPromise;\n};\n\n/* -------------------------\r\n  AuthProvider (component)\r\n  ------------------------- */\n\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [sessionValid, setSessionValid] = useState(false);\n  const [sessionExpiresAt, setSessionExpiresAt] = useState(null);\n  const [authError, setAuthError] = useState(null);\n  const [authSuccess, setAuthSuccess] = useState(null);\n  const refreshTimeoutRef = useRef(null);\n  const sessionCheckIntervalRef = useRef(null);\n  const isRefreshingRef = useRef(false);\n  const refreshQueueRef = useRef([]);\n\n  /* Security logger */\n  const logSecurityEvent = useCallback((eventType, data = {}) => {\n    const securityEvent = {\n      timestamp: new Date().toISOString(),\n      event: eventType,\n      userId: user === null || user === void 0 ? void 0 : user._id,\n      userRole: user === null || user === void 0 ? void 0 : user.role,\n      ...data,\n      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'server',\n      ip: 'client-ip'\n    };\n    if (process.env.NODE_ENV === 'development') {\n      console.log('ðŸ”’ Security Event:', securityEvent);\n    }\n    sendToSecurityLog(securityEvent);\n  }, [user]);\n  const clearError = useCallback(() => setAuthError(null), []);\n  const clearSuccess = useCallback(() => setAuthSuccess(null), []);\n  const setError = useCallback(message => {\n    setAuthError(message);\n    setTimeout(() => setAuthError(null), 10000);\n  }, []);\n  const setSuccess = useCallback(message => {\n    setAuthSuccess(message);\n    setTimeout(() => setAuthSuccess(null), 5000);\n  }, []);\n\n  /* Refresh token queueing (unchanged logic, but retained) */\n  const refreshToken = useCallback(async () => {\n    if (isRefreshingRef.current) {\n      return new Promise((resolve, reject) => {\n        refreshQueueRef.current.push({\n          resolve,\n          reject\n        });\n      });\n    }\n    try {\n      var _response$data2, _response$data3;\n      isRefreshingRef.current = true;\n      const response = await authService.refreshToken();\n      if (!response.success || !((_response$data2 = response.data) !== null && _response$data2 !== void 0 && _response$data2.accessToken) || !((_response$data3 = response.data) !== null && _response$data3 !== void 0 && _response$data3.user)) {\n        throw new Error('Invalid refresh response');\n      }\n      if (!validateUserData(response.data.user)) {\n        throw new Error('Invalid user data in refresh response');\n      }\n      const sanitizedUser = sanitizeUserData(response.data.user);\n      const accessToken = response.data.accessToken;\n      setUser(sanitizedUser);\n      setSessionValid(true);\n      const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\n      storage.setItem('token', accessToken);\n      storage.setItem('user', JSON.stringify(sanitizedUser));\n      api.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;\n      const expiryTime = Date.now() + 24 * 60 * 60 * 1000;\n      setSessionExpiresAt(expiryTime);\n      localStorage.setItem('sessionExpiry', expiryTime.toString());\n\n      // scheduleTokenRefresh will be called below after expiry set / or can be invoked here\n      scheduleTokenRefresh();\n      while (refreshQueueRef.current.length > 0) {\n        const queued = refreshQueueRef.current.shift();\n        queued.resolve();\n      }\n      return response;\n    } catch (error) {\n      console.error('Token refresh failed:', error);\n      while (refreshQueueRef.current.length > 0) {\n        const queued = refreshQueueRef.current.shift();\n        queued.reject(error);\n      }\n      throw error;\n    } finally {\n      isRefreshingRef.current = false;\n    }\n  }, []); // no deps\n\n  const scheduleTokenRefresh = useCallback(() => {\n    if (refreshTimeoutRef.current) {\n      clearTimeout(refreshTimeoutRef.current);\n      refreshTimeoutRef.current = null;\n    }\n    const refreshTime = sessionExpiresAt ? sessionExpiresAt - 5 * 60 * 1000 - Date.now() : 55 * 60 * 1000; // default 55 minutes\n    if (refreshTime > 0) {\n      refreshTimeoutRef.current = setTimeout(async () => {\n        try {\n          await refreshToken();\n        } catch (err) {\n          console.error('Scheduled token refresh failed:', err);\n        }\n      }, refreshTime);\n    }\n  }, [sessionExpiresAt, refreshToken]);\n  const startSessionMonitoring = useCallback(() => {\n    if (sessionCheckIntervalRef.current) {\n      clearInterval(sessionCheckIntervalRef.current);\n    }\n    sessionCheckIntervalRef.current = setInterval(() => {\n      if (sessionExpiresAt && Date.now() > sessionExpiresAt) {\n        console.warn('Session expired during monitoring');\n        logout('Session expired');\n      }\n    }, 60 * 1000);\n  }, [sessionExpiresAt]);\n  const logout = useCallback((reason = 'user_initiated') => {\n    setUser(null);\n    setSessionValid(false);\n    setSessionExpiresAt(null);\n    setAuthError(null);\n    setAuthSuccess(null);\n    if (refreshTimeoutRef.current) {\n      clearTimeout(refreshTimeoutRef.current);\n      refreshTimeoutRef.current = null;\n    }\n    if (sessionCheckIntervalRef.current) {\n      clearInterval(sessionCheckIntervalRef.current);\n      sessionCheckIntervalRef.current = null;\n    }\n    localStorage.removeItem('token');\n    localStorage.removeItem('user');\n    localStorage.removeItem('sessionExpiry');\n    localStorage.removeItem('rememberMe');\n    sessionStorage.removeItem('token');\n    sessionStorage.removeItem('user');\n    delete api.defaults.headers.common['Authorization'];\n    authService.logout().catch(err => console.error('Backend logout failed:', err));\n    logSecurityEvent('logout', {\n      reason\n    });\n    refreshQueueRef.current = [];\n    console.log('ðŸ‘‹ User logged out:', reason);\n  }, [logSecurityEvent]);\n\n  /* -------------------------\r\n     Login / Register logic (mostly same)\r\n     ------------------------- */\n\n  const login = useCallback(async (email, password, rememberMe = false) => {\n    try {\n      var _response$data4, _response$data5;\n      setAuthError(null);\n      setAuthSuccess(null);\n      setLoading(true);\n      const response = await authService.login(email, password, rememberMe);\n      if (!response.success) throw new Error(response.message || 'Login failed');\n      if (!((_response$data4 = response.data) !== null && _response$data4 !== void 0 && _response$data4.user) || !((_response$data5 = response.data) !== null && _response$data5 !== void 0 && _response$data5.accessToken)) throw new Error('Invalid login response format');\n      if (!validateUserData(response.data.user)) throw new Error('Invalid user data received from server');\n      const sanitizedUser = sanitizeUserData(response.data.user);\n      const accessToken = response.data.accessToken;\n      setUser(sanitizedUser);\n      setSessionValid(true);\n      const expiryTime = Date.now() + 24 * 60 * 60 * 1000;\n      setSessionExpiresAt(expiryTime);\n      const storage = rememberMe ? localStorage : sessionStorage;\n      storage.setItem('token', accessToken);\n      storage.setItem('user', JSON.stringify(sanitizedUser));\n      if (rememberMe) {\n        localStorage.setItem('sessionExpiry', expiryTime.toString());\n        localStorage.setItem('rememberMe', 'true');\n      }\n      api.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;\n      scheduleTokenRefresh();\n      startSessionMonitoring();\n      logSecurityEvent('login_success', {\n        email,\n        role: sanitizedUser.role\n      });\n      return response;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error('âŒ Login error:', error);\n      logSecurityEvent('login_failed', {\n        email,\n        error: error.message\n      });\n      const errorMessage = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.message || 'Login failed. Please check your credentials.';\n      setError(errorMessage);\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  }, [scheduleTokenRefresh, startSessionMonitoring, setError, logSecurityEvent]);\n  const register = useCallback(async userData => {\n    try {\n      var _response$data6, _response$data7, _response$data8;\n      setAuthError(null);\n      setAuthSuccess(null);\n      setLoading(true);\n      const response = await authService.register(userData);\n      if (!response.success) throw new Error(response.message || 'Registration failed');\n      const requiresVerification = ((_response$data6 = response.data) === null || _response$data6 === void 0 ? void 0 : _response$data6.requiresEmailVerification) || false;\n      if (requiresVerification) {\n        setSuccess('Registration successful! Please check your email to verify your account.');\n        logSecurityEvent('registration_pending_verification', {\n          email: userData.email,\n          role: userData.role\n        });\n        return {\n          ...response,\n          requiresVerification: true,\n          message: 'Registration successful! Please check your email to verify your account.'\n        };\n      }\n      if (!((_response$data7 = response.data) !== null && _response$data7 !== void 0 && _response$data7.user) || !((_response$data8 = response.data) !== null && _response$data8 !== void 0 && _response$data8.accessToken)) throw new Error('Invalid registration response format');\n      if (!validateUserData(response.data.user)) throw new Error('Invalid user data received from server');\n      const sanitizedUser = sanitizeUserData(response.data.user);\n      const accessToken = response.data.accessToken;\n      setUser(sanitizedUser);\n      setSessionValid(true);\n      const expiryTime = Date.now() + 24 * 60 * 60 * 1000;\n      setSessionExpiresAt(expiryTime);\n      localStorage.setItem('token', accessToken);\n      localStorage.setItem('user', JSON.stringify(sanitizedUser));\n      localStorage.setItem('sessionExpiry', expiryTime.toString());\n      api.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;\n      scheduleTokenRefresh();\n      startSessionMonitoring();\n      logSecurityEvent('registration_success', {\n        email: sanitizedUser.email,\n        role: sanitizedUser.role\n      });\n      return {\n        ...response,\n        requiresVerification: false,\n        message: 'Registration successful! You are now logged in.'\n      };\n    } catch (error) {\n      var _error$response2, _error$response2$data, _error$response3, _error$response3$data;\n      console.error('âŒ Registration error:', error);\n      logSecurityEvent('registration_failed', {\n        email: userData.email,\n        error: error.message,\n        role: userData.role\n      });\n      let errorMessage = 'Registration failed. Please try again.';\n      if (error.message && error.message !== errorMessage) errorMessage = error.message;else if ((_error$response2 = error.response) !== null && _error$response2 !== void 0 && (_error$response2$data = _error$response2.data) !== null && _error$response2$data !== void 0 && _error$response2$data.message) errorMessage = error.response.data.message;else if ((_error$response3 = error.response) !== null && _error$response3 !== void 0 && (_error$response3$data = _error$response3.data) !== null && _error$response3$data !== void 0 && _error$response3$data.errors) {\n        const validationErrors = error.response.data.errors;\n        if (Array.isArray(validationErrors)) errorMessage = validationErrors.map(err => err.message || err.msg).join('. ');else if (typeof validationErrors === 'object') errorMessage = Object.values(validationErrors).join('. ');\n      }\n      setError(errorMessage);\n      throw new Error(errorMessage);\n    } finally {\n      setLoading(false);\n    }\n  }, [scheduleTokenRefresh, startSessionMonitoring, setError, setSuccess, logSecurityEvent]);\n\n  /* -------------------------\r\n     initializeAuth - guarded with authInitPromise so we don't run it multiple times\r\n     ------------------------- */\n\n  const initializeAuth = useCallback(async () => {\n    // If an initialization is already running or done, return that promise\n    if (authInitPromise) return authInitPromise;\n    authInitPromise = (async () => {\n      try {\n        setLoading(true);\n        setAuthError(null);\n        setAuthSuccess(null);\n        const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n        const savedUser = localStorage.getItem('user') || sessionStorage.getItem('user');\n        const sessionExpiry = localStorage.getItem('sessionExpiry');\n        if (!token || !savedUser) {\n          setLoading(false);\n          return;\n        }\n        let parsedUser;\n        try {\n          parsedUser = JSON.parse(savedUser);\n        } catch (err) {\n          console.error('Error parsing saved user:', err);\n          logout('Invalid session data');\n          return;\n        }\n        if (!validateUserData(parsedUser)) {\n          console.warn('Invalid user data in storage, logging out');\n          logout('Invalid user data');\n          return;\n        }\n        if (sessionExpiry) {\n          const expiryTime = parseInt(sessionExpiry, 10);\n          if (Date.now() > expiryTime) {\n            console.warn('Session expired, logging out');\n            logout('Session expired');\n            return;\n          }\n          setSessionExpiresAt(expiryTime);\n        }\n        api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n\n        // Use cached/deduped current user call\n        try {\n          const userData = await getCurrentUserCached();\n          if (!validateUserData(userData)) throw new Error('Invalid user data received from server');\n          const sanitizedUser = sanitizeUserData(userData);\n          setUser(sanitizedUser);\n          setSessionValid(true);\n          const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\n          storage.setItem('user', JSON.stringify(sanitizedUser));\n          scheduleTokenRefresh();\n          startSessionMonitoring();\n          console.log('âœ… Auth initialized successfully:', sanitizedUser.email);\n        } catch (error) {\n          console.error('Token verification failed:', error);\n          try {\n            await refreshToken();\n          } catch (refreshError) {\n            console.error('Token refresh failed:', refreshError);\n            logout('Session verification failed');\n          }\n        }\n      } catch (error) {\n        console.error('Auth initialization error:', error);\n        setError('Authentication initialization failed');\n      } finally {\n        setLoading(false);\n      }\n    })();\n    return authInitPromise;\n  }, [logout, refreshToken, scheduleTokenRefresh, startSessionMonitoring, setError]);\n\n  /* -------------------------\r\n     Other helpers using getCurrentUserCached where appropriate\r\n     ------------------------- */\n\n  const hasRole = useCallback(roles => {\n    if (!user || !user.role) return false;\n    const rolesToCheck = Array.isArray(roles) ? roles : [roles];\n    return rolesToCheck.includes(user.role);\n  }, [user]);\n  const hasPermission = useCallback(permissions => {\n    if (!user || !user.permissions) return false;\n    const permissionsToCheck = Array.isArray(permissions) ? permissions : [permissions];\n    return permissionsToCheck.every(permission => {\n      var _user$permissions;\n      return (_user$permissions = user.permissions) === null || _user$permissions === void 0 ? void 0 : _user$permissions.includes(permission);\n    });\n  }, [user]);\n  const checkSession = useCallback(async () => {\n    // Use cached call so quick repeated checks don't hit server\n    try {\n      const userData = await getCurrentUserCached();\n      return !!userData;\n    } catch (err) {\n      return false;\n    }\n  }, []);\n  const updateProfile = useCallback(async updates => {\n    try {\n      var _response$data9;\n      const response = await authService.updateProfile(updates);\n      if (response.success && (_response$data9 = response.data) !== null && _response$data9 !== void 0 && _response$data9.user) {\n        const sanitizedUser = sanitizeUserData(response.data.user);\n        setUser(sanitizedUser);\n        const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\n        storage.setItem('user', JSON.stringify(sanitizedUser));\n      }\n      return response;\n    } catch (error) {\n      console.error('Profile update error:', error);\n      throw error;\n    }\n  }, []);\n  const changePassword = useCallback(async (currentPassword, newPassword) => {\n    try {\n      const response = await authService.changePassword(currentPassword, newPassword);\n      if (response.success) logSecurityEvent('password_changed');\n      return response;\n    } catch (error) {\n      console.error('Password change error:', error);\n      throw error;\n    }\n  }, [logSecurityEvent]);\n  const forgotPassword = useCallback(async email => {\n    try {\n      return await authService.forgotPassword(email);\n    } catch (error) {\n      console.error('Forgot password error:', error);\n      throw error;\n    }\n  }, []);\n  const resetPassword = useCallback(async (token, userId, newPassword) => {\n    try {\n      return await authService.resetPassword(token, userId, newPassword);\n    } catch (error) {\n      console.error('Reset password error:', error);\n      throw error;\n    }\n  }, []);\n  const verifyEmail = useCallback(async (token, userId) => {\n    try {\n      return await authService.verifyEmail(token, userId);\n    } catch (error) {\n      console.error('Email verification error:', error);\n      throw error;\n    }\n  }, []);\n  const checkEmail = useCallback(async email => {\n    try {\n      return await authService.checkEmail(email);\n    } catch (error) {\n      console.error('Check email error:', error);\n      throw error;\n    }\n  }, []);\n  const checkUsername = useCallback(async username => {\n    try {\n      return await authService.checkUsername(username);\n    } catch (error) {\n      console.error('Check username error:', error);\n      throw error;\n    }\n  }, []);\n\n  /* -------------------------\r\n     Effects\r\n     - initialization (runs once per app start due to authInitPromise)\r\n     - axios interceptor for refresh (unchanged)\r\n     ------------------------- */\n\n  useEffect(() => {\n    initializeAuth();\n    return () => {\n      if (refreshTimeoutRef.current) {\n        clearTimeout(refreshTimeoutRef.current);\n      }\n      if (sessionCheckIntervalRef.current) {\n        clearInterval(sessionCheckIntervalRef.current);\n      }\n    };\n  }, [initializeAuth]);\n  useEffect(() => {\n    const interceptor = api.interceptors.response.use(response => response, async error => {\n      var _error$response4;\n      const originalRequest = error.config;\n      if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 401 && !originalRequest._retry) {\n        originalRequest._retry = true;\n        try {\n          await refreshToken();\n          const token = localStorage.getItem('token') || sessionStorage.getItem('token');\n          if (token) originalRequest.headers.Authorization = `Bearer ${token}`;\n          return api(originalRequest);\n        } catch (refreshError) {\n          logout('token_refresh_failed');\n          return Promise.reject(refreshError);\n        }\n      }\n      return Promise.reject(error);\n    });\n    return () => api.interceptors.response.eject(interceptor);\n  }, [refreshToken, logout]);\n\n  /* -------------------------\r\n     Context value & render\r\n     ------------------------- */\n\n  const value = {\n    user,\n    loading,\n    sessionValid,\n    sessionExpiresAt,\n    authError,\n    authSuccess,\n    login,\n    register,\n    logout,\n    refreshToken,\n    checkSession,\n    updateProfile,\n    changePassword,\n    forgotPassword,\n    resetPassword,\n    verifyEmail,\n    checkEmail,\n    checkUsername,\n    hasRole,\n    hasPermission,\n    logSecurityEvent,\n    isAuthenticated: !!user && sessionValid,\n    clearError,\n    clearSuccess,\n    setError,\n    setSuccess\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 653,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"pglvAvtLFXK8VrLu/EmqfKBGpqE=\");\n_c = AuthProvider;\nAuthProvider.propTypes = {\n  children: PropTypes.node.isRequired\n};\nexport default AuthContext;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useCallback","useRef","PropTypes","authService","api","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","context","Error","validateUserData","userData","requiredFields","field","console","warn","validRoles","includes","role","emailRegex","test","email","sanitizeUserData","sanitized","password","tempPassword","resetToken","verificationToken","__v","toLowerCase","sendToSecurityLog","eventData","existingEvents","JSON","parse","localStorage","getItem","push","length","shift","setItem","stringify","e","authCheckPromise","lastAuthCheck","AUTH_CACHE_TIME","authInitPromise","getCurrentUserCached","now","Date","timestamp","data","trace","_response$data","response","getCurrentUser","user","AuthProvider","children","_s2","setUser","loading","setLoading","sessionValid","setSessionValid","sessionExpiresAt","setSessionExpiresAt","authError","setAuthError","authSuccess","setAuthSuccess","refreshTimeoutRef","sessionCheckIntervalRef","isRefreshingRef","refreshQueueRef","logSecurityEvent","eventType","securityEvent","toISOString","event","userId","_id","userRole","userAgent","navigator","ip","process","env","NODE_ENV","log","clearError","clearSuccess","setError","message","setTimeout","setSuccess","refreshToken","current","Promise","resolve","reject","_response$data2","_response$data3","success","accessToken","sanitizedUser","storage","sessionStorage","defaults","headers","common","expiryTime","toString","scheduleTokenRefresh","queued","error","clearTimeout","refreshTime","err","startSessionMonitoring","clearInterval","setInterval","logout","reason","removeItem","catch","login","rememberMe","_response$data4","_response$data5","_error$response","_error$response$data","errorMessage","register","_response$data6","_response$data7","_response$data8","requiresVerification","requiresEmailVerification","_error$response2","_error$response2$data","_error$response3","_error$response3$data","errors","validationErrors","Array","isArray","map","msg","join","Object","values","initializeAuth","token","savedUser","sessionExpiry","parsedUser","parseInt","refreshError","hasRole","roles","rolesToCheck","hasPermission","permissions","permissionsToCheck","every","permission","_user$permissions","checkSession","updateProfile","updates","_response$data9","changePassword","currentPassword","newPassword","forgotPassword","resetPassword","verifyEmail","checkEmail","checkUsername","username","interceptor","interceptors","use","_error$response4","originalRequest","config","status","_retry","Authorization","eject","value","isAuthenticated","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","propTypes","node","isRequired","$RefreshReg$"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/context/AuthContext.js"],"sourcesContent":["import React, { createContext, useState, useContext, useEffect, useCallback, useRef } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport authService from '../services/authService';\r\nimport api from '../services/api';\r\n\r\n/**\r\n * AuthContext - Optimized to avoid repeated /auth/me calls\r\n */\r\n\r\nexport const AuthContext = createContext();\r\n\r\nexport const useAuth = () => {\r\n  const context = useContext(AuthContext);\r\n  if (!context) {\r\n    throw new Error('useAuth must be used within an AuthProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n/* -------------------------\r\n  Helpers: Validation + Sanitization\r\n   (unchanged from your original)\r\n   ------------------------- */\r\n\r\nconst validateUserData = (userData) => {\r\n  if (!userData || typeof userData !== 'object') {\r\n    return false;\r\n  }\r\n  const requiredFields = ['_id', 'email', 'role'];\r\n  for (const field of requiredFields) {\r\n    if (!userData[field]) {\r\n      console.warn(`Invalid user data: Missing ${field}`);\r\n      return false;\r\n    }\r\n  }\r\n  const validRoles = ['admin', 'technician', 'staff', 'student'];\r\n  if (!validRoles.includes(userData.role)) {\r\n    console.warn(`Invalid user data: Invalid role \"${userData.role}\"`);\r\n    return false;\r\n  }\r\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  if (!emailRegex.test(userData.email)) {\r\n    console.warn(`Invalid user data: Invalid email \"${userData.email}\"`);\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\nconst sanitizeUserData = (userData) => {\r\n  if (!userData) return null;\r\n  const sanitized = { ...userData };\r\n  delete sanitized.password;\r\n  delete sanitized.tempPassword;\r\n  delete sanitized.resetToken;\r\n  delete sanitized.verificationToken;\r\n  delete sanitized.__v;\r\n  if (sanitized.role) sanitized.role = sanitized.role.toLowerCase();\r\n  return sanitized;\r\n};\r\n\r\nconst sendToSecurityLog = (eventData) => {\r\n  try {\r\n    const existingEvents = JSON.parse(localStorage.getItem('security_events') || '[]');\r\n    existingEvents.push(eventData);\r\n    if (existingEvents.length > 50) existingEvents.shift();\r\n    localStorage.setItem('security_events', JSON.stringify(existingEvents));\r\n  } catch (e) {\r\n    // ignore\r\n  }\r\n};\r\n\r\n/* -------------------------\r\n  Caching / Deduplication Globals\r\n  - Keeps things at module scope so multiple mounts share cache\r\n  ------------------------- */\r\n\r\nlet authCheckPromise = null;      // in-flight GET /auth/me promise\r\nlet lastAuthCheck = null;         // { data, timestamp }\r\nconst AUTH_CACHE_TIME = 5000;     // 5 seconds cache\r\n\r\nlet authInitPromise = null;       // protects initializeAuth from running multiple times\r\n\r\n/* Cached GET current user:\r\n   - returns cached data if recent\r\n   - dedupes in-flight requests\r\n   - console.trace() on new network calls to help debugging\r\n*/\r\nconst getCurrentUserCached = async () => {\r\n  const now = Date.now();\r\n\r\n  // Return cached result if still fresh\r\n  if (lastAuthCheck && (now - lastAuthCheck.timestamp) < AUTH_CACHE_TIME) {\r\n    return lastAuthCheck.data;\r\n  }\r\n\r\n  // If an in-flight promise exists, reuse it\r\n  if (authCheckPromise) {\r\n    return authCheckPromise;\r\n  }\r\n\r\n  // Make new request and store the promise\r\n  authCheckPromise = (async () => {\r\n    // Helpful trace to find callers (only when we truly call the network)\r\n    try {\r\n      console.trace('ðŸ” getCurrentUserCached network call stack:');\r\n    } catch (e) {}\r\n\r\n    try {\r\n      const response = await authService.getCurrentUser();\r\n      // Normalize expected shape: your authService likely returns { success: true, data: user }\r\n      const user = response?.data ?? response;\r\n      lastAuthCheck = { data: user, timestamp: Date.now() };\r\n      return user;\r\n    } finally {\r\n      // Clear in-flight promise after resolution (success or failure)\r\n      authCheckPromise = null;\r\n    }\r\n  })();\r\n\r\n  return authCheckPromise;\r\n};\r\n\r\n/* -------------------------\r\n  AuthProvider (component)\r\n  ------------------------- */\r\n\r\nexport const AuthProvider = ({ children }) => {\r\n  const [user, setUser] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [sessionValid, setSessionValid] = useState(false);\r\n  const [sessionExpiresAt, setSessionExpiresAt] = useState(null);\r\n  const [authError, setAuthError] = useState(null);\r\n  const [authSuccess, setAuthSuccess] = useState(null);\r\n\r\n  const refreshTimeoutRef = useRef(null);\r\n  const sessionCheckIntervalRef = useRef(null);\r\n  const isRefreshingRef = useRef(false);\r\n  const refreshQueueRef = useRef([]);\r\n\r\n  /* Security logger */\r\n  const logSecurityEvent = useCallback((eventType, data = {}) => {\r\n    const securityEvent = {\r\n      timestamp: new Date().toISOString(),\r\n      event: eventType,\r\n      userId: user?._id,\r\n      userRole: user?.role,\r\n      ...data,\r\n      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'server',\r\n      ip: 'client-ip'\r\n    };\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log('ðŸ”’ Security Event:', securityEvent);\r\n    }\r\n    sendToSecurityLog(securityEvent);\r\n  }, [user]);\r\n\r\n  const clearError = useCallback(() => setAuthError(null), []);\r\n  const clearSuccess = useCallback(() => setAuthSuccess(null), []);\r\n  const setError = useCallback((message) => {\r\n    setAuthError(message);\r\n    setTimeout(() => setAuthError(null), 10000);\r\n  }, []);\r\n  const setSuccess = useCallback((message) => {\r\n    setAuthSuccess(message);\r\n    setTimeout(() => setAuthSuccess(null), 5000);\r\n  }, []);\r\n\r\n  /* Refresh token queueing (unchanged logic, but retained) */\r\n  const refreshToken = useCallback(async () => {\r\n    if (isRefreshingRef.current) {\r\n      return new Promise((resolve, reject) => {\r\n        refreshQueueRef.current.push({ resolve, reject });\r\n      });\r\n    }\r\n\r\n    try {\r\n      isRefreshingRef.current = true;\r\n      const response = await authService.refreshToken();\r\n      if (!response.success || !response.data?.accessToken || !response.data?.user) {\r\n        throw new Error('Invalid refresh response');\r\n      }\r\n\r\n      if (!validateUserData(response.data.user)) {\r\n        throw new Error('Invalid user data in refresh response');\r\n      }\r\n\r\n      const sanitizedUser = sanitizeUserData(response.data.user);\r\n      const accessToken = response.data.accessToken;\r\n\r\n      setUser(sanitizedUser);\r\n      setSessionValid(true);\r\n\r\n      const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\r\n      storage.setItem('token', accessToken);\r\n      storage.setItem('user', JSON.stringify(sanitizedUser));\r\n\r\n      api.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;\r\n\r\n      const expiryTime = Date.now() + (24 * 60 * 60 * 1000);\r\n      setSessionExpiresAt(expiryTime);\r\n      localStorage.setItem('sessionExpiry', expiryTime.toString());\r\n\r\n      // scheduleTokenRefresh will be called below after expiry set / or can be invoked here\r\n      scheduleTokenRefresh();\r\n\r\n      while (refreshQueueRef.current.length > 0) {\r\n        const queued = refreshQueueRef.current.shift();\r\n        queued.resolve();\r\n      }\r\n\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Token refresh failed:', error);\r\n      while (refreshQueueRef.current.length > 0) {\r\n        const queued = refreshQueueRef.current.shift();\r\n        queued.reject(error);\r\n      }\r\n      throw error;\r\n    } finally {\r\n      isRefreshingRef.current = false;\r\n    }\r\n  }, []); // no deps\r\n\r\n  const scheduleTokenRefresh = useCallback(() => {\r\n    if (refreshTimeoutRef.current) {\r\n      clearTimeout(refreshTimeoutRef.current);\r\n      refreshTimeoutRef.current = null;\r\n    }\r\n    const refreshTime = sessionExpiresAt\r\n      ? sessionExpiresAt - (5 * 60 * 1000) - Date.now()\r\n      : 55 * 60 * 1000; // default 55 minutes\r\n    if (refreshTime > 0) {\r\n      refreshTimeoutRef.current = setTimeout(async () => {\r\n        try {\r\n          await refreshToken();\r\n        } catch (err) {\r\n          console.error('Scheduled token refresh failed:', err);\r\n        }\r\n      }, refreshTime);\r\n    }\r\n  }, [sessionExpiresAt, refreshToken]);\r\n\r\n  const startSessionMonitoring = useCallback(() => {\r\n    if (sessionCheckIntervalRef.current) {\r\n      clearInterval(sessionCheckIntervalRef.current);\r\n    }\r\n    sessionCheckIntervalRef.current = setInterval(() => {\r\n      if (sessionExpiresAt && Date.now() > sessionExpiresAt) {\r\n        console.warn('Session expired during monitoring');\r\n        logout('Session expired');\r\n      }\r\n    }, 60 * 1000);\r\n  }, [sessionExpiresAt]);\r\n\r\n  const logout = useCallback((reason = 'user_initiated') => {\r\n    setUser(null);\r\n    setSessionValid(false);\r\n    setSessionExpiresAt(null);\r\n    setAuthError(null);\r\n    setAuthSuccess(null);\r\n\r\n    if (refreshTimeoutRef.current) {\r\n      clearTimeout(refreshTimeoutRef.current);\r\n      refreshTimeoutRef.current = null;\r\n    }\r\n    if (sessionCheckIntervalRef.current) {\r\n      clearInterval(sessionCheckIntervalRef.current);\r\n      sessionCheckIntervalRef.current = null;\r\n    }\r\n\r\n    localStorage.removeItem('token');\r\n    localStorage.removeItem('user');\r\n    localStorage.removeItem('sessionExpiry');\r\n    localStorage.removeItem('rememberMe');\r\n    sessionStorage.removeItem('token');\r\n    sessionStorage.removeItem('user');\r\n\r\n    delete api.defaults.headers.common['Authorization'];\r\n\r\n    authService.logout().catch(err => console.error('Backend logout failed:', err));\r\n    logSecurityEvent('logout', { reason });\r\n\r\n    refreshQueueRef.current = [];\r\n    console.log('ðŸ‘‹ User logged out:', reason);\r\n  }, [logSecurityEvent]);\r\n\r\n  /* -------------------------\r\n     Login / Register logic (mostly same)\r\n     ------------------------- */\r\n\r\n  const login = useCallback(async (email, password, rememberMe = false) => {\r\n    try {\r\n      setAuthError(null);\r\n      setAuthSuccess(null);\r\n      setLoading(true);\r\n\r\n      const response = await authService.login(email, password, rememberMe);\r\n      if (!response.success) throw new Error(response.message || 'Login failed');\r\n      if (!response.data?.user || !response.data?.accessToken) throw new Error('Invalid login response format');\r\n      if (!validateUserData(response.data.user)) throw new Error('Invalid user data received from server');\r\n\r\n      const sanitizedUser = sanitizeUserData(response.data.user);\r\n      const accessToken = response.data.accessToken;\r\n\r\n      setUser(sanitizedUser);\r\n      setSessionValid(true);\r\n\r\n      const expiryTime = Date.now() + (24 * 60 * 60 * 1000);\r\n      setSessionExpiresAt(expiryTime);\r\n\r\n      const storage = rememberMe ? localStorage : sessionStorage;\r\n      storage.setItem('token', accessToken);\r\n      storage.setItem('user', JSON.stringify(sanitizedUser));\r\n      if (rememberMe) {\r\n        localStorage.setItem('sessionExpiry', expiryTime.toString());\r\n        localStorage.setItem('rememberMe', 'true');\r\n      }\r\n\r\n      api.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;\r\n\r\n      scheduleTokenRefresh();\r\n      startSessionMonitoring();\r\n      logSecurityEvent('login_success', { email, role: sanitizedUser.role });\r\n\r\n      return response;\r\n    } catch (error) {\r\n      console.error('âŒ Login error:', error);\r\n      logSecurityEvent('login_failed', { email, error: error.message });\r\n      const errorMessage = error.response?.data?.message || error.message || 'Login failed. Please check your credentials.';\r\n      setError(errorMessage);\r\n      throw error;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [scheduleTokenRefresh, startSessionMonitoring, setError, logSecurityEvent]);\r\n\r\n  const register = useCallback(async (userData) => {\r\n    try {\r\n      setAuthError(null);\r\n      setAuthSuccess(null);\r\n      setLoading(true);\r\n\r\n      const response = await authService.register(userData);\r\n      if (!response.success) throw new Error(response.message || 'Registration failed');\r\n\r\n      const requiresVerification = response.data?.requiresEmailVerification || false;\r\n      if (requiresVerification) {\r\n        setSuccess('Registration successful! Please check your email to verify your account.');\r\n        logSecurityEvent('registration_pending_verification', { email: userData.email, role: userData.role });\r\n        return { ...response, requiresVerification: true, message: 'Registration successful! Please check your email to verify your account.' };\r\n      }\r\n\r\n      if (!response.data?.user || !response.data?.accessToken) throw new Error('Invalid registration response format');\r\n      if (!validateUserData(response.data.user)) throw new Error('Invalid user data received from server');\r\n\r\n      const sanitizedUser = sanitizeUserData(response.data.user);\r\n      const accessToken = response.data.accessToken;\r\n\r\n      setUser(sanitizedUser);\r\n      setSessionValid(true);\r\n      const expiryTime = Date.now() + (24 * 60 * 60 * 1000);\r\n      setSessionExpiresAt(expiryTime);\r\n\r\n      localStorage.setItem('token', accessToken);\r\n      localStorage.setItem('user', JSON.stringify(sanitizedUser));\r\n      localStorage.setItem('sessionExpiry', expiryTime.toString());\r\n\r\n      api.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;\r\n\r\n      scheduleTokenRefresh();\r\n      startSessionMonitoring();\r\n      logSecurityEvent('registration_success', { email: sanitizedUser.email, role: sanitizedUser.role });\r\n\r\n      return { ...response, requiresVerification: false, message: 'Registration successful! You are now logged in.' };\r\n    } catch (error) {\r\n      console.error('âŒ Registration error:', error);\r\n      logSecurityEvent('registration_failed', { email: userData.email, error: error.message, role: userData.role });\r\n      let errorMessage = 'Registration failed. Please try again.';\r\n      if (error.message && error.message !== errorMessage) errorMessage = error.message;\r\n      else if (error.response?.data?.message) errorMessage = error.response.data.message;\r\n      else if (error.response?.data?.errors) {\r\n        const validationErrors = error.response.data.errors;\r\n        if (Array.isArray(validationErrors)) errorMessage = validationErrors.map(err => err.message || err.msg).join('. ');\r\n        else if (typeof validationErrors === 'object') errorMessage = Object.values(validationErrors).join('. ');\r\n      }\r\n      setError(errorMessage);\r\n      throw new Error(errorMessage);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [scheduleTokenRefresh, startSessionMonitoring, setError, setSuccess, logSecurityEvent]);\r\n\r\n  /* -------------------------\r\n     initializeAuth - guarded with authInitPromise so we don't run it multiple times\r\n     ------------------------- */\r\n\r\n  const initializeAuth = useCallback(async () => {\r\n    // If an initialization is already running or done, return that promise\r\n    if (authInitPromise) return authInitPromise;\r\n\r\n    authInitPromise = (async () => {\r\n      try {\r\n        setLoading(true);\r\n        setAuthError(null);\r\n        setAuthSuccess(null);\r\n\r\n        const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n        const savedUser = localStorage.getItem('user') || sessionStorage.getItem('user');\r\n        const sessionExpiry = localStorage.getItem('sessionExpiry');\r\n\r\n        if (!token || !savedUser) {\r\n          setLoading(false);\r\n          return;\r\n        }\r\n\r\n        let parsedUser;\r\n        try {\r\n          parsedUser = JSON.parse(savedUser);\r\n        } catch (err) {\r\n          console.error('Error parsing saved user:', err);\r\n          logout('Invalid session data');\r\n          return;\r\n        }\r\n\r\n        if (!validateUserData(parsedUser)) {\r\n          console.warn('Invalid user data in storage, logging out');\r\n          logout('Invalid user data');\r\n          return;\r\n        }\r\n\r\n        if (sessionExpiry) {\r\n          const expiryTime = parseInt(sessionExpiry, 10);\r\n          if (Date.now() > expiryTime) {\r\n            console.warn('Session expired, logging out');\r\n            logout('Session expired');\r\n            return;\r\n          }\r\n          setSessionExpiresAt(expiryTime);\r\n        }\r\n\r\n        api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\r\n\r\n        // Use cached/deduped current user call\r\n        try {\r\n          const userData = await getCurrentUserCached();\r\n          if (!validateUserData(userData)) throw new Error('Invalid user data received from server');\r\n\r\n          const sanitizedUser = sanitizeUserData(userData);\r\n          setUser(sanitizedUser);\r\n          setSessionValid(true);\r\n\r\n          const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\r\n          storage.setItem('user', JSON.stringify(sanitizedUser));\r\n\r\n          scheduleTokenRefresh();\r\n          startSessionMonitoring();\r\n\r\n          console.log('âœ… Auth initialized successfully:', sanitizedUser.email);\r\n        } catch (error) {\r\n          console.error('Token verification failed:', error);\r\n          try {\r\n            await refreshToken();\r\n          } catch (refreshError) {\r\n            console.error('Token refresh failed:', refreshError);\r\n            logout('Session verification failed');\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Auth initialization error:', error);\r\n        setError('Authentication initialization failed');\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    })();\r\n\r\n    return authInitPromise;\r\n  }, [logout, refreshToken, scheduleTokenRefresh, startSessionMonitoring, setError]);\r\n\r\n  /* -------------------------\r\n     Other helpers using getCurrentUserCached where appropriate\r\n     ------------------------- */\r\n\r\n  const hasRole = useCallback((roles) => {\r\n    if (!user || !user.role) return false;\r\n    const rolesToCheck = Array.isArray(roles) ? roles : [roles];\r\n    return rolesToCheck.includes(user.role);\r\n  }, [user]);\r\n\r\n  const hasPermission = useCallback((permissions) => {\r\n    if (!user || !user.permissions) return false;\r\n    const permissionsToCheck = Array.isArray(permissions) ? permissions : [permissions];\r\n    return permissionsToCheck.every(permission => user.permissions?.includes(permission));\r\n  }, [user]);\r\n\r\n  const checkSession = useCallback(async () => {\r\n    // Use cached call so quick repeated checks don't hit server\r\n    try {\r\n      const userData = await getCurrentUserCached();\r\n      return !!userData;\r\n    } catch (err) {\r\n      return false;\r\n    }\r\n  }, []);\r\n\r\n  const updateProfile = useCallback(async (updates) => {\r\n    try {\r\n      const response = await authService.updateProfile(updates);\r\n      if (response.success && response.data?.user) {\r\n        const sanitizedUser = sanitizeUserData(response.data.user);\r\n        setUser(sanitizedUser);\r\n        const storage = localStorage.getItem('token') ? localStorage : sessionStorage;\r\n        storage.setItem('user', JSON.stringify(sanitizedUser));\r\n      }\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Profile update error:', error);\r\n      throw error;\r\n    }\r\n  }, []);\r\n\r\n  const changePassword = useCallback(async (currentPassword, newPassword) => {\r\n    try {\r\n      const response = await authService.changePassword(currentPassword, newPassword);\r\n      if (response.success) logSecurityEvent('password_changed');\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Password change error:', error);\r\n      throw error;\r\n    }\r\n  }, [logSecurityEvent]);\r\n\r\n  const forgotPassword = useCallback(async (email) => {\r\n    try {\r\n      return await authService.forgotPassword(email);\r\n    } catch (error) {\r\n      console.error('Forgot password error:', error);\r\n      throw error;\r\n    }\r\n  }, []);\r\n\r\n  const resetPassword = useCallback(async (token, userId, newPassword) => {\r\n    try {\r\n      return await authService.resetPassword(token, userId, newPassword);\r\n    } catch (error) {\r\n      console.error('Reset password error:', error);\r\n      throw error;\r\n    }\r\n  }, []);\r\n\r\n  const verifyEmail = useCallback(async (token, userId) => {\r\n    try {\r\n      return await authService.verifyEmail(token, userId);\r\n    } catch (error) {\r\n      console.error('Email verification error:', error);\r\n      throw error;\r\n    }\r\n  }, []);\r\n\r\n  const checkEmail = useCallback(async (email) => {\r\n    try {\r\n      return await authService.checkEmail(email);\r\n    } catch (error) {\r\n      console.error('Check email error:', error);\r\n      throw error;\r\n    }\r\n  }, []);\r\n\r\n  const checkUsername = useCallback(async (username) => {\r\n    try {\r\n      return await authService.checkUsername(username);\r\n    } catch (error) {\r\n      console.error('Check username error:', error);\r\n      throw error;\r\n    }\r\n  }, []);\r\n\r\n  /* -------------------------\r\n     Effects\r\n     - initialization (runs once per app start due to authInitPromise)\r\n     - axios interceptor for refresh (unchanged)\r\n     ------------------------- */\r\n\r\n  useEffect(() => {\r\n    initializeAuth();\r\n\r\n    return () => {\r\n      if (refreshTimeoutRef.current) {\r\n        clearTimeout(refreshTimeoutRef.current);\r\n      }\r\n      if (sessionCheckIntervalRef.current) {\r\n        clearInterval(sessionCheckIntervalRef.current);\r\n      }\r\n    };\r\n  }, [initializeAuth]);\r\n\r\n  useEffect(() => {\r\n    const interceptor = api.interceptors.response.use(\r\n      (response) => response,\r\n      async (error) => {\r\n        const originalRequest = error.config;\r\n        if (error.response?.status === 401 && !originalRequest._retry) {\r\n          originalRequest._retry = true;\r\n          try {\r\n            await refreshToken();\r\n            const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n            if (token) originalRequest.headers.Authorization = `Bearer ${token}`;\r\n            return api(originalRequest);\r\n          } catch (refreshError) {\r\n            logout('token_refresh_failed');\r\n            return Promise.reject(refreshError);\r\n          }\r\n        }\r\n        return Promise.reject(error);\r\n      }\r\n    );\r\n    return () => api.interceptors.response.eject(interceptor);\r\n  }, [refreshToken, logout]);\r\n\r\n  /* -------------------------\r\n     Context value & render\r\n     ------------------------- */\r\n\r\n  const value = {\r\n    user,\r\n    loading,\r\n    sessionValid,\r\n    sessionExpiresAt,\r\n    authError,\r\n    authSuccess,\r\n    login,\r\n    register,\r\n    logout,\r\n    refreshToken,\r\n    checkSession,\r\n    updateProfile,\r\n    changePassword,\r\n    forgotPassword,\r\n    resetPassword,\r\n    verifyEmail,\r\n    checkEmail,\r\n    checkUsername,\r\n    hasRole,\r\n    hasPermission,\r\n    logSecurityEvent,\r\n    isAuthenticated: !!user && sessionValid,\r\n    clearError,\r\n    clearSuccess,\r\n    setError,\r\n    setSuccess\r\n  };\r\n\r\n  return (\r\n    <AuthContext.Provider value={value}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n};\r\n\r\nAuthProvider.propTypes = {\r\n  children: PropTypes.node.isRequired\r\n};\r\n\r\nexport default AuthContext;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}