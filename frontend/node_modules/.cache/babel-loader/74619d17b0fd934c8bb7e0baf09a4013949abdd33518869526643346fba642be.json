{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\KADZ-TECH\\\\Documents\\\\dev\\\\it-support-system\\\\frontend\\\\src\\\\context\\\\AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// frontend/src/context/AuthContext.js - ENHANCED VERSION WITH LOG SECURITY EVENT\nimport React, { createContext, useState, useContext, useEffect, useCallback, useRef, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { authService } from '../services/authService';\n\n/**\r\n * Enterprise Auth Context v5.1.0\r\n * Features:\r\n * - Comprehensive state management\r\n * - Automatic token refresh\r\n * - Session monitoring\r\n * - Error boundary integration\r\n * - Performance optimization\r\n * - Memory leak prevention\r\n * - Role-based permissions\r\n * - Event logging with logSecurityEvent\r\n */\n\n// Context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const AuthContext = /*#__PURE__*/createContext();\n\n// Custom hook\nexport const useAuth = () => {\n  _s();\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n};\n\n// Error boundary for auth errors\n_s(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nclass AuthErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: null\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      hasError: true,\n      error\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error('Auth Error Boundary caught:', error, errorInfo);\n  }\n  render() {\n    if (this.state.hasError) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"auth-error-boundary\",\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          children: \"Authentication Error\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 50,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: \"Something went wrong with authentication. Please try refreshing the page.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 51,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => window.location.reload(),\n          children: \"Refresh Page\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 52,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 49,\n        columnNumber: 9\n      }, this);\n    }\n    return this.props.children;\n  }\n}\n\n// Performance monitoring\nconst createPerformanceMonitor = () => {\n  const metrics = {\n    loginTime: null,\n    refreshTime: null,\n    sessionChecks: 0,\n    errors: [],\n    securityEvents: []\n  };\n  return {\n    startMeasurement(operation) {\n      const startTime = performance.now();\n      return () => {\n        const duration = performance.now() - startTime;\n        metrics[operation] = duration;\n        if (duration > 1000) {\n          console.warn(`Slow auth operation: ${operation} took ${duration.toFixed(2)}ms`);\n        }\n      };\n    },\n    logError(error, operation) {\n      metrics.errors.push({\n        operation,\n        error: error.message,\n        timestamp: new Date().toISOString()\n      });\n    },\n    logSecurityEvent(eventType, details) {\n      metrics.securityEvents.push({\n        eventType,\n        details,\n        timestamp: new Date().toISOString()\n      });\n\n      // Log to console in development\n      if (process.env.NODE_ENV === 'development') {\n        console.log(`[SECURITY EVENT] ${eventType}:`, details);\n      }\n    },\n    getMetrics() {\n      return {\n        ...metrics\n      };\n    }\n  };\n};\n\n// Main provider component\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  // State management\n  const [state, setState] = useState({\n    user: null,\n    session: null,\n    loading: true,\n    error: null,\n    success: null,\n    sessionExpiresAt: null,\n    permissions: new Set()\n  });\n\n  // Refs for cleanup\n  const refreshTimerRef = useRef(null);\n  const sessionCheckRef = useRef(null);\n  const activityTimerRef = useRef(null);\n  const isMountedRef = useRef(true);\n  const performanceMonitor = useMemo(() => createPerformanceMonitor(), []);\n\n  // Update state safely\n  const setAuthState = useCallback(updates => {\n    if (isMountedRef.current) {\n      setState(prev => ({\n        ...prev,\n        ...updates\n      }));\n    }\n  }, []);\n\n  // Clear all timers\n  const clearTimers = useCallback(() => {\n    if (refreshTimerRef.current) {\n      clearTimeout(refreshTimerRef.current);\n      refreshTimerRef.current = null;\n    }\n    if (sessionCheckRef.current) {\n      clearInterval(sessionCheckRef.current);\n      sessionCheckRef.current = null;\n    }\n    if (activityTimerRef.current) {\n      clearTimeout(activityTimerRef.current);\n      activityTimerRef.current = null;\n    }\n  }, []);\n\n  // Schedule token refresh\n  const scheduleTokenRefresh = useCallback(expiresAt => {\n    clearTimers();\n    if (!expiresAt) return;\n    const refreshTime = expiresAt - 5 * 60 * 1000 - Date.now();\n    if (refreshTime > 0) {\n      refreshTimerRef.current = setTimeout(async () => {\n        try {\n          const endMeasurement = performanceMonitor.startMeasurement('tokenRefresh');\n          await authService.refreshAccessToken();\n          endMeasurement();\n\n          // Update session after refresh\n          const session = authService.getCurrentSession();\n          if (session) {\n            setAuthState({\n              session,\n              sessionExpiresAt: session.expiresAt\n            });\n            scheduleTokenRefresh(session.expiresAt);\n          }\n        } catch (error) {\n          performanceMonitor.logError(error, 'tokenRefresh');\n          console.error('Token refresh failed:', error);\n        }\n      }, refreshTime);\n    }\n  }, [clearTimers, performanceMonitor, setAuthState]);\n\n  // Start session monitoring\n  const startSessionMonitoring = useCallback(expiresAt => {\n    clearTimers();\n\n    // Check session every minute\n    sessionCheckRef.current = setInterval(() => {\n      if (expiresAt && Date.now() > expiresAt) {\n        logout('session_expired');\n      }\n    }, 60 * 1000);\n\n    // Activity tracking\n    const trackActivity = () => {\n      if (activityTimerRef.current) {\n        clearTimeout(activityTimerRef.current);\n      }\n      activityTimerRef.current = setTimeout(() => {\n        logout('inactivity');\n      }, 30 * 60 * 1000); // 30 minutes\n    };\n\n    // Track user activity\n    ['mousemove', 'keydown', 'click', 'scroll'].forEach(event => {\n      window.addEventListener(event, trackActivity, {\n        passive: true\n      });\n    });\n    trackActivity();\n  }, [clearTimers]);\n\n  // Security Event Logging Function\n  const logSecurityEvent = useCallback((eventType, details) => {\n    var _state$user, _state$user2, _state$session;\n    // Log to performance monitor\n    performanceMonitor.logSecurityEvent(eventType, details);\n\n    // Prepare log data\n    const logData = {\n      eventType,\n      details,\n      timestamp: new Date().toISOString(),\n      userId: (_state$user = state.user) === null || _state$user === void 0 ? void 0 : _state$user.id,\n      userRole: (_state$user2 = state.user) === null || _state$user2 === void 0 ? void 0 : _state$user2.role,\n      sessionId: (_state$session = state.session) === null || _state$session === void 0 ? void 0 : _state$session.id,\n      source: 'auth_context',\n      userAgent: navigator.userAgent,\n      url: window.location.href,\n      screenResolution: `${window.screen.width}x${window.screen.height}`,\n      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone\n    };\n\n    // Console log in development\n    if (process.env.NODE_ENV === 'development') {\n      console.group(`ðŸ”’ Security Event: ${eventType}`);\n      console.log('Details:', details);\n      console.log('Full Log:', logData);\n      console.groupEnd();\n    }\n\n    // Send to backend (async - don't await to avoid blocking)\n    if (window.location.hostname !== 'localhost' && process.env.NODE_ENV === 'production') {\n      try {\n        var _state$session2;\n        fetch('/api/logs/security', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': (_state$session2 = state.session) !== null && _state$session2 !== void 0 && _state$session2.accessToken ? `Bearer ${state.session.accessToken}` : ''\n          },\n          body: JSON.stringify(logData)\n        }).catch(error => {\n          console.warn('Failed to send security log to backend:', error);\n        });\n      } catch (error) {\n        console.error('Error sending security log:', error);\n      }\n    }\n  }, [state.user, state.session, performanceMonitor]);\n\n  // Initialize auth state\n  const initializeAuth = useCallback(async () => {\n    try {\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const session = authService.getCurrentSession();\n      if (!session) {\n        setAuthState({\n          loading: false\n        });\n        return;\n      }\n\n      // Verify session is still valid\n      if (Date.now() > session.expiresAt) {\n        await logout('session_expired');\n        return;\n      }\n\n      // Get fresh user data\n      const userResponse = await authService.getCurrentUser();\n      if (!userResponse.success) {\n        throw new Error('Failed to get user data');\n      }\n      const permissions = new Set(userResponse.data.permissions || []);\n      setAuthState({\n        user: userResponse.data,\n        session,\n        sessionExpiresAt: session.expiresAt,\n        permissions,\n        loading: false\n      });\n\n      // Log security event\n      logSecurityEvent('session_initialized', {\n        userId: userResponse.data.id,\n        role: userResponse.data.role,\n        sessionId: session.id,\n        sessionExpiresAt: new Date(session.expiresAt).toISOString()\n      });\n\n      // Schedule token refresh\n      scheduleTokenRefresh(session.expiresAt);\n\n      // Start session monitoring\n      startSessionMonitoring(session.expiresAt);\n    } catch (error) {\n      performanceMonitor.logError(error, 'initializeAuth');\n      console.error('Auth initialization error:', error);\n      logSecurityEvent('initialization_failed', {\n        error: error.message,\n        sessionExists: !!authService.getCurrentSession()\n      });\n      setAuthState({\n        error: 'Failed to initialize authentication',\n        loading: false\n      });\n    }\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, logSecurityEvent]);\n\n  // Login\n  const login = useCallback(async (email, password, rememberMe = false) => {\n    try {\n      setAuthState({\n        loading: true,\n        error: null,\n        success: null\n      });\n      const endMeasurement = performanceMonitor.startMeasurement('login');\n      const response = await authService.login(email, password, rememberMe);\n      endMeasurement();\n      if (!response.success) {\n        throw new Error(response.message || 'Login failed');\n      }\n      const session = authService.getCurrentSession();\n      const permissions = new Set(response.data.user.permissions || []);\n      setAuthState({\n        user: response.data.user,\n        session,\n        sessionExpiresAt: session.expiresAt,\n        permissions,\n        loading: false,\n        success: 'Login successful'\n      });\n\n      // Log security event\n      logSecurityEvent('login_success', {\n        userId: response.data.user.id,\n        email: email,\n        role: response.data.user.role,\n        rememberMe,\n        ip: 'client-side',\n        // In production, this would come from the backend\n        userAgent: navigator.userAgent\n      });\n\n      // Schedule token refresh\n      scheduleTokenRefresh(session.expiresAt);\n\n      // Start session monitoring\n      startSessionMonitoring(session.expiresAt);\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'login');\n\n      // Log failed login attempt\n      logSecurityEvent('login_failed', {\n        email: email,\n        error: error.message,\n        userAgent: navigator.userAgent,\n        timestamp: new Date().toISOString()\n      });\n      const errorMessage = error.message || 'Login failed. Please check your credentials.';\n      setAuthState({\n        error: errorMessage,\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, logSecurityEvent]);\n\n  // Register\n  const register = useCallback(async userData => {\n    try {\n      setAuthState({\n        loading: true,\n        error: null,\n        success: null\n      });\n      const endMeasurement = performanceMonitor.startMeasurement('register');\n      const response = await authService.register(userData);\n      endMeasurement();\n      if (!response.success) {\n        throw new Error(response.message || 'Registration failed');\n      }\n\n      // Log registration attempt\n      logSecurityEvent('registration_attempt', {\n        email: userData.email,\n        role: userData.role,\n        username: userData.username,\n        department: userData.department,\n        isPersonalEmail: userData.email && !userData.email.includes('bugemauniv.ac.ug')\n      });\n      if (response.requiresVerification) {\n        var _response$data;\n        setAuthState({\n          loading: false,\n          success: response.message || 'Registration successful! Please verify your email.'\n        });\n\n        // Log registration success (pending verification)\n        logSecurityEvent('registration_pending_verification', {\n          userId: ((_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.id) || 'pending',\n          email: userData.email,\n          role: userData.role\n        });\n        return response;\n      }\n\n      // Auto-login after registration\n      const session = authService.getCurrentSession();\n      const permissions = new Set(response.data.user.permissions || []);\n      setAuthState({\n        user: response.data.user,\n        session,\n        sessionExpiresAt: session.expiresAt,\n        permissions,\n        loading: false,\n        success: response.message || 'Registration successful!'\n      });\n\n      // Log registration success\n      logSecurityEvent('registration_success', {\n        userId: response.data.user.id,\n        email: userData.email,\n        role: userData.role,\n        username: userData.username,\n        department: userData.department\n      });\n\n      // Schedule token refresh\n      scheduleTokenRefresh(session.expiresAt);\n\n      // Start session monitoring\n      startSessionMonitoring(session.expiresAt);\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'register');\n\n      // Log registration failure\n      logSecurityEvent('registration_failed', {\n        email: userData.email,\n        role: userData.role,\n        error: error.message,\n        errorCode: error.code,\n        username: userData.username\n      });\n      let errorMessage = error.message || 'Registration failed. Please try again.';\n\n      // Handle specific error types\n      if (error.isAPIError) {\n        switch (error.code) {\n          case 'EMAIL_EXISTS':\n            errorMessage = 'An account with this email already exists.';\n            break;\n          case 'USERNAME_EXISTS':\n            errorMessage = 'This username is already taken.';\n            break;\n          case 'VALIDATION_ERROR':\n            if (error.errors) {\n              errorMessage = Object.values(error.errors).join('. ');\n            }\n            break;\n        }\n      }\n      setAuthState({\n        error: errorMessage,\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, logSecurityEvent]);\n\n  // Logout\n  const logout = useCallback(async (reason = 'user_action') => {\n    try {\n      var _state$user3, _state$user4, _state$session3;\n      // Log logout event\n      logSecurityEvent('logout', {\n        userId: (_state$user3 = state.user) === null || _state$user3 === void 0 ? void 0 : _state$user3.id,\n        userRole: (_state$user4 = state.user) === null || _state$user4 === void 0 ? void 0 : _state$user4.role,\n        reason: reason,\n        sessionId: (_state$session3 = state.session) === null || _state$session3 === void 0 ? void 0 : _state$session3.id,\n        sessionDuration: state.session ? (Date.now() - new Date(state.session.createdAt).getTime()) / 1000 : null\n      });\n      await authService.logout();\n    } catch (error) {\n      var _state$user5;\n      console.warn('Logout error:', error);\n      logSecurityEvent('logout_error', {\n        error: error.message,\n        userId: (_state$user5 = state.user) === null || _state$user5 === void 0 ? void 0 : _state$user5.id,\n        reason: reason\n      });\n    } finally {\n      clearTimers();\n      setAuthState({\n        user: null,\n        session: null,\n        sessionExpiresAt: null,\n        permissions: new Set(),\n        error: null,\n        success: null,\n        loading: false\n      });\n    }\n  }, [clearTimers, setAuthState, state.user, state.session, logSecurityEvent]);\n\n  // Check username availability\n  const checkUsername = useCallback(async username => {\n    try {\n      const response = await authService.checkUsername(username);\n\n      // Log username check\n      logSecurityEvent('username_check', {\n        username: username,\n        available: response.available,\n        suggestedAlternatives: response.suggestions\n      });\n      return response;\n    } catch (error) {\n      console.error('Check username error:', error);\n      logSecurityEvent('username_check_error', {\n        username: username,\n        error: error.message\n      });\n      return {\n        success: false,\n        available: false,\n        error: error.message\n      };\n    }\n  }, [logSecurityEvent]);\n\n  // Check email availability\n  const checkEmail = useCallback(async email => {\n    try {\n      const response = await authService.checkEmail(email);\n\n      // Log email check\n      logSecurityEvent('email_check', {\n        email: email,\n        available: response.available,\n        isUniversityEmail: email.includes('bugemauniv.ac.ug')\n      });\n      return response;\n    } catch (error) {\n      console.error('Check email error:', error);\n      logSecurityEvent('email_check_error', {\n        email: email,\n        error: error.message\n      });\n      return {\n        success: false,\n        available: false,\n        error: error.message\n      };\n    }\n  }, [logSecurityEvent]);\n\n  // Update profile\n  const updateProfile = useCallback(async updates => {\n    try {\n      var _state$user6;\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const response = await authService.updateProfile(updates);\n      if (!response.success) {\n        throw new Error(response.message || 'Update failed');\n      }\n\n      // Log profile update\n      logSecurityEvent('profile_updated', {\n        userId: response.data.id,\n        updatedFields: Object.keys(updates),\n        previousRole: (_state$user6 = state.user) === null || _state$user6 === void 0 ? void 0 : _state$user6.role,\n        newRole: response.data.role\n      });\n      setAuthState({\n        user: response.data,\n        loading: false,\n        success: response.message || 'Profile updated successfully'\n      });\n      return response;\n    } catch (error) {\n      var _state$user7;\n      performanceMonitor.logError(error, 'updateProfile');\n\n      // Log profile update failure\n      logSecurityEvent('profile_update_failed', {\n        userId: (_state$user7 = state.user) === null || _state$user7 === void 0 ? void 0 : _state$user7.id,\n        error: error.message,\n        attemptedUpdates: Object.keys(updates)\n      });\n      setAuthState({\n        error: error.message || 'Failed to update profile',\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, performanceMonitor, state.user, logSecurityEvent]);\n\n  // Change password\n  const changePassword = useCallback(async (currentPassword, newPassword) => {\n    try {\n      var _state$user8, _state$user9;\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const response = await authService.changePassword(currentPassword, newPassword);\n      if (!response.success) {\n        throw new Error(response.message || 'Password change failed');\n      }\n\n      // Log password change\n      logSecurityEvent('password_changed', {\n        userId: (_state$user8 = state.user) === null || _state$user8 === void 0 ? void 0 : _state$user8.id,\n        userRole: (_state$user9 = state.user) === null || _state$user9 === void 0 ? void 0 : _state$user9.role,\n        passwordStrength: newPassword.length // You could add more sophisticated strength calculation\n      });\n      setAuthState({\n        loading: false,\n        success: response.message || 'Password changed successfully'\n      });\n      return response;\n    } catch (error) {\n      var _state$user0;\n      performanceMonitor.logError(error, 'changePassword');\n\n      // Log failed password change\n      logSecurityEvent('password_change_failed', {\n        userId: (_state$user0 = state.user) === null || _state$user0 === void 0 ? void 0 : _state$user0.id,\n        error: error.message,\n        attempted: true\n      });\n      setAuthState({\n        error: error.message || 'Failed to change password',\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, performanceMonitor, state.user, logSecurityEvent]);\n\n  // Forgot password\n  const forgotPassword = useCallback(async email => {\n    try {\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const response = await authService.forgotPassword(email);\n\n      // Log forgot password request (always log, even if email doesn't exist for security)\n      logSecurityEvent('forgot_password_requested', {\n        email: email,\n        ip: 'client-side',\n        userAgent: navigator.userAgent,\n        timestamp: new Date().toISOString()\n      });\n      setAuthState({\n        loading: false,\n        success: response.message || 'If an account exists, you will receive reset instructions.'\n      });\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'forgotPassword');\n\n      // Still show success for security (don't reveal if email exists)\n      setAuthState({\n        loading: false,\n        success: 'If an account exists, you will receive reset instructions.'\n      });\n      return {\n        success: true,\n        message: 'If an account exists, you will receive reset instructions.'\n      };\n    }\n  }, [setAuthState, performanceMonitor, logSecurityEvent]);\n\n  // Reset password\n  const resetPassword = useCallback(async (token, passwordData) => {\n    try {\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const response = await authService.resetPassword(token, passwordData);\n      if (!response.success) {\n        throw new Error(response.message || 'Password reset failed');\n      }\n\n      // Log password reset\n      logSecurityEvent('password_reset', {\n        tokenUsed: token.substring(0, 8) + '...',\n        // Only log partial token for security\n        success: true,\n        ip: 'client-side'\n      });\n      setAuthState({\n        loading: false,\n        success: response.message || 'Password reset successful'\n      });\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'resetPassword');\n\n      // Log failed password reset\n      logSecurityEvent('password_reset_failed', {\n        tokenUsed: token ? token.substring(0, 8) + '...' : 'no-token',\n        error: error.message,\n        ip: 'client-side'\n      });\n      setAuthState({\n        error: error.message || 'Failed to reset password',\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, performanceMonitor, logSecurityEvent]);\n\n  // Verify email\n  const verifyEmail = useCallback(async token => {\n    try {\n      var _response$data2, _response$data3;\n      setAuthState({\n        loading: true,\n        error: null\n      });\n      const response = await authService.verifyEmail(token);\n      if (!response.success) {\n        throw new Error(response.message || 'Verification failed');\n      }\n\n      // Log email verification\n      logSecurityEvent('email_verified', {\n        userId: (_response$data2 = response.data) === null || _response$data2 === void 0 ? void 0 : _response$data2.id,\n        tokenUsed: token.substring(0, 8) + '...',\n        success: true,\n        email: (_response$data3 = response.data) === null || _response$data3 === void 0 ? void 0 : _response$data3.email\n      });\n      setAuthState({\n        loading: false,\n        success: response.message || 'Email verified successfully'\n      });\n      return response;\n    } catch (error) {\n      performanceMonitor.logError(error, 'verifyEmail');\n\n      // Log verification failure\n      logSecurityEvent('email_verification_failed', {\n        tokenUsed: token.substring(0, 8) + '...',\n        error: error.message,\n        ip: 'client-side'\n      });\n      setAuthState({\n        error: error.message || 'Failed to verify email',\n        loading: false\n      });\n      throw error;\n    }\n  }, [setAuthState, performanceMonitor, logSecurityEvent]);\n\n  // Check permissions\n  const hasPermission = useCallback(permission => {\n    var _state$user1;\n    const hasPerm = state.permissions.has(permission) || ((_state$user1 = state.user) === null || _state$user1 === void 0 ? void 0 : _state$user1.role) === 'admin';\n\n    // Log permission check for admin/security reviews\n    if (process.env.NODE_ENV === 'development') {\n      var _state$user10, _state$user11;\n      logSecurityEvent('permission_check', {\n        permission,\n        userId: (_state$user10 = state.user) === null || _state$user10 === void 0 ? void 0 : _state$user10.id,\n        hasPermission: hasPerm,\n        userRole: (_state$user11 = state.user) === null || _state$user11 === void 0 ? void 0 : _state$user11.role\n      });\n    }\n    return hasPerm;\n  }, [state.permissions, state.user, logSecurityEvent]);\n  const hasRole = useCallback(role => {\n    var _state$user12;\n    return ((_state$user12 = state.user) === null || _state$user12 === void 0 ? void 0 : _state$user12.role) === role;\n  }, [state.user]);\n  const hasAnyRole = useCallback(roles => {\n    var _state$user13;\n    return roles.includes((_state$user13 = state.user) === null || _state$user13 === void 0 ? void 0 : _state$user13.role);\n  }, [state.user]);\n\n  // Clear messages\n  const clearError = useCallback(() => {\n    setAuthState({\n      error: null\n    });\n  }, [setAuthState]);\n  const clearSuccess = useCallback(() => {\n    setAuthState({\n      success: null\n    });\n  }, [setAuthState]);\n\n  // Initialize on mount\n  useEffect(() => {\n    isMountedRef.current = true;\n    initializeAuth();\n    return () => {\n      var _state$user14;\n      isMountedRef.current = false;\n      clearTimers();\n\n      // Log component unmount\n      logSecurityEvent('auth_context_unmounted', {\n        userId: (_state$user14 = state.user) === null || _state$user14 === void 0 ? void 0 : _state$user14.id,\n        sessionActive: !!state.session,\n        unmountTime: new Date().toISOString()\n      });\n    };\n  }, [initializeAuth, clearTimers, logSecurityEvent, state.user, state.session]);\n\n  // Context value\n  const contextValue = useMemo(() => ({\n    // State\n    user: state.user,\n    session: state.session,\n    loading: state.loading,\n    error: state.error,\n    success: state.success,\n    sessionExpiresAt: state.sessionExpiresAt,\n    // Authentication methods\n    login,\n    register,\n    logout,\n    // Validation methods\n    checkUsername,\n    checkEmail,\n    // User management\n    updateProfile,\n    changePassword,\n    forgotPassword,\n    resetPassword,\n    verifyEmail,\n    // Permission checks\n    hasPermission,\n    hasRole,\n    hasAnyRole,\n    isAuthenticated: !!state.user && !!state.session,\n    // Security logging\n    logSecurityEvent,\n    // Utility methods\n    clearError,\n    clearSuccess,\n    // Performance metrics (for debugging)\n    getPerformanceMetrics: () => performanceMonitor.getMetrics()\n  }), [state, login, register, logout, checkUsername, checkEmail, updateProfile, changePassword, forgotPassword, resetPassword, verifyEmail, hasPermission, hasRole, hasAnyRole, logSecurityEvent, clearError, clearSuccess, performanceMonitor]);\n  return /*#__PURE__*/_jsxDEV(AuthErrorBoundary, {\n    children: /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n      value: contextValue,\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 924,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 923,\n    columnNumber: 5\n  }, this);\n};\n\n// PropTypes\n_s2(AuthProvider, \"LCZvtuboUELh3SAziUXLOYXyIzA=\");\n_c = AuthProvider;\nAuthProvider.propTypes = {\n  children: PropTypes.node.isRequired\n};\nexport default AuthContext;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useCallback","useRef","useMemo","PropTypes","authService","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","context","Error","AuthErrorBoundary","Component","constructor","props","state","hasError","error","getDerivedStateFromError","componentDidCatch","errorInfo","console","render","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","window","location","reload","createPerformanceMonitor","metrics","loginTime","refreshTime","sessionChecks","errors","securityEvents","startMeasurement","operation","startTime","performance","now","duration","warn","toFixed","logError","push","message","timestamp","Date","toISOString","logSecurityEvent","eventType","details","process","env","NODE_ENV","log","getMetrics","AuthProvider","_s2","setState","user","session","loading","success","sessionExpiresAt","permissions","Set","refreshTimerRef","sessionCheckRef","activityTimerRef","isMountedRef","performanceMonitor","setAuthState","updates","current","prev","clearTimers","clearTimeout","clearInterval","scheduleTokenRefresh","expiresAt","setTimeout","endMeasurement","refreshAccessToken","getCurrentSession","startSessionMonitoring","setInterval","logout","trackActivity","forEach","event","addEventListener","passive","_state$user","_state$user2","_state$session","logData","userId","id","userRole","role","sessionId","source","userAgent","navigator","url","href","screenResolution","screen","width","height","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","group","groupEnd","hostname","_state$session2","fetch","method","headers","accessToken","body","JSON","stringify","catch","initializeAuth","userResponse","getCurrentUser","data","sessionExists","login","email","password","rememberMe","response","ip","errorMessage","register","userData","username","department","isPersonalEmail","includes","requiresVerification","_response$data","errorCode","code","isAPIError","Object","values","join","reason","_state$user3","_state$user4","_state$session3","sessionDuration","createdAt","getTime","_state$user5","checkUsername","available","suggestedAlternatives","suggestions","checkEmail","isUniversityEmail","updateProfile","_state$user6","updatedFields","keys","previousRole","newRole","_state$user7","attemptedUpdates","changePassword","currentPassword","newPassword","_state$user8","_state$user9","passwordStrength","length","_state$user0","attempted","forgotPassword","resetPassword","token","passwordData","tokenUsed","substring","verifyEmail","_response$data2","_response$data3","hasPermission","permission","_state$user1","hasPerm","has","_state$user10","_state$user11","hasRole","_state$user12","hasAnyRole","roles","_state$user13","clearError","clearSuccess","_state$user14","sessionActive","unmountTime","contextValue","isAuthenticated","getPerformanceMetrics","Provider","value","_c","propTypes","node","isRequired","$RefreshReg$"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/context/AuthContext.js"],"sourcesContent":["// frontend/src/context/AuthContext.js - ENHANCED VERSION WITH LOG SECURITY EVENT\r\nimport React, { createContext, useState, useContext, useEffect, useCallback, useRef, useMemo } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { authService } from '../services/authService';\r\n\r\n/**\r\n * Enterprise Auth Context v5.1.0\r\n * Features:\r\n * - Comprehensive state management\r\n * - Automatic token refresh\r\n * - Session monitoring\r\n * - Error boundary integration\r\n * - Performance optimization\r\n * - Memory leak prevention\r\n * - Role-based permissions\r\n * - Event logging with logSecurityEvent\r\n */\r\n\r\n// Context\r\nexport const AuthContext = createContext();\r\n\r\n// Custom hook\r\nexport const useAuth = () => {\r\n  const context = useContext(AuthContext);\r\n  if (!context) {\r\n    throw new Error('useAuth must be used within AuthProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// Error boundary for auth errors\r\nclass AuthErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { hasError: false, error: null };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    return { hasError: true, error };\r\n  }\r\n\r\n  componentDidCatch(error, errorInfo) {\r\n    console.error('Auth Error Boundary caught:', error, errorInfo);\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return (\r\n        <div className=\"auth-error-boundary\">\r\n          <h3>Authentication Error</h3>\r\n          <p>Something went wrong with authentication. Please try refreshing the page.</p>\r\n          <button onClick={() => window.location.reload()}>\r\n            Refresh Page\r\n          </button>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\n// Performance monitoring\r\nconst createPerformanceMonitor = () => {\r\n  const metrics = {\r\n    loginTime: null,\r\n    refreshTime: null,\r\n    sessionChecks: 0,\r\n    errors: [],\r\n    securityEvents: []\r\n  };\r\n\r\n  return {\r\n    startMeasurement(operation) {\r\n      const startTime = performance.now();\r\n      return () => {\r\n        const duration = performance.now() - startTime;\r\n        metrics[operation] = duration;\r\n        \r\n        if (duration > 1000) {\r\n          console.warn(`Slow auth operation: ${operation} took ${duration.toFixed(2)}ms`);\r\n        }\r\n      };\r\n    },\r\n\r\n    logError(error, operation) {\r\n      metrics.errors.push({\r\n        operation,\r\n        error: error.message,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n    },\r\n\r\n    logSecurityEvent(eventType, details) {\r\n      metrics.securityEvents.push({\r\n        eventType,\r\n        details,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      \r\n      // Log to console in development\r\n      if (process.env.NODE_ENV === 'development') {\r\n        console.log(`[SECURITY EVENT] ${eventType}:`, details);\r\n      }\r\n    },\r\n\r\n    getMetrics() {\r\n      return { ...metrics };\r\n    }\r\n  };\r\n};\r\n\r\n// Main provider component\r\nexport const AuthProvider = ({ children }) => {\r\n  // State management\r\n  const [state, setState] = useState({\r\n    user: null,\r\n    session: null,\r\n    loading: true,\r\n    error: null,\r\n    success: null,\r\n    sessionExpiresAt: null,\r\n    permissions: new Set()\r\n  });\r\n\r\n  // Refs for cleanup\r\n  const refreshTimerRef = useRef(null);\r\n  const sessionCheckRef = useRef(null);\r\n  const activityTimerRef = useRef(null);\r\n  const isMountedRef = useRef(true);\r\n  const performanceMonitor = useMemo(() => createPerformanceMonitor(), []);\r\n\r\n  // Update state safely\r\n  const setAuthState = useCallback((updates) => {\r\n    if (isMountedRef.current) {\r\n      setState(prev => ({ ...prev, ...updates }));\r\n    }\r\n  }, []);\r\n\r\n  // Clear all timers\r\n  const clearTimers = useCallback(() => {\r\n    if (refreshTimerRef.current) {\r\n      clearTimeout(refreshTimerRef.current);\r\n      refreshTimerRef.current = null;\r\n    }\r\n    \r\n    if (sessionCheckRef.current) {\r\n      clearInterval(sessionCheckRef.current);\r\n      sessionCheckRef.current = null;\r\n    }\r\n    \r\n    if (activityTimerRef.current) {\r\n      clearTimeout(activityTimerRef.current);\r\n      activityTimerRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  // Schedule token refresh\r\n  const scheduleTokenRefresh = useCallback((expiresAt) => {\r\n    clearTimers();\r\n    \r\n    if (!expiresAt) return;\r\n\r\n    const refreshTime = expiresAt - (5 * 60 * 1000) - Date.now();\r\n    \r\n    if (refreshTime > 0) {\r\n      refreshTimerRef.current = setTimeout(async () => {\r\n        try {\r\n          const endMeasurement = performanceMonitor.startMeasurement('tokenRefresh');\r\n          await authService.refreshAccessToken();\r\n          endMeasurement();\r\n          \r\n          // Update session after refresh\r\n          const session = authService.getCurrentSession();\r\n          if (session) {\r\n            setAuthState({\r\n              session,\r\n              sessionExpiresAt: session.expiresAt\r\n            });\r\n            scheduleTokenRefresh(session.expiresAt);\r\n          }\r\n        } catch (error) {\r\n          performanceMonitor.logError(error, 'tokenRefresh');\r\n          console.error('Token refresh failed:', error);\r\n        }\r\n      }, refreshTime);\r\n    }\r\n  }, [clearTimers, performanceMonitor, setAuthState]);\r\n\r\n  // Start session monitoring\r\n  const startSessionMonitoring = useCallback((expiresAt) => {\r\n    clearTimers();\r\n    \r\n    // Check session every minute\r\n    sessionCheckRef.current = setInterval(() => {\r\n      if (expiresAt && Date.now() > expiresAt) {\r\n        logout('session_expired');\r\n      }\r\n    }, 60 * 1000);\r\n\r\n    // Activity tracking\r\n    const trackActivity = () => {\r\n      if (activityTimerRef.current) {\r\n        clearTimeout(activityTimerRef.current);\r\n      }\r\n      \r\n      activityTimerRef.current = setTimeout(() => {\r\n        logout('inactivity');\r\n      }, 30 * 60 * 1000); // 30 minutes\r\n    };\r\n\r\n    // Track user activity\r\n    ['mousemove', 'keydown', 'click', 'scroll'].forEach(event => {\r\n      window.addEventListener(event, trackActivity, { passive: true });\r\n    });\r\n\r\n    trackActivity();\r\n  }, [clearTimers]);\r\n\r\n  // Security Event Logging Function\r\n  const logSecurityEvent = useCallback((eventType, details) => {\r\n    // Log to performance monitor\r\n    performanceMonitor.logSecurityEvent(eventType, details);\r\n    \r\n    // Prepare log data\r\n    const logData = {\r\n      eventType,\r\n      details,\r\n      timestamp: new Date().toISOString(),\r\n      userId: state.user?.id,\r\n      userRole: state.user?.role,\r\n      sessionId: state.session?.id,\r\n      source: 'auth_context',\r\n      userAgent: navigator.userAgent,\r\n      url: window.location.href,\r\n      screenResolution: `${window.screen.width}x${window.screen.height}`,\r\n      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone\r\n    };\r\n    \r\n    // Console log in development\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.group(`ðŸ”’ Security Event: ${eventType}`);\r\n      console.log('Details:', details);\r\n      console.log('Full Log:', logData);\r\n      console.groupEnd();\r\n    }\r\n    \r\n    // Send to backend (async - don't await to avoid blocking)\r\n    if (window.location.hostname !== 'localhost' && process.env.NODE_ENV === 'production') {\r\n      try {\r\n        fetch('/api/logs/security', {\r\n          method: 'POST',\r\n          headers: { \r\n            'Content-Type': 'application/json',\r\n            'Authorization': state.session?.accessToken ? `Bearer ${state.session.accessToken}` : ''\r\n          },\r\n          body: JSON.stringify(logData)\r\n        }).catch(error => {\r\n          console.warn('Failed to send security log to backend:', error);\r\n        });\r\n      } catch (error) {\r\n        console.error('Error sending security log:', error);\r\n      }\r\n    }\r\n  }, [state.user, state.session, performanceMonitor]);\r\n\r\n  // Initialize auth state\r\n  const initializeAuth = useCallback(async () => {\r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n\r\n      const session = authService.getCurrentSession();\r\n      \r\n      if (!session) {\r\n        setAuthState({ loading: false });\r\n        return;\r\n      }\r\n\r\n      // Verify session is still valid\r\n      if (Date.now() > session.expiresAt) {\r\n        await logout('session_expired');\r\n        return;\r\n      }\r\n\r\n      // Get fresh user data\r\n      const userResponse = await authService.getCurrentUser();\r\n      \r\n      if (!userResponse.success) {\r\n        throw new Error('Failed to get user data');\r\n      }\r\n\r\n      const permissions = new Set(userResponse.data.permissions || []);\r\n\r\n      setAuthState({\r\n        user: userResponse.data,\r\n        session,\r\n        sessionExpiresAt: session.expiresAt,\r\n        permissions,\r\n        loading: false\r\n      });\r\n\r\n      // Log security event\r\n      logSecurityEvent('session_initialized', {\r\n        userId: userResponse.data.id,\r\n        role: userResponse.data.role,\r\n        sessionId: session.id,\r\n        sessionExpiresAt: new Date(session.expiresAt).toISOString()\r\n      });\r\n\r\n      // Schedule token refresh\r\n      scheduleTokenRefresh(session.expiresAt);\r\n      \r\n      // Start session monitoring\r\n      startSessionMonitoring(session.expiresAt);\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'initializeAuth');\r\n      console.error('Auth initialization error:', error);\r\n      \r\n      logSecurityEvent('initialization_failed', {\r\n        error: error.message,\r\n        sessionExists: !!authService.getCurrentSession()\r\n      });\r\n      \r\n      setAuthState({\r\n        error: 'Failed to initialize authentication',\r\n        loading: false\r\n      });\r\n    }\r\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, logSecurityEvent]);\r\n\r\n  // Login\r\n  const login = useCallback(async (email, password, rememberMe = false) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null, success: null });\r\n      \r\n      const endMeasurement = performanceMonitor.startMeasurement('login');\r\n      const response = await authService.login(email, password, rememberMe);\r\n      endMeasurement();\r\n\r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Login failed');\r\n      }\r\n\r\n      const session = authService.getCurrentSession();\r\n      const permissions = new Set(response.data.user.permissions || []);\r\n\r\n      setAuthState({\r\n        user: response.data.user,\r\n        session,\r\n        sessionExpiresAt: session.expiresAt,\r\n        permissions,\r\n        loading: false,\r\n        success: 'Login successful'\r\n      });\r\n\r\n      // Log security event\r\n      logSecurityEvent('login_success', {\r\n        userId: response.data.user.id,\r\n        email: email,\r\n        role: response.data.user.role,\r\n        rememberMe,\r\n        ip: 'client-side', // In production, this would come from the backend\r\n        userAgent: navigator.userAgent\r\n      });\r\n\r\n      // Schedule token refresh\r\n      scheduleTokenRefresh(session.expiresAt);\r\n      \r\n      // Start session monitoring\r\n      startSessionMonitoring(session.expiresAt);\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'login');\r\n      \r\n      // Log failed login attempt\r\n      logSecurityEvent('login_failed', {\r\n        email: email,\r\n        error: error.message,\r\n        userAgent: navigator.userAgent,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      \r\n      const errorMessage = error.message || 'Login failed. Please check your credentials.';\r\n      \r\n      setAuthState({\r\n        error: errorMessage,\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, logSecurityEvent]);\r\n\r\n  // Register\r\n  const register = useCallback(async (userData) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null, success: null });\r\n      \r\n      const endMeasurement = performanceMonitor.startMeasurement('register');\r\n      const response = await authService.register(userData);\r\n      endMeasurement();\r\n\r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Registration failed');\r\n      }\r\n\r\n      // Log registration attempt\r\n      logSecurityEvent('registration_attempt', {\r\n        email: userData.email,\r\n        role: userData.role,\r\n        username: userData.username,\r\n        department: userData.department,\r\n        isPersonalEmail: userData.email && !userData.email.includes('bugemauniv.ac.ug')\r\n      });\r\n\r\n      if (response.requiresVerification) {\r\n        setAuthState({\r\n          loading: false,\r\n          success: response.message || 'Registration successful! Please verify your email.'\r\n        });\r\n        \r\n        // Log registration success (pending verification)\r\n        logSecurityEvent('registration_pending_verification', {\r\n          userId: response.data?.id || 'pending',\r\n          email: userData.email,\r\n          role: userData.role\r\n        });\r\n        \r\n        return response;\r\n      }\r\n\r\n      // Auto-login after registration\r\n      const session = authService.getCurrentSession();\r\n      const permissions = new Set(response.data.user.permissions || []);\r\n\r\n      setAuthState({\r\n        user: response.data.user,\r\n        session,\r\n        sessionExpiresAt: session.expiresAt,\r\n        permissions,\r\n        loading: false,\r\n        success: response.message || 'Registration successful!'\r\n      });\r\n\r\n      // Log registration success\r\n      logSecurityEvent('registration_success', {\r\n        userId: response.data.user.id,\r\n        email: userData.email,\r\n        role: userData.role,\r\n        username: userData.username,\r\n        department: userData.department\r\n      });\r\n\r\n      // Schedule token refresh\r\n      scheduleTokenRefresh(session.expiresAt);\r\n      \r\n      // Start session monitoring\r\n      startSessionMonitoring(session.expiresAt);\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'register');\r\n      \r\n      // Log registration failure\r\n      logSecurityEvent('registration_failed', {\r\n        email: userData.email,\r\n        role: userData.role,\r\n        error: error.message,\r\n        errorCode: error.code,\r\n        username: userData.username\r\n      });\r\n      \r\n      let errorMessage = error.message || 'Registration failed. Please try again.';\r\n      \r\n      // Handle specific error types\r\n      if (error.isAPIError) {\r\n        switch (error.code) {\r\n          case 'EMAIL_EXISTS':\r\n            errorMessage = 'An account with this email already exists.';\r\n            break;\r\n          case 'USERNAME_EXISTS':\r\n            errorMessage = 'This username is already taken.';\r\n            break;\r\n          case 'VALIDATION_ERROR':\r\n            if (error.errors) {\r\n              errorMessage = Object.values(error.errors).join('. ');\r\n            }\r\n            break;\r\n        }\r\n      }\r\n\r\n      setAuthState({\r\n        error: errorMessage,\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, scheduleTokenRefresh, startSessionMonitoring, performanceMonitor, logSecurityEvent]);\r\n\r\n  // Logout\r\n  const logout = useCallback(async (reason = 'user_action') => {\r\n    try {\r\n      // Log logout event\r\n      logSecurityEvent('logout', {\r\n        userId: state.user?.id,\r\n        userRole: state.user?.role,\r\n        reason: reason,\r\n        sessionId: state.session?.id,\r\n        sessionDuration: state.session ? \r\n          (Date.now() - new Date(state.session.createdAt).getTime()) / 1000 : null\r\n      });\r\n      \r\n      await authService.logout();\r\n    } catch (error) {\r\n      console.warn('Logout error:', error);\r\n      logSecurityEvent('logout_error', {\r\n        error: error.message,\r\n        userId: state.user?.id,\r\n        reason: reason\r\n      });\r\n    } finally {\r\n      clearTimers();\r\n      \r\n      setAuthState({\r\n        user: null,\r\n        session: null,\r\n        sessionExpiresAt: null,\r\n        permissions: new Set(),\r\n        error: null,\r\n        success: null,\r\n        loading: false\r\n      });\r\n    }\r\n  }, [clearTimers, setAuthState, state.user, state.session, logSecurityEvent]);\r\n\r\n  // Check username availability\r\n  const checkUsername = useCallback(async (username) => {\r\n    try {\r\n      const response = await authService.checkUsername(username);\r\n      \r\n      // Log username check\r\n      logSecurityEvent('username_check', {\r\n        username: username,\r\n        available: response.available,\r\n        suggestedAlternatives: response.suggestions\r\n      });\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('Check username error:', error);\r\n      \r\n      logSecurityEvent('username_check_error', {\r\n        username: username,\r\n        error: error.message\r\n      });\r\n      \r\n      return { success: false, available: false, error: error.message };\r\n    }\r\n  }, [logSecurityEvent]);\r\n\r\n  // Check email availability\r\n  const checkEmail = useCallback(async (email) => {\r\n    try {\r\n      const response = await authService.checkEmail(email);\r\n      \r\n      // Log email check\r\n      logSecurityEvent('email_check', {\r\n        email: email,\r\n        available: response.available,\r\n        isUniversityEmail: email.includes('bugemauniv.ac.ug')\r\n      });\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('Check email error:', error);\r\n      \r\n      logSecurityEvent('email_check_error', {\r\n        email: email,\r\n        error: error.message\r\n      });\r\n      \r\n      return { success: false, available: false, error: error.message };\r\n    }\r\n  }, [logSecurityEvent]);\r\n\r\n  // Update profile\r\n  const updateProfile = useCallback(async (updates) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n      \r\n      const response = await authService.updateProfile(updates);\r\n      \r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Update failed');\r\n      }\r\n\r\n      // Log profile update\r\n      logSecurityEvent('profile_updated', {\r\n        userId: response.data.id,\r\n        updatedFields: Object.keys(updates),\r\n        previousRole: state.user?.role,\r\n        newRole: response.data.role\r\n      });\r\n\r\n      setAuthState({\r\n        user: response.data,\r\n        loading: false,\r\n        success: response.message || 'Profile updated successfully'\r\n      });\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'updateProfile');\r\n      \r\n      // Log profile update failure\r\n      logSecurityEvent('profile_update_failed', {\r\n        userId: state.user?.id,\r\n        error: error.message,\r\n        attemptedUpdates: Object.keys(updates)\r\n      });\r\n      \r\n      setAuthState({\r\n        error: error.message || 'Failed to update profile',\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, performanceMonitor, state.user, logSecurityEvent]);\r\n\r\n  // Change password\r\n  const changePassword = useCallback(async (currentPassword, newPassword) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n      \r\n      const response = await authService.changePassword(currentPassword, newPassword);\r\n      \r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Password change failed');\r\n      }\r\n\r\n      // Log password change\r\n      logSecurityEvent('password_changed', {\r\n        userId: state.user?.id,\r\n        userRole: state.user?.role,\r\n        passwordStrength: newPassword.length // You could add more sophisticated strength calculation\r\n      });\r\n\r\n      setAuthState({\r\n        loading: false,\r\n        success: response.message || 'Password changed successfully'\r\n      });\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'changePassword');\r\n      \r\n      // Log failed password change\r\n      logSecurityEvent('password_change_failed', {\r\n        userId: state.user?.id,\r\n        error: error.message,\r\n        attempted: true\r\n      });\r\n      \r\n      setAuthState({\r\n        error: error.message || 'Failed to change password',\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, performanceMonitor, state.user, logSecurityEvent]);\r\n\r\n  // Forgot password\r\n  const forgotPassword = useCallback(async (email) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n      \r\n      const response = await authService.forgotPassword(email);\r\n      \r\n      // Log forgot password request (always log, even if email doesn't exist for security)\r\n      logSecurityEvent('forgot_password_requested', {\r\n        email: email,\r\n        ip: 'client-side',\r\n        userAgent: navigator.userAgent,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      setAuthState({\r\n        loading: false,\r\n        success: response.message || 'If an account exists, you will receive reset instructions.'\r\n      });\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'forgotPassword');\r\n      \r\n      // Still show success for security (don't reveal if email exists)\r\n      setAuthState({\r\n        loading: false,\r\n        success: 'If an account exists, you will receive reset instructions.'\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        message: 'If an account exists, you will receive reset instructions.'\r\n      };\r\n    }\r\n  }, [setAuthState, performanceMonitor, logSecurityEvent]);\r\n\r\n  // Reset password\r\n  const resetPassword = useCallback(async (token, passwordData) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n      \r\n      const response = await authService.resetPassword(token, passwordData);\r\n      \r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Password reset failed');\r\n      }\r\n\r\n      // Log password reset\r\n      logSecurityEvent('password_reset', {\r\n        tokenUsed: token.substring(0, 8) + '...', // Only log partial token for security\r\n        success: true,\r\n        ip: 'client-side'\r\n      });\r\n\r\n      setAuthState({\r\n        loading: false,\r\n        success: response.message || 'Password reset successful'\r\n      });\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'resetPassword');\r\n      \r\n      // Log failed password reset\r\n      logSecurityEvent('password_reset_failed', {\r\n        tokenUsed: token ? token.substring(0, 8) + '...' : 'no-token',\r\n        error: error.message,\r\n        ip: 'client-side'\r\n      });\r\n      \r\n      setAuthState({\r\n        error: error.message || 'Failed to reset password',\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, performanceMonitor, logSecurityEvent]);\r\n\r\n  // Verify email\r\n  const verifyEmail = useCallback(async (token) => {\r\n    try {\r\n      setAuthState({ loading: true, error: null });\r\n      \r\n      const response = await authService.verifyEmail(token);\r\n      \r\n      if (!response.success) {\r\n        throw new Error(response.message || 'Verification failed');\r\n      }\r\n\r\n      // Log email verification\r\n      logSecurityEvent('email_verified', {\r\n        userId: response.data?.id,\r\n        tokenUsed: token.substring(0, 8) + '...',\r\n        success: true,\r\n        email: response.data?.email\r\n      });\r\n\r\n      setAuthState({\r\n        loading: false,\r\n        success: response.message || 'Email verified successfully'\r\n      });\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      performanceMonitor.logError(error, 'verifyEmail');\r\n      \r\n      // Log verification failure\r\n      logSecurityEvent('email_verification_failed', {\r\n        tokenUsed: token.substring(0, 8) + '...',\r\n        error: error.message,\r\n        ip: 'client-side'\r\n      });\r\n      \r\n      setAuthState({\r\n        error: error.message || 'Failed to verify email',\r\n        loading: false\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, [setAuthState, performanceMonitor, logSecurityEvent]);\r\n\r\n  // Check permissions\r\n  const hasPermission = useCallback((permission) => {\r\n    const hasPerm = state.permissions.has(permission) || state.user?.role === 'admin';\r\n    \r\n    // Log permission check for admin/security reviews\r\n    if (process.env.NODE_ENV === 'development') {\r\n      logSecurityEvent('permission_check', {\r\n        permission,\r\n        userId: state.user?.id,\r\n        hasPermission: hasPerm,\r\n        userRole: state.user?.role\r\n      });\r\n    }\r\n    \r\n    return hasPerm;\r\n  }, [state.permissions, state.user, logSecurityEvent]);\r\n\r\n  const hasRole = useCallback((role) => {\r\n    return state.user?.role === role;\r\n  }, [state.user]);\r\n\r\n  const hasAnyRole = useCallback((roles) => {\r\n    return roles.includes(state.user?.role);\r\n  }, [state.user]);\r\n\r\n  // Clear messages\r\n  const clearError = useCallback(() => {\r\n    setAuthState({ error: null });\r\n  }, [setAuthState]);\r\n\r\n  const clearSuccess = useCallback(() => {\r\n    setAuthState({ success: null });\r\n  }, [setAuthState]);\r\n\r\n  // Initialize on mount\r\n  useEffect(() => {\r\n    isMountedRef.current = true;\r\n    initializeAuth();\r\n\r\n    return () => {\r\n      isMountedRef.current = false;\r\n      clearTimers();\r\n      \r\n      // Log component unmount\r\n      logSecurityEvent('auth_context_unmounted', {\r\n        userId: state.user?.id,\r\n        sessionActive: !!state.session,\r\n        unmountTime: new Date().toISOString()\r\n      });\r\n    };\r\n  }, [initializeAuth, clearTimers, logSecurityEvent, state.user, state.session]);\r\n\r\n  // Context value\r\n  const contextValue = useMemo(() => ({\r\n    // State\r\n    user: state.user,\r\n    session: state.session,\r\n    loading: state.loading,\r\n    error: state.error,\r\n    success: state.success,\r\n    sessionExpiresAt: state.sessionExpiresAt,\r\n    \r\n    // Authentication methods\r\n    login,\r\n    register,\r\n    logout,\r\n    \r\n    // Validation methods\r\n    checkUsername,\r\n    checkEmail,\r\n    \r\n    // User management\r\n    updateProfile,\r\n    changePassword,\r\n    forgotPassword,\r\n    resetPassword,\r\n    verifyEmail,\r\n    \r\n    // Permission checks\r\n    hasPermission,\r\n    hasRole,\r\n    hasAnyRole,\r\n    isAuthenticated: !!state.user && !!state.session,\r\n    \r\n    // Security logging\r\n    logSecurityEvent,\r\n    \r\n    // Utility methods\r\n    clearError,\r\n    clearSuccess,\r\n    \r\n    // Performance metrics (for debugging)\r\n    getPerformanceMetrics: () => performanceMonitor.getMetrics()\r\n  }), [\r\n    state,\r\n    login,\r\n    register,\r\n    logout,\r\n    checkUsername,\r\n    checkEmail,\r\n    updateProfile,\r\n    changePassword,\r\n    forgotPassword,\r\n    resetPassword,\r\n    verifyEmail,\r\n    hasPermission,\r\n    hasRole,\r\n    hasAnyRole,\r\n    logSecurityEvent,\r\n    clearError,\r\n    clearSuccess,\r\n    performanceMonitor\r\n  ]);\r\n\r\n  return (\r\n    <AuthErrorBoundary>\r\n      <AuthContext.Provider value={contextValue}>\r\n        {children}\r\n      </AuthContext.Provider>\r\n    </AuthErrorBoundary>\r\n  );\r\n};\r\n\r\n// PropTypes\r\nAuthProvider.propTypes = {\r\n  children: PropTypes.node.isRequired\r\n};\r\n\r\nexport default AuthContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}