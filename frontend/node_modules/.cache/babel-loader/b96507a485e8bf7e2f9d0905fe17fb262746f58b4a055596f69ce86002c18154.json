{"ast":null,"code":"// frontend/src/services/authService.js\n/**\r\n * Enterprise Authentication Service\r\n * \r\n * Production-grade authentication service with comprehensive\r\n * security features, monitoring, and enterprise patterns.\r\n * \r\n * Features:\r\n * - JWT token management with refresh tokens\r\n * - Secure HTTP-only cookie handling\r\n * - Comprehensive error handling\r\n * - Security event tracking\r\n * - Rate limiting awareness\r\n * - Audit logging\r\n * - Session management\r\n * - Token refresh automation\r\n * - Offline detection\r\n * - Network retry logic\r\n * - Cache management\r\n * \r\n * @version 4.0.0\r\n * @author Bugema University IT Support System\r\n */\n\nimport api from './api';\n\n// Constants\nconst TOKEN_REFRESH_THRESHOLD = 5 * 60 * 1000; // 5 minutes before expiry\nconst MAX_RETRY_ATTEMPTS = 3;\nconst RETRY_DELAY = 1000; // 1 second\nconst OFFLINE_CHECK_INTERVAL = 30000; // 30 seconds\n\n// Security event tracking\nclass SecurityMonitor {\n  constructor() {\n    this.events = [];\n    this.maxEvents = 100;\n  }\n  log(eventType, data = {}) {\n    const event = {\n      id: crypto.randomUUID(),\n      timestamp: new Date().toISOString(),\n      type: eventType,\n      ...data,\n      userAgent: navigator.userAgent,\n      url: window.location.href\n    };\n\n    // Development logging\n    if (process.env.NODE_ENV === 'development') {\n      console.group('ðŸ” Security Event');\n      console.log('Type:', eventType);\n      console.log('Data:', data);\n      console.log('Timestamp:', event.timestamp);\n      console.groupEnd();\n    }\n\n    // Store event\n    this.events.unshift(event);\n    if (this.events.length > this.maxEvents) {\n      this.events.pop();\n    }\n\n    // Persist to localStorage for debugging\n    this.persistEvents();\n\n    // Send to security monitoring in production\n    if (process.env.NODE_ENV === 'production') {\n      this.sendToMonitoring(event);\n    }\n  }\n  persistEvents() {\n    try {\n      localStorage.setItem('auth_security_events', JSON.stringify(this.events));\n    } catch (e) {\n      // Silently fail if localStorage is not available\n    }\n  }\n  sendToMonitoring(event) {\n    // Implement with your security monitoring service\n    // Example: Sentry, LogRocket, custom API\n    console.log('[Security Monitor]', event);\n  }\n  getEvents(limit = 50) {\n    return this.events.slice(0, limit);\n  }\n  clearEvents() {\n    this.events = [];\n    localStorage.removeItem('auth_security_events');\n  }\n}\n\n// Initialize security monitor\nconst securityMonitor = new SecurityMonitor();\n\n// Token management\nclass TokenManager {\n  constructor() {\n    this.accessToken = null;\n    this.refreshToken = null;\n    this.tokenExpiry = null;\n    this.isRefreshing = false;\n    this.refreshQueue = [];\n  }\n  async getAccessToken() {\n    // Check if token is expired or about to expire\n    if (this.accessToken && this.tokenExpiry) {\n      const timeToExpiry = this.tokenExpiry - Date.now();\n      if (timeToExpiry < TOKEN_REFRESH_THRESHOLD) {\n        await this.refreshAccessToken();\n      }\n    }\n    return this.accessToken;\n  }\n  async refreshAccessToken() {\n    if (this.isRefreshing) {\n      // Wait for the ongoing refresh to complete\n      return new Promise((resolve, reject) => {\n        this.refreshQueue.push({\n          resolve,\n          reject\n        });\n      });\n    }\n    this.isRefreshing = true;\n    try {\n      const response = await api.post('/auth/refresh', {}, {\n        withCredentials: true // Important for HTTP-only cookies\n      });\n      const {\n        accessToken\n      } = response.data;\n      if (accessToken) {\n        this.setTokens(accessToken, this.refreshToken);\n\n        // Resolve all queued requests\n        this.refreshQueue.forEach(({\n          resolve\n        }) => resolve(accessToken));\n      }\n      return accessToken;\n    } catch (error) {\n      // Reject all queued requests\n      this.refreshQueue.forEach(({\n        reject\n      }) => reject(error));\n      throw error;\n    } finally {\n      this.isRefreshing = false;\n      this.refreshQueue = [];\n    }\n  }\n  setTokens(accessToken, refreshToken) {\n    this.accessToken = accessToken;\n    this.refreshToken = refreshToken;\n\n    // Calculate token expiry (assuming 15 minutes from now)\n    this.tokenExpiry = Date.now() + 15 * 60 * 1000;\n\n    // Store in memory only (cookies are HTTP-only)\n    sessionStorage.setItem('token_refresh_time', Date.now().toString());\n  }\n  clearTokens() {\n    this.accessToken = null;\n    this.refreshToken = null;\n    this.tokenExpiry = null;\n    sessionStorage.removeItem('token_refresh_time');\n  }\n}\n\n// Initialize token manager\nconst tokenManager = new TokenManager();\n\n// Request interceptor\napi.interceptors.request.use(async config => {\n  // Skip token for auth endpoints except logout\n  if (config.url.includes('/auth/') && !config.url.includes('/auth/logout')) {\n    return config;\n  }\n\n  // Add access token if available\n  const accessToken = await tokenManager.getAccessToken();\n  if (accessToken) {\n    config.headers.Authorization = `Bearer ${accessToken}`;\n  }\n\n  // Add request ID for tracking\n  config.headers['X-Request-ID'] = crypto.randomUUID();\n\n  // Add timestamp for monitoring\n  config.metadata = {\n    startTime: Date.now(),\n    url: config.url,\n    method: config.method\n  };\n  return config;\n}, error => {\n  var _error$config;\n  securityMonitor.log('request_interceptor_error', {\n    error: error.message,\n    url: (_error$config = error.config) === null || _error$config === void 0 ? void 0 : _error$config.url\n  });\n  return Promise.reject(error);\n});\n\n// Response interceptor\napi.interceptors.response.use(response => {\n  var _config$metadata;\n  const {\n    config,\n    data\n  } = response;\n  const duration = Date.now() - (((_config$metadata = config.metadata) === null || _config$metadata === void 0 ? void 0 : _config$metadata.startTime) || Date.now());\n\n  // Log successful requests\n  if (config.url.includes('/auth/')) {\n    securityMonitor.log('auth_request_success', {\n      endpoint: config.url,\n      method: config.method,\n      duration: `${duration}ms`,\n      status: response.status\n    });\n  }\n\n  // Handle token in response for login/register\n  if (config.url.includes('/auth/login') || config.url.includes('/auth/register')) {\n    var _data$data;\n    if ((_data$data = data.data) !== null && _data$data !== void 0 && _data$data.accessToken) {\n      tokenManager.setTokens(data.data.accessToken, data.data.refreshToken);\n    }\n  }\n  return response;\n}, async error => {\n  var _config$url;\n  const {\n    config,\n    response\n  } = error;\n  const originalRequest = config;\n\n  // Log failed requests\n  if (config !== null && config !== void 0 && (_config$url = config.url) !== null && _config$url !== void 0 && _config$url.includes('/auth/')) {\n    securityMonitor.log('auth_request_failed', {\n      endpoint: config.url,\n      method: config.method,\n      status: response === null || response === void 0 ? void 0 : response.status,\n      error: error.message,\n      retryCount: originalRequest._retryCount || 0\n    });\n  }\n\n  // Handle 401 - Unauthorized (token expired)\n  if ((response === null || response === void 0 ? void 0 : response.status) === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    try {\n      // Attempt to refresh token\n      await tokenManager.refreshAccessToken();\n\n      // Retry the original request\n      return api(originalRequest);\n    } catch (refreshError) {\n      // Refresh failed, clear tokens and redirect to login\n      tokenManager.clearTokens();\n      window.location.href = '/login?session=expired';\n      return Promise.reject(refreshError);\n    }\n  }\n\n  // Handle 429 - Rate limited\n  if ((response === null || response === void 0 ? void 0 : response.status) === 429) {\n    const retryAfter = response.headers['retry-after'] || 60;\n    securityMonitor.log('rate_limited', {\n      endpoint: config.url,\n      retryAfter,\n      timestamp: new Date().toISOString()\n    });\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve(api(originalRequest));\n      }, retryAfter * 1000);\n    });\n  }\n\n  // Handle network errors with retry logic\n  if (!response && originalRequest._retryCount < MAX_RETRY_ATTEMPTS) {\n    originalRequest._retryCount = (originalRequest._retryCount || 0) + 1;\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve(api(originalRequest));\n      }, RETRY_DELAY * Math.pow(2, originalRequest._retryCount - 1));\n    });\n  }\n  return Promise.reject(error);\n});\n\n// Offline detection\nclass NetworkMonitor {\n  constructor() {\n    this.isOnline = navigator.onLine;\n    this.listeners = [];\n    window.addEventListener('online', () => this.handleOnline());\n    window.addEventListener('offline', () => this.handleOffline());\n\n    // Periodic connectivity check\n    setInterval(() => this.checkConnectivity(), OFFLINE_CHECK_INTERVAL);\n  }\n  handleOnline() {\n    this.isOnline = true;\n    securityMonitor.log('network_online');\n    this.notifyListeners(true);\n  }\n  handleOffline() {\n    this.isOnline = false;\n    securityMonitor.log('network_offline');\n    this.notifyListeners(false);\n  }\n  checkConnectivity() {\n    // Implement custom connectivity check if needed\n    const wasOnline = this.isOnline;\n    this.isOnline = navigator.onLine;\n    if (wasOnline !== this.isOnline) {\n      securityMonitor.log(this.isOnline ? 'network_restored' : 'network_lost');\n      this.notifyListeners(this.isOnline);\n    }\n  }\n  addListener(listener) {\n    this.listeners.push(listener);\n  }\n  notifyListeners(isOnline) {\n    this.listeners.forEach(listener => listener(isOnline));\n  }\n  isConnected() {\n    return this.isOnline;\n  }\n}\n\n// Initialize network monitor\nconst networkMonitor = new NetworkMonitor();\n\n// Main auth service\nconst authService = {\n  /**\r\n   * Register new user with comprehensive validation\r\n   * \r\n   * @param {Object} userData - User registration data\r\n   * @returns {Promise<Object>} Registration response\r\n   */\n  // In authService.js - Update the register function\n  register: async userData => {\n    try {\n      var _userData$firstName, _userData$lastName, _userData$department, _data$user, _data$user2, _data$user3;\n      securityMonitor.log('registration_attempt', {\n        email: userData.email,\n        role: userData.role,\n        hasStudentId: !!userData.studentId\n      });\n\n      // Validate required fields\n      const requiredFields = ['username', 'email', 'password', 'role'];\n      const missingFields = requiredFields.filter(field => !userData[field]);\n      if (missingFields.length > 0) {\n        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n      }\n\n      // Format student ID\n      if (userData.studentId) {\n        userData.studentId = userData.studentId.toUpperCase().trim();\n      }\n\n      // Prepare registration data - MATCHING backend expectations\n      const registrationData = {\n        fullName: userData.username.trim(),\n        // This is the full name from frontend\n        email: userData.email.toLowerCase().trim(),\n        password: userData.password,\n        role: userData.role,\n        firstName: (_userData$firstName = userData.firstName) === null || _userData$firstName === void 0 ? void 0 : _userData$firstName.trim(),\n        lastName: (_userData$lastName = userData.lastName) === null || _userData$lastName === void 0 ? void 0 : _userData$lastName.trim(),\n        phone: userData.phone,\n        department: (_userData$department = userData.department) === null || _userData$department === void 0 ? void 0 : _userData$department.trim(),\n        studentId: userData.studentId,\n        campus: userData.campus || 'BU',\n        yearOfEntry: userData.yearOfEntry,\n        semester: userData.semester,\n        employeeId: userData.employeeId,\n        metadata: {\n          registrationSource: 'web',\n          userAgent: navigator.userAgent,\n          screenResolution: `${window.screen.width}x${window.screen.height}`,\n          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone\n        }\n      };\n      console.log('ðŸ” Sending registration request:', registrationData);\n      const response = await api.post('/auth/register', registrationData);\n      console.log('ðŸ” Registration response:', response);\n      console.log('ðŸ” Response data:', response.data);\n      if (!response.data.success) {\n        console.error('âŒ Backend returned success: false', response.data);\n        throw new Error(response.data.message || 'Registration failed');\n      }\n      const {\n        data\n      } = response.data;\n      securityMonitor.log('registration_success', {\n        userId: (_data$user = data.user) === null || _data$user === void 0 ? void 0 : _data$user.id,\n        email: (_data$user2 = data.user) === null || _data$user2 === void 0 ? void 0 : _data$user2.email,\n        role: (_data$user3 = data.user) === null || _data$user3 === void 0 ? void 0 : _data$user3.role,\n        requiresEmailVerification: data.requiresEmailVerification\n      });\n      return {\n        success: true,\n        message: response.data.message,\n        data: {\n          user: data.user,\n          accessToken: data.accessToken,\n          requiresEmailVerification: data.requiresEmailVerification\n        }\n      };\n    } catch (error) {\n      var _error$response, _error$response2, _error$response3, _error$response4, _error$response5;\n      console.error('ðŸ”¥ REGISTRATION API ERROR DETAILS:');\n      console.error('ðŸ”¥ Error:', error);\n      console.error('ðŸ”¥ Error response:', error.response);\n      console.error('ðŸ”¥ Error status:', (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status);\n      console.error('ðŸ”¥ Error data:', (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.data);\n      console.error('ðŸ”¥ Error config:', error.config);\n      securityMonitor.log('registration_failed', {\n        email: userData === null || userData === void 0 ? void 0 : userData.email,\n        error: error.message,\n        response: (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data,\n        status: (_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status\n      });\n      let errorMessage = 'Registration failed. Please try again.';\n      if ((_error$response5 = error.response) !== null && _error$response5 !== void 0 && _error$response5.data) {\n        const {\n          message,\n          code,\n          errors\n        } = error.response.data;\n        console.error('ðŸ”¥ Backend error details:', {\n          message,\n          code,\n          errors\n        });\n        if (code === 'EMAIL_EXISTS') {\n          errorMessage = 'An account with this email already exists.';\n        } else if (code === 'STUDENT_ID_EXISTS') {\n          errorMessage = 'This student ID is already registered.';\n        } else if (code === 'VALIDATION_ERROR' && errors !== null && errors !== void 0 && errors.length) {\n          errorMessage = errors.map(e => e.message).join('. ');\n        } else if (message) {\n          errorMessage = message;\n        }\n      } else if (error.message.includes('Network Error')) {\n        errorMessage = 'Cannot connect to server. Please check your internet connection.';\n      } else if (error.request) {\n        console.error('ðŸ”¥ No response received:', error.request);\n        errorMessage = 'No response from server. Please try again.';\n      }\n      console.error('ðŸ”¥ Throwing error:', errorMessage);\n      throw new Error(errorMessage);\n    }\n  },\n  /**\r\n   * User login with credentials\r\n   * \r\n   * @param {string} email - User email\r\n   * @param {string} password - User password\r\n   * @param {boolean} rememberMe - Remember login\r\n   * @returns {Promise<Object>} Authentication response\r\n   */\n  login: async (email, password, rememberMe = false) => {\n    try {\n      var _data$user4, _data$user5, _data$user6;\n      securityMonitor.log('login_attempt', {\n        email,\n        rememberMe\n      });\n      if (!email || !password) {\n        throw new Error('Email and password are required');\n      }\n      const response = await api.post('/auth/login', {\n        email: email.toLowerCase().trim(),\n        password: password.trim(),\n        rememberMe\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Login failed');\n      }\n      const {\n        data\n      } = response.data;\n      securityMonitor.log('login_success', {\n        userId: (_data$user4 = data.user) === null || _data$user4 === void 0 ? void 0 : _data$user4.id,\n        email: (_data$user5 = data.user) === null || _data$user5 === void 0 ? void 0 : _data$user5.email,\n        role: (_data$user6 = data.user) === null || _data$user6 === void 0 ? void 0 : _data$user6.role,\n        requiresEmailVerification: data.requiresEmailVerification\n      });\n      return {\n        success: true,\n        message: response.data.message,\n        data: {\n          user: data.user,\n          accessToken: data.accessToken,\n          refreshToken: data.refreshToken,\n          requiresEmailVerification: data.requiresEmailVerification\n        }\n      };\n    } catch (error) {\n      var _error$response6, _error$response7, _error$response7$data, _error$response8;\n      securityMonitor.log('login_failed', {\n        email,\n        error: error.message,\n        status: (_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status,\n        code: (_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : (_error$response7$data = _error$response7.data) === null || _error$response7$data === void 0 ? void 0 : _error$response7$data.code\n      });\n      let errorMessage = 'Login failed. Please check your credentials.';\n      if ((_error$response8 = error.response) !== null && _error$response8 !== void 0 && _error$response8.data) {\n        const {\n          message,\n          code,\n          attemptsLeft,\n          locked\n        } = error.response.data;\n        if (code === 'ACCOUNT_LOCKED') {\n          errorMessage = `Account is locked. Try again in ${error.response.data.lockDuration} minutes.`;\n        } else if (code === 'ACCOUNT_INACTIVE') {\n          errorMessage = 'Account is deactivated. Please contact support.';\n        } else if (code === 'INVALID_CREDENTIALS') {\n          if (attemptsLeft > 0) {\n            errorMessage = `Invalid credentials. ${attemptsLeft} attempts remaining.`;\n          } else if (locked) {\n            errorMessage = 'Account locked due to too many failed attempts.';\n          }\n        } else if (message) {\n          errorMessage = message;\n        }\n      } else if (error.message.includes('Network Error')) {\n        errorMessage = 'Cannot connect to server. Please check your internet connection.';\n      }\n      throw new Error(errorMessage);\n    }\n  },\n  /**\r\n   * Logout user and clear tokens\r\n   * \r\n   * @returns {Promise<Object>} Logout response\r\n   */\n  logout: async () => {\n    try {\n      securityMonitor.log('logout_attempt');\n      await api.post('/auth/logout', {}, {\n        withCredentials: true\n      });\n\n      // Clear local tokens\n      tokenManager.clearTokens();\n\n      // Clear any stored user data\n      sessionStorage.clear();\n      localStorage.removeItem('user_data');\n      securityMonitor.log('logout_success');\n      return {\n        success: true,\n        message: 'Logged out successfully'\n      };\n    } catch (error) {\n      securityMonitor.log('logout_failed', {\n        error: error.message\n      });\n\n      // Still clear tokens even if API call fails\n      tokenManager.clearTokens();\n      sessionStorage.clear();\n      localStorage.removeItem('user_data');\n      return {\n        success: true,\n        message: 'Logged out locally'\n      };\n    }\n  },\n  /**\r\n   * Get current authenticated user\r\n   * \r\n   * @returns {Promise<Object>} Current user data\r\n   */\n  getCurrentUser: async () => {\n    try {\n      const response = await api.get('/auth/me', {\n        withCredentials: true\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Failed to get user data');\n      }\n      return {\n        success: true,\n        data: response.data.data.user\n      };\n    } catch (error) {\n      var _error$response9;\n      securityMonitor.log('get_current_user_failed', {\n        error: error.message\n      });\n      if (((_error$response9 = error.response) === null || _error$response9 === void 0 ? void 0 : _error$response9.status) === 401) {\n        tokenManager.clearTokens();\n        throw new Error('Session expired. Please login again.');\n      }\n      throw new Error('Failed to get user data');\n    }\n  },\n  /**\r\n   * Update user profile\r\n   * \r\n   * @param {Object} updates - Profile updates\r\n   * @returns {Promise<Object>} Updated user data\r\n   */\n  updateProfile: async updates => {\n    try {\n      securityMonitor.log('profile_update_attempt', {\n        fields: Object.keys(updates)\n      });\n      const response = await api.put('/auth/me', updates, {\n        withCredentials: true\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Update failed');\n      }\n      securityMonitor.log('profile_update_success', {\n        fields: Object.keys(updates)\n      });\n      return {\n        success: true,\n        message: response.data.message,\n        data: response.data.data.user\n      };\n    } catch (error) {\n      var _error$response0, _error$response0$data, _error$response0$data2;\n      securityMonitor.log('profile_update_failed', {\n        error: error.message,\n        fields: Object.keys(updates)\n      });\n      let errorMessage = 'Failed to update profile.';\n      if ((_error$response0 = error.response) !== null && _error$response0 !== void 0 && (_error$response0$data = _error$response0.data) !== null && _error$response0$data !== void 0 && (_error$response0$data2 = _error$response0$data.errors) !== null && _error$response0$data2 !== void 0 && _error$response0$data2.length) {\n        errorMessage = error.response.data.errors.map(e => e.message).join('. ');\n      }\n      throw new Error(errorMessage);\n    }\n  },\n  /**\r\n   * Change password for authenticated user\r\n   * \r\n   * @param {string} currentPassword - Current password\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  changePassword: async (currentPassword, newPassword) => {\n    try {\n      securityMonitor.log('password_change_attempt');\n\n      // Validate password strength\n      if (newPassword.length < 8) {\n        throw new Error('Password must be at least 8 characters');\n      }\n      const response = await api.post('/auth/change-password', {\n        currentPassword: currentPassword.trim(),\n        newPassword: newPassword.trim()\n      }, {\n        withCredentials: true\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Password change failed');\n      }\n      securityMonitor.log('password_change_success');\n      return {\n        success: true,\n        message: response.data.message\n      };\n    } catch (error) {\n      var _error$response1, _error$response1$data;\n      securityMonitor.log('password_change_failed', {\n        error: error.message\n      });\n      throw new Error(((_error$response1 = error.response) === null || _error$response1 === void 0 ? void 0 : (_error$response1$data = _error$response1.data) === null || _error$response1$data === void 0 ? void 0 : _error$response1$data.message) || 'Failed to change password');\n    }\n  },\n  /**\r\n   * Request password reset\r\n   * \r\n   * @param {string} email - User email\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  forgotPassword: async email => {\n    try {\n      securityMonitor.log('password_reset_request', {\n        email\n      });\n      const response = await api.post('/auth/forgot-password', {\n        email: email.toLowerCase().trim()\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Request failed');\n      }\n      securityMonitor.log('password_reset_request_success', {\n        email\n      });\n      return {\n        success: true,\n        message: response.data.message\n      };\n    } catch (error) {\n      securityMonitor.log('password_reset_request_failed', {\n        email,\n        error: error.message\n      });\n\n      // Always return success for security (don't reveal if email exists)\n      return {\n        success: true,\n        message: 'If an account exists with this email, you will receive reset instructions.'\n      };\n    }\n  },\n  /**\r\n   * Reset password with token\r\n   * \r\n   * @param {string} token - Reset token\r\n   * @param {string} userId - User ID\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  resetPassword: async (token, userId, newPassword) => {\n    try {\n      securityMonitor.log('password_reset_attempt', {\n        token: token.substring(0, 10) + '...',\n        userId\n      });\n      if (newPassword.length < 8) {\n        throw new Error('Password must be at least 8 characters');\n      }\n      const response = await api.post('/auth/reset-password', {\n        token: token.trim(),\n        userId: userId.trim(),\n        password: newPassword.trim()\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Password reset failed');\n      }\n      securityMonitor.log('password_reset_success', {\n        userId\n      });\n      return {\n        success: true,\n        message: response.data.message\n      };\n    } catch (error) {\n      var _error$response10, _error$response10$dat;\n      securityMonitor.log('password_reset_failed', {\n        userId,\n        error: error.message\n      });\n      throw new Error(((_error$response10 = error.response) === null || _error$response10 === void 0 ? void 0 : (_error$response10$dat = _error$response10.data) === null || _error$response10$dat === void 0 ? void 0 : _error$response10$dat.message) || 'Failed to reset password');\n    }\n  },\n  /**\r\n   * Verify email with token\r\n   * \r\n   * @param {string} token - Verification token\r\n   * @param {string} userId - User ID\r\n   * @returns {Promise<Object>} Success response\r\n   */\n  verifyEmail: async (token, userId) => {\n    try {\n      securityMonitor.log('email_verification_attempt', {\n        userId\n      });\n      const response = await api.post('/auth/verify-email', {\n        token: token.trim(),\n        userId: userId.trim()\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Verification failed');\n      }\n      securityMonitor.log('email_verification_success', {\n        userId\n      });\n      return {\n        success: true,\n        message: response.data.message\n      };\n    } catch (error) {\n      var _error$response11, _error$response11$dat;\n      securityMonitor.log('email_verification_failed', {\n        userId,\n        error: error.message\n      });\n      throw new Error(((_error$response11 = error.response) === null || _error$response11 === void 0 ? void 0 : (_error$response11$dat = _error$response11.data) === null || _error$response11$dat === void 0 ? void 0 : _error$response11$dat.message) || 'Failed to verify email');\n    }\n  },\n  /**\r\n   * Resend verification email\r\n   * \r\n   * @returns {Promise<Object>} Success response\r\n   */\n  resendVerification: async () => {\n    try {\n      securityMonitor.log('verification_resend_attempt');\n      const response = await api.post('/auth/resend-verification', {}, {\n        withCredentials: true\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Failed to resend verification');\n      }\n      securityMonitor.log('verification_resend_success');\n      return {\n        success: true,\n        message: response.data.message\n      };\n    } catch (error) {\n      var _error$response12, _error$response12$dat;\n      securityMonitor.log('verification_resend_failed', {\n        error: error.message\n      });\n      throw new Error(((_error$response12 = error.response) === null || _error$response12 === void 0 ? void 0 : (_error$response12$dat = _error$response12.data) === null || _error$response12$dat === void 0 ? void 0 : _error$response12$dat.message) || 'Failed to resend verification');\n    }\n  },\n  /**\r\n   * Check if email is available\r\n   * \r\n   * @param {string} email - Email to check\r\n   * @returns {Promise<Object>} Availability result\r\n   */\n  checkEmail: async email => {\n    try {\n      const response = await api.post('/auth/check-email', {\n        email: email.toLowerCase().trim()\n      });\n      return {\n        success: true,\n        data: response.data.data\n      };\n    } catch (error) {\n      securityMonitor.log('check_email_failed', {\n        email,\n        error: error.message\n      });\n      throw new Error('Failed to check email availability');\n    }\n  },\n  /**\r\n   * Check if username is available\r\n   * \r\n   * @param {string} username - Username to check\r\n   * @returns {Promise<Object>} Availability result\r\n   */\n  checkUsername: async username => {\n    try {\n      const response = await api.post('/auth/check-username', {\n        username: username.trim()\n      });\n      return {\n        success: true,\n        data: response.data.data\n      };\n    } catch (error) {\n      securityMonitor.log('check_username_failed', {\n        username,\n        error: error.message\n      });\n      throw new Error('Failed to check username availability');\n    }\n  },\n  /**\r\n   * Get authentication statistics (admin only)\r\n   * \r\n   * @returns {Promise<Object>} Authentication statistics\r\n   */\n  getAuthStats: async () => {\n    try {\n      const response = await api.get('/auth/stats', {\n        withCredentials: true\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.message || 'Failed to get stats');\n      }\n      return {\n        success: true,\n        data: response.data.data\n      };\n    } catch (error) {\n      securityMonitor.log('get_auth_stats_failed', {\n        error: error.message\n      });\n      throw new Error('Failed to get authentication statistics');\n    }\n  },\n  /**\r\n   * Get security events (for debugging/admin)\r\n   * \r\n   * @param {number} limit - Maximum number of events\r\n   * @returns {Array} Security events\r\n   */\n  getSecurityEvents: (limit = 50) => {\n    return securityMonitor.getEvents(limit);\n  },\n  /**\r\n   * Clear security events\r\n   */\n  clearSecurityEvents: () => {\n    securityMonitor.clearEvents();\n  },\n  /**\r\n   * Check if user is authenticated\r\n   * \r\n   * @returns {Promise<boolean>} Authentication status\r\n   */\n  isAuthenticated: async () => {\n    try {\n      await this.getCurrentUser();\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n  /**\r\n   * Check network connectivity\r\n   * \r\n   * @returns {boolean} Network status\r\n   */\n  isOnline: () => {\n    return networkMonitor.isConnected();\n  },\n  /**\r\n   * Add network status listener\r\n   * \r\n   * @param {Function} listener - Listener function\r\n   */\n  onNetworkChange: listener => {\n    networkMonitor.addListener(listener);\n  }\n};\nexport default authService;","map":{"version":3,"names":["api","TOKEN_REFRESH_THRESHOLD","MAX_RETRY_ATTEMPTS","RETRY_DELAY","OFFLINE_CHECK_INTERVAL","SecurityMonitor","constructor","events","maxEvents","log","eventType","data","event","id","crypto","randomUUID","timestamp","Date","toISOString","type","userAgent","navigator","url","window","location","href","process","env","NODE_ENV","console","group","groupEnd","unshift","length","pop","persistEvents","sendToMonitoring","localStorage","setItem","JSON","stringify","e","getEvents","limit","slice","clearEvents","removeItem","securityMonitor","TokenManager","accessToken","refreshToken","tokenExpiry","isRefreshing","refreshQueue","getAccessToken","timeToExpiry","now","refreshAccessToken","Promise","resolve","reject","push","response","post","withCredentials","setTokens","forEach","error","sessionStorage","toString","clearTokens","tokenManager","interceptors","request","use","config","includes","headers","Authorization","metadata","startTime","method","_error$config","message","_config$metadata","duration","endpoint","status","_data$data","_config$url","originalRequest","retryCount","_retryCount","_retry","refreshError","retryAfter","setTimeout","Math","pow","NetworkMonitor","isOnline","onLine","listeners","addEventListener","handleOnline","handleOffline","setInterval","checkConnectivity","notifyListeners","wasOnline","addListener","listener","isConnected","networkMonitor","authService","register","userData","_userData$firstName","_userData$lastName","_userData$department","_data$user","_data$user2","_data$user3","email","role","hasStudentId","studentId","requiredFields","missingFields","filter","field","Error","join","toUpperCase","trim","registrationData","fullName","username","toLowerCase","password","firstName","lastName","phone","department","campus","yearOfEntry","semester","employeeId","registrationSource","screenResolution","screen","width","height","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","success","userId","user","requiresEmailVerification","_error$response","_error$response2","_error$response3","_error$response4","_error$response5","errorMessage","code","errors","map","login","rememberMe","_data$user4","_data$user5","_data$user6","_error$response6","_error$response7","_error$response7$data","_error$response8","attemptsLeft","locked","lockDuration","logout","clear","getCurrentUser","get","_error$response9","updateProfile","updates","fields","Object","keys","put","_error$response0","_error$response0$data","_error$response0$data2","changePassword","currentPassword","newPassword","_error$response1","_error$response1$data","forgotPassword","resetPassword","token","substring","_error$response10","_error$response10$dat","verifyEmail","_error$response11","_error$response11$dat","resendVerification","_error$response12","_error$response12$dat","checkEmail","checkUsername","getAuthStats","getSecurityEvents","clearSecurityEvents","isAuthenticated","onNetworkChange"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/services/authService.js"],"sourcesContent":["// frontend/src/services/authService.js\r\n/**\r\n * Enterprise Authentication Service\r\n * \r\n * Production-grade authentication service with comprehensive\r\n * security features, monitoring, and enterprise patterns.\r\n * \r\n * Features:\r\n * - JWT token management with refresh tokens\r\n * - Secure HTTP-only cookie handling\r\n * - Comprehensive error handling\r\n * - Security event tracking\r\n * - Rate limiting awareness\r\n * - Audit logging\r\n * - Session management\r\n * - Token refresh automation\r\n * - Offline detection\r\n * - Network retry logic\r\n * - Cache management\r\n * \r\n * @version 4.0.0\r\n * @author Bugema University IT Support System\r\n */\r\n\r\nimport api from './api';\r\n\r\n// Constants\r\nconst TOKEN_REFRESH_THRESHOLD = 5 * 60 * 1000; // 5 minutes before expiry\r\nconst MAX_RETRY_ATTEMPTS = 3;\r\nconst RETRY_DELAY = 1000; // 1 second\r\nconst OFFLINE_CHECK_INTERVAL = 30000; // 30 seconds\r\n\r\n// Security event tracking\r\nclass SecurityMonitor {\r\n  constructor() {\r\n    this.events = [];\r\n    this.maxEvents = 100;\r\n  }\r\n\r\n  log(eventType, data = {}) {\r\n    const event = {\r\n      id: crypto.randomUUID(),\r\n      timestamp: new Date().toISOString(),\r\n      type: eventType,\r\n      ...data,\r\n      userAgent: navigator.userAgent,\r\n      url: window.location.href\r\n    };\r\n\r\n    // Development logging\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.group('ðŸ” Security Event');\r\n      console.log('Type:', eventType);\r\n      console.log('Data:', data);\r\n      console.log('Timestamp:', event.timestamp);\r\n      console.groupEnd();\r\n    }\r\n\r\n    // Store event\r\n    this.events.unshift(event);\r\n    if (this.events.length > this.maxEvents) {\r\n      this.events.pop();\r\n    }\r\n\r\n    // Persist to localStorage for debugging\r\n    this.persistEvents();\r\n\r\n    // Send to security monitoring in production\r\n    if (process.env.NODE_ENV === 'production') {\r\n      this.sendToMonitoring(event);\r\n    }\r\n  }\r\n\r\n  persistEvents() {\r\n    try {\r\n      localStorage.setItem('auth_security_events', JSON.stringify(this.events));\r\n    } catch (e) {\r\n      // Silently fail if localStorage is not available\r\n    }\r\n  }\r\n\r\n  sendToMonitoring(event) {\r\n    // Implement with your security monitoring service\r\n    // Example: Sentry, LogRocket, custom API\r\n    console.log('[Security Monitor]', event);\r\n  }\r\n\r\n  getEvents(limit = 50) {\r\n    return this.events.slice(0, limit);\r\n  }\r\n\r\n  clearEvents() {\r\n    this.events = [];\r\n    localStorage.removeItem('auth_security_events');\r\n  }\r\n}\r\n\r\n// Initialize security monitor\r\nconst securityMonitor = new SecurityMonitor();\r\n\r\n// Token management\r\nclass TokenManager {\r\n  constructor() {\r\n    this.accessToken = null;\r\n    this.refreshToken = null;\r\n    this.tokenExpiry = null;\r\n    this.isRefreshing = false;\r\n    this.refreshQueue = [];\r\n  }\r\n\r\n  async getAccessToken() {\r\n    // Check if token is expired or about to expire\r\n    if (this.accessToken && this.tokenExpiry) {\r\n      const timeToExpiry = this.tokenExpiry - Date.now();\r\n      \r\n      if (timeToExpiry < TOKEN_REFRESH_THRESHOLD) {\r\n        await this.refreshAccessToken();\r\n      }\r\n    }\r\n    \r\n    return this.accessToken;\r\n  }\r\n\r\n  async refreshAccessToken() {\r\n    if (this.isRefreshing) {\r\n      // Wait for the ongoing refresh to complete\r\n      return new Promise((resolve, reject) => {\r\n        this.refreshQueue.push({ resolve, reject });\r\n      });\r\n    }\r\n\r\n    this.isRefreshing = true;\r\n\r\n    try {\r\n      const response = await api.post('/auth/refresh', {}, {\r\n        withCredentials: true // Important for HTTP-only cookies\r\n      });\r\n\r\n      const { accessToken } = response.data;\r\n      \r\n      if (accessToken) {\r\n        this.setTokens(accessToken, this.refreshToken);\r\n        \r\n        // Resolve all queued requests\r\n        this.refreshQueue.forEach(({ resolve }) => resolve(accessToken));\r\n      }\r\n      \r\n      return accessToken;\r\n    } catch (error) {\r\n      // Reject all queued requests\r\n      this.refreshQueue.forEach(({ reject }) => reject(error));\r\n      throw error;\r\n    } finally {\r\n      this.isRefreshing = false;\r\n      this.refreshQueue = [];\r\n    }\r\n  }\r\n\r\n  setTokens(accessToken, refreshToken) {\r\n    this.accessToken = accessToken;\r\n    this.refreshToken = refreshToken;\r\n    \r\n    // Calculate token expiry (assuming 15 minutes from now)\r\n    this.tokenExpiry = Date.now() + 15 * 60 * 1000;\r\n    \r\n    // Store in memory only (cookies are HTTP-only)\r\n    sessionStorage.setItem('token_refresh_time', Date.now().toString());\r\n  }\r\n\r\n  clearTokens() {\r\n    this.accessToken = null;\r\n    this.refreshToken = null;\r\n    this.tokenExpiry = null;\r\n    sessionStorage.removeItem('token_refresh_time');\r\n  }\r\n}\r\n\r\n// Initialize token manager\r\nconst tokenManager = new TokenManager();\r\n\r\n// Request interceptor\r\napi.interceptors.request.use(\r\n  async (config) => {\r\n    // Skip token for auth endpoints except logout\r\n    if (config.url.includes('/auth/') && !config.url.includes('/auth/logout')) {\r\n      return config;\r\n    }\r\n\r\n    // Add access token if available\r\n    const accessToken = await tokenManager.getAccessToken();\r\n    if (accessToken) {\r\n      config.headers.Authorization = `Bearer ${accessToken}`;\r\n    }\r\n\r\n    // Add request ID for tracking\r\n    config.headers['X-Request-ID'] = crypto.randomUUID();\r\n    \r\n    // Add timestamp for monitoring\r\n    config.metadata = { \r\n      startTime: Date.now(),\r\n      url: config.url,\r\n      method: config.method \r\n    };\r\n\r\n    return config;\r\n  },\r\n  (error) => {\r\n    securityMonitor.log('request_interceptor_error', {\r\n      error: error.message,\r\n      url: error.config?.url\r\n    });\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Response interceptor\r\napi.interceptors.response.use(\r\n  (response) => {\r\n    const { config, data } = response;\r\n    const duration = Date.now() - (config.metadata?.startTime || Date.now());\r\n\r\n    // Log successful requests\r\n    if (config.url.includes('/auth/')) {\r\n      securityMonitor.log('auth_request_success', {\r\n        endpoint: config.url,\r\n        method: config.method,\r\n        duration: `${duration}ms`,\r\n        status: response.status\r\n      });\r\n    }\r\n\r\n    // Handle token in response for login/register\r\n    if (config.url.includes('/auth/login') || config.url.includes('/auth/register')) {\r\n      if (data.data?.accessToken) {\r\n        tokenManager.setTokens(data.data.accessToken, data.data.refreshToken);\r\n      }\r\n    }\r\n\r\n    return response;\r\n  },\r\n  async (error) => {\r\n    const { config, response } = error;\r\n    const originalRequest = config;\r\n\r\n    // Log failed requests\r\n    if (config?.url?.includes('/auth/')) {\r\n      securityMonitor.log('auth_request_failed', {\r\n        endpoint: config.url,\r\n        method: config.method,\r\n        status: response?.status,\r\n        error: error.message,\r\n        retryCount: originalRequest._retryCount || 0\r\n      });\r\n    }\r\n\r\n    // Handle 401 - Unauthorized (token expired)\r\n    if (response?.status === 401 && !originalRequest._retry) {\r\n      originalRequest._retry = true;\r\n      \r\n      try {\r\n        // Attempt to refresh token\r\n        await tokenManager.refreshAccessToken();\r\n        \r\n        // Retry the original request\r\n        return api(originalRequest);\r\n      } catch (refreshError) {\r\n        // Refresh failed, clear tokens and redirect to login\r\n        tokenManager.clearTokens();\r\n        window.location.href = '/login?session=expired';\r\n        return Promise.reject(refreshError);\r\n      }\r\n    }\r\n\r\n    // Handle 429 - Rate limited\r\n    if (response?.status === 429) {\r\n      const retryAfter = response.headers['retry-after'] || 60;\r\n      securityMonitor.log('rate_limited', {\r\n        endpoint: config.url,\r\n        retryAfter,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n          resolve(api(originalRequest));\r\n        }, retryAfter * 1000);\r\n      });\r\n    }\r\n\r\n    // Handle network errors with retry logic\r\n    if (!response && originalRequest._retryCount < MAX_RETRY_ATTEMPTS) {\r\n      originalRequest._retryCount = (originalRequest._retryCount || 0) + 1;\r\n      \r\n      return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n          resolve(api(originalRequest));\r\n        }, RETRY_DELAY * Math.pow(2, originalRequest._retryCount - 1));\r\n      });\r\n    }\r\n\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Offline detection\r\nclass NetworkMonitor {\r\n  constructor() {\r\n    this.isOnline = navigator.onLine;\r\n    this.listeners = [];\r\n    \r\n    window.addEventListener('online', () => this.handleOnline());\r\n    window.addEventListener('offline', () => this.handleOffline());\r\n    \r\n    // Periodic connectivity check\r\n    setInterval(() => this.checkConnectivity(), OFFLINE_CHECK_INTERVAL);\r\n  }\r\n\r\n  handleOnline() {\r\n    this.isOnline = true;\r\n    securityMonitor.log('network_online');\r\n    this.notifyListeners(true);\r\n  }\r\n\r\n  handleOffline() {\r\n    this.isOnline = false;\r\n    securityMonitor.log('network_offline');\r\n    this.notifyListeners(false);\r\n  }\r\n\r\n  checkConnectivity() {\r\n    // Implement custom connectivity check if needed\r\n    const wasOnline = this.isOnline;\r\n    this.isOnline = navigator.onLine;\r\n    \r\n    if (wasOnline !== this.isOnline) {\r\n      securityMonitor.log(this.isOnline ? 'network_restored' : 'network_lost');\r\n      this.notifyListeners(this.isOnline);\r\n    }\r\n  }\r\n\r\n  addListener(listener) {\r\n    this.listeners.push(listener);\r\n  }\r\n\r\n  notifyListeners(isOnline) {\r\n    this.listeners.forEach(listener => listener(isOnline));\r\n  }\r\n\r\n  isConnected() {\r\n    return this.isOnline;\r\n  }\r\n}\r\n\r\n// Initialize network monitor\r\nconst networkMonitor = new NetworkMonitor();\r\n\r\n// Main auth service\r\nconst authService = {\r\n  /**\r\n   * Register new user with comprehensive validation\r\n   * \r\n   * @param {Object} userData - User registration data\r\n   * @returns {Promise<Object>} Registration response\r\n   */\r\n// In authService.js - Update the register function\r\nregister: async (userData) => {\r\n  try {\r\n    securityMonitor.log('registration_attempt', {\r\n      email: userData.email,\r\n      role: userData.role,\r\n      hasStudentId: !!userData.studentId\r\n    });\r\n\r\n    // Validate required fields\r\n    const requiredFields = ['username', 'email', 'password', 'role'];\r\n    const missingFields = requiredFields.filter(field => !userData[field]);\r\n    \r\n    if (missingFields.length > 0) {\r\n      throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\r\n    }\r\n\r\n    // Format student ID\r\n    if (userData.studentId) {\r\n      userData.studentId = userData.studentId.toUpperCase().trim();\r\n    }\r\n\r\n    // Prepare registration data - MATCHING backend expectations\r\n    const registrationData = {\r\n      fullName: userData.username.trim(), // This is the full name from frontend\r\n      email: userData.email.toLowerCase().trim(),\r\n      password: userData.password,\r\n      role: userData.role,\r\n      firstName: userData.firstName?.trim(),\r\n      lastName: userData.lastName?.trim(),\r\n      phone: userData.phone,\r\n      department: userData.department?.trim(),\r\n      studentId: userData.studentId,\r\n      campus: userData.campus || 'BU',\r\n      yearOfEntry: userData.yearOfEntry,\r\n      semester: userData.semester,\r\n      employeeId: userData.employeeId,\r\n      metadata: {\r\n        registrationSource: 'web',\r\n        userAgent: navigator.userAgent,\r\n        screenResolution: `${window.screen.width}x${window.screen.height}`,\r\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone\r\n      }\r\n    };\r\n\r\n    console.log('ðŸ” Sending registration request:', registrationData);\r\n    \r\n    const response = await api.post('/auth/register', registrationData);\r\n    \r\n    console.log('ðŸ” Registration response:', response);\r\n    console.log('ðŸ” Response data:', response.data);\r\n    \r\n    if (!response.data.success) {\r\n      console.error('âŒ Backend returned success: false', response.data);\r\n      throw new Error(response.data.message || 'Registration failed');\r\n    }\r\n\r\n    const { data } = response.data;\r\n\r\n    securityMonitor.log('registration_success', {\r\n      userId: data.user?.id,\r\n      email: data.user?.email,\r\n      role: data.user?.role,\r\n      requiresEmailVerification: data.requiresEmailVerification\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      message: response.data.message,\r\n      data: {\r\n        user: data.user,\r\n        accessToken: data.accessToken,\r\n        requiresEmailVerification: data.requiresEmailVerification\r\n      }\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('ðŸ”¥ REGISTRATION API ERROR DETAILS:');\r\n    console.error('ðŸ”¥ Error:', error);\r\n    console.error('ðŸ”¥ Error response:', error.response);\r\n    console.error('ðŸ”¥ Error status:', error.response?.status);\r\n    console.error('ðŸ”¥ Error data:', error.response?.data);\r\n    console.error('ðŸ”¥ Error config:', error.config);\r\n    \r\n    securityMonitor.log('registration_failed', {\r\n      email: userData?.email,\r\n      error: error.message,\r\n      response: error.response?.data,\r\n      status: error.response?.status\r\n    });\r\n\r\n    let errorMessage = 'Registration failed. Please try again.';\r\n    \r\n    if (error.response?.data) {\r\n      const { message, code, errors } = error.response.data;\r\n      console.error('ðŸ”¥ Backend error details:', { message, code, errors });\r\n      \r\n      if (code === 'EMAIL_EXISTS') {\r\n        errorMessage = 'An account with this email already exists.';\r\n      } else if (code === 'STUDENT_ID_EXISTS') {\r\n        errorMessage = 'This student ID is already registered.';\r\n      } else if (code === 'VALIDATION_ERROR' && errors?.length) {\r\n        errorMessage = errors.map(e => e.message).join('. ');\r\n      } else if (message) {\r\n        errorMessage = message;\r\n      }\r\n    } else if (error.message.includes('Network Error')) {\r\n      errorMessage = 'Cannot connect to server. Please check your internet connection.';\r\n    } else if (error.request) {\r\n      console.error('ðŸ”¥ No response received:', error.request);\r\n      errorMessage = 'No response from server. Please try again.';\r\n    }\r\n\r\n    console.error('ðŸ”¥ Throwing error:', errorMessage);\r\n    throw new Error(errorMessage);\r\n  }\r\n},\r\n\r\n  /**\r\n   * User login with credentials\r\n   * \r\n   * @param {string} email - User email\r\n   * @param {string} password - User password\r\n   * @param {boolean} rememberMe - Remember login\r\n   * @returns {Promise<Object>} Authentication response\r\n   */\r\n  login: async (email, password, rememberMe = false) => {\r\n    try {\r\n      securityMonitor.log('login_attempt', { email, rememberMe });\r\n\r\n      if (!email || !password) {\r\n        throw new Error('Email and password are required');\r\n      }\r\n\r\n      const response = await api.post('/auth/login', {\r\n        email: email.toLowerCase().trim(),\r\n        password: password.trim(),\r\n        rememberMe\r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Login failed');\r\n      }\r\n\r\n      const { data } = response.data;\r\n\r\n      securityMonitor.log('login_success', {\r\n        userId: data.user?.id,\r\n        email: data.user?.email,\r\n        role: data.user?.role,\r\n        requiresEmailVerification: data.requiresEmailVerification\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message,\r\n        data: {\r\n          user: data.user,\r\n          accessToken: data.accessToken,\r\n          refreshToken: data.refreshToken,\r\n          requiresEmailVerification: data.requiresEmailVerification\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('login_failed', {\r\n        email,\r\n        error: error.message,\r\n        status: error.response?.status,\r\n        code: error.response?.data?.code\r\n      });\r\n\r\n      let errorMessage = 'Login failed. Please check your credentials.';\r\n      \r\n      if (error.response?.data) {\r\n        const { message, code, attemptsLeft, locked } = error.response.data;\r\n        \r\n        if (code === 'ACCOUNT_LOCKED') {\r\n          errorMessage = `Account is locked. Try again in ${error.response.data.lockDuration} minutes.`;\r\n        } else if (code === 'ACCOUNT_INACTIVE') {\r\n          errorMessage = 'Account is deactivated. Please contact support.';\r\n        } else if (code === 'INVALID_CREDENTIALS') {\r\n          if (attemptsLeft > 0) {\r\n            errorMessage = `Invalid credentials. ${attemptsLeft} attempts remaining.`;\r\n          } else if (locked) {\r\n            errorMessage = 'Account locked due to too many failed attempts.';\r\n          }\r\n        } else if (message) {\r\n          errorMessage = message;\r\n        }\r\n      } else if (error.message.includes('Network Error')) {\r\n        errorMessage = 'Cannot connect to server. Please check your internet connection.';\r\n      }\r\n\r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Logout user and clear tokens\r\n   * \r\n   * @returns {Promise<Object>} Logout response\r\n   */\r\n  logout: async () => {\r\n    try {\r\n      securityMonitor.log('logout_attempt');\r\n\r\n      await api.post('/auth/logout', {}, { withCredentials: true });\r\n\r\n      // Clear local tokens\r\n      tokenManager.clearTokens();\r\n      \r\n      // Clear any stored user data\r\n      sessionStorage.clear();\r\n      localStorage.removeItem('user_data');\r\n\r\n      securityMonitor.log('logout_success');\r\n\r\n      return {\r\n        success: true,\r\n        message: 'Logged out successfully'\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('logout_failed', { error: error.message });\r\n      \r\n      // Still clear tokens even if API call fails\r\n      tokenManager.clearTokens();\r\n      sessionStorage.clear();\r\n      localStorage.removeItem('user_data');\r\n\r\n      return {\r\n        success: true,\r\n        message: 'Logged out locally'\r\n      };\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get current authenticated user\r\n   * \r\n   * @returns {Promise<Object>} Current user data\r\n   */\r\n  getCurrentUser: async () => {\r\n    try {\r\n      const response = await api.get('/auth/me', { withCredentials: true });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Failed to get user data');\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        data: response.data.data.user\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('get_current_user_failed', { error: error.message });\r\n\r\n      if (error.response?.status === 401) {\r\n        tokenManager.clearTokens();\r\n        throw new Error('Session expired. Please login again.');\r\n      }\r\n\r\n      throw new Error('Failed to get user data');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update user profile\r\n   * \r\n   * @param {Object} updates - Profile updates\r\n   * @returns {Promise<Object>} Updated user data\r\n   */\r\n  updateProfile: async (updates) => {\r\n    try {\r\n      securityMonitor.log('profile_update_attempt', { \r\n        fields: Object.keys(updates) \r\n      });\r\n\r\n      const response = await api.put('/auth/me', updates, { \r\n        withCredentials: true \r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Update failed');\r\n      }\r\n\r\n      securityMonitor.log('profile_update_success', { \r\n        fields: Object.keys(updates) \r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message,\r\n        data: response.data.data.user\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('profile_update_failed', { \r\n        error: error.message,\r\n        fields: Object.keys(updates)\r\n      });\r\n\r\n      let errorMessage = 'Failed to update profile.';\r\n      \r\n      if (error.response?.data?.errors?.length) {\r\n        errorMessage = error.response.data.errors.map(e => e.message).join('. ');\r\n      }\r\n\r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Change password for authenticated user\r\n   * \r\n   * @param {string} currentPassword - Current password\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  changePassword: async (currentPassword, newPassword) => {\r\n    try {\r\n      securityMonitor.log('password_change_attempt');\r\n\r\n      // Validate password strength\r\n      if (newPassword.length < 8) {\r\n        throw new Error('Password must be at least 8 characters');\r\n      }\r\n\r\n      const response = await api.post('/auth/change-password', {\r\n        currentPassword: currentPassword.trim(),\r\n        newPassword: newPassword.trim()\r\n      }, { withCredentials: true });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Password change failed');\r\n      }\r\n\r\n      securityMonitor.log('password_change_success');\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('password_change_failed', { error: error.message });\r\n      throw new Error(error.response?.data?.message || 'Failed to change password');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Request password reset\r\n   * \r\n   * @param {string} email - User email\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  forgotPassword: async (email) => {\r\n    try {\r\n      securityMonitor.log('password_reset_request', { email });\r\n\r\n      const response = await api.post('/auth/forgot-password', {\r\n        email: email.toLowerCase().trim()\r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Request failed');\r\n      }\r\n\r\n      securityMonitor.log('password_reset_request_success', { email });\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('password_reset_request_failed', { \r\n        email,\r\n        error: error.message \r\n      });\r\n\r\n      // Always return success for security (don't reveal if email exists)\r\n      return {\r\n        success: true,\r\n        message: 'If an account exists with this email, you will receive reset instructions.'\r\n      };\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Reset password with token\r\n   * \r\n   * @param {string} token - Reset token\r\n   * @param {string} userId - User ID\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  resetPassword: async (token, userId, newPassword) => {\r\n    try {\r\n      securityMonitor.log('password_reset_attempt', { \r\n        token: token.substring(0, 10) + '...',\r\n        userId \r\n      });\r\n\r\n      if (newPassword.length < 8) {\r\n        throw new Error('Password must be at least 8 characters');\r\n      }\r\n\r\n      const response = await api.post('/auth/reset-password', {\r\n        token: token.trim(),\r\n        userId: userId.trim(),\r\n        password: newPassword.trim()\r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Password reset failed');\r\n      }\r\n\r\n      securityMonitor.log('password_reset_success', { userId });\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('password_reset_failed', { \r\n        userId,\r\n        error: error.message \r\n      });\r\n\r\n      throw new Error(error.response?.data?.message || 'Failed to reset password');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Verify email with token\r\n   * \r\n   * @param {string} token - Verification token\r\n   * @param {string} userId - User ID\r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  verifyEmail: async (token, userId) => {\r\n    try {\r\n      securityMonitor.log('email_verification_attempt', { userId });\r\n\r\n      const response = await api.post('/auth/verify-email', {\r\n        token: token.trim(),\r\n        userId: userId.trim()\r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Verification failed');\r\n      }\r\n\r\n      securityMonitor.log('email_verification_success', { userId });\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('email_verification_failed', { \r\n        userId,\r\n        error: error.message \r\n      });\r\n\r\n      throw new Error(error.response?.data?.message || 'Failed to verify email');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Resend verification email\r\n   * \r\n   * @returns {Promise<Object>} Success response\r\n   */\r\n  resendVerification: async () => {\r\n    try {\r\n      securityMonitor.log('verification_resend_attempt');\r\n\r\n      const response = await api.post('/auth/resend-verification', {}, { \r\n        withCredentials: true \r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Failed to resend verification');\r\n      }\r\n\r\n      securityMonitor.log('verification_resend_success');\r\n\r\n      return {\r\n        success: true,\r\n        message: response.data.message\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('verification_resend_failed', { error: error.message });\r\n      throw new Error(error.response?.data?.message || 'Failed to resend verification');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check if email is available\r\n   * \r\n   * @param {string} email - Email to check\r\n   * @returns {Promise<Object>} Availability result\r\n   */\r\n  checkEmail: async (email) => {\r\n    try {\r\n      const response = await api.post('/auth/check-email', {\r\n        email: email.toLowerCase().trim()\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        data: response.data.data\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('check_email_failed', { email, error: error.message });\r\n      throw new Error('Failed to check email availability');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check if username is available\r\n   * \r\n   * @param {string} username - Username to check\r\n   * @returns {Promise<Object>} Availability result\r\n   */\r\n  checkUsername: async (username) => {\r\n    try {\r\n      const response = await api.post('/auth/check-username', {\r\n        username: username.trim()\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        data: response.data.data\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('check_username_failed', { username, error: error.message });\r\n      throw new Error('Failed to check username availability');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get authentication statistics (admin only)\r\n   * \r\n   * @returns {Promise<Object>} Authentication statistics\r\n   */\r\n  getAuthStats: async () => {\r\n    try {\r\n      const response = await api.get('/auth/stats', { withCredentials: true });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.message || 'Failed to get stats');\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        data: response.data.data\r\n      };\r\n\r\n    } catch (error) {\r\n      securityMonitor.log('get_auth_stats_failed', { error: error.message });\r\n      throw new Error('Failed to get authentication statistics');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get security events (for debugging/admin)\r\n   * \r\n   * @param {number} limit - Maximum number of events\r\n   * @returns {Array} Security events\r\n   */\r\n  getSecurityEvents: (limit = 50) => {\r\n    return securityMonitor.getEvents(limit);\r\n  },\r\n\r\n  /**\r\n   * Clear security events\r\n   */\r\n  clearSecurityEvents: () => {\r\n    securityMonitor.clearEvents();\r\n  },\r\n\r\n  /**\r\n   * Check if user is authenticated\r\n   * \r\n   * @returns {Promise<boolean>} Authentication status\r\n   */\r\n  isAuthenticated: async () => {\r\n    try {\r\n      await this.getCurrentUser();\r\n      return true;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check network connectivity\r\n   * \r\n   * @returns {boolean} Network status\r\n   */\r\n  isOnline: () => {\r\n    return networkMonitor.isConnected();\r\n  },\r\n\r\n  /**\r\n   * Add network status listener\r\n   * \r\n   * @param {Function} listener - Listener function\r\n   */\r\n  onNetworkChange: (listener) => {\r\n    networkMonitor.addListener(listener);\r\n  }\r\n};\r\n\r\nexport default authService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}