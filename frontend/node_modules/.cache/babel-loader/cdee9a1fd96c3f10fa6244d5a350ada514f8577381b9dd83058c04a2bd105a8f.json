{"ast":null,"code":"// frontend/src/components/ProtectedRoute.js\nimport React,{useContext,useEffect,useState}from'react';import{Navigate,Outlet,useLocation}from'react-router-dom';// Import PropTypes\nimport{AuthContext}from'../context/AuthContext';import LoadingSpinner from'../components/LoadingSpinner';import apiService from'../services/api';// Import the enhanced apiService\n/**\r\n * Production-grade Protected Route component\r\n * Features:\r\n * - Authentication checking\r\n * - Role-based access control\r\n * - Loading states\r\n * - Session validation\r\n * - Redirect handling\r\n * - Error boundary integration\r\n */import{jsx as _jsx}from\"react/jsx-runtime\";const ProtectedRoute=_ref=>{let{children,requiredRoles=[],redirectPath='/login',requireVerifiedEmail=false,showLoading=true}=_ref;const{user,isLoading,isAuthenticated,logout}=useContext(AuthContext);const location=useLocation();const[isValidatingSession,setIsValidatingSession]=useState(false);const[validationError,setValidationError]=useState(null);// Validate session with backend on component mount and when auth state changes\nuseEffect(()=>{let isMounted=true;const validateSession=async()=>{// Skip validation if no token exists\nconst token=localStorage.getItem('token')||sessionStorage.getItem('token');if(!token){if(isMounted){setValidationError('NO_TOKEN');}return;}if(isMounted){setIsValidatingSession(true);setValidationError(null);}try{// Optional: Validate session with backend\n// This can be enabled for extra security\nif(process.env.REACT_APP_ENABLE_SESSION_VALIDATION==='true'){await apiService.testConnection();// Or call a specific session validation endpoint\n// await apiService.get('/auth/validate-session');\n}if(isMounted){setValidationError(null);}}catch(error){if(isMounted){var _error$response;console.error('Session validation failed:',error);setValidationError('SESSION_INVALID');// Auto-logout on session validation failure\nif(error.code==='AUTH_REQUIRED'||((_error$response=error.response)===null||_error$response===void 0?void 0:_error$response.status)===401){setTimeout(()=>{if(isMounted){logout();}},1000);}}}finally{if(isMounted){setIsValidatingSession(false);}}};if(isAuthenticated&&user){validateSession();}return()=>{isMounted=false;};},[isAuthenticated,user,logout]);// Check if user has required roles\nconst hasRequiredRole=()=>{if(!requiredRoles||requiredRoles.length===0)return true;if(!user||!user.roles)return false;return requiredRoles.some(role=>user.roles.includes(role));};// Check if email verification is required and user is verified\nconst isEmailVerified=()=>{if(!requireVerifiedEmail)return true;if(!user)return false;// Check based on your user model structure\nreturn user.isEmailVerified||user.emailVerified||user.verified||true;};// Show loading state\nif(isLoading||isValidatingSession){if(showLoading){return/*#__PURE__*/_jsx(\"div\",{className:\"flex items-center justify-center min-h-screen bg-gray-50\",\"data-testid\":\"protected-route-loading\",children:/*#__PURE__*/_jsx(LoadingSpinner,{size:\"lg\",message:isValidatingSession?\"Validating session...\":\"Loading...\"})});}return null;}// Handle validation errors\nif(validationError==='SESSION_INVALID'){// Store the attempted location for redirect after login\nsessionStorage.setItem('redirectAfterLogin',location.pathname+location.search);return/*#__PURE__*/_jsx(Navigate,{to:\"\".concat(redirectPath,\"?session=invalid&redirect=\").concat(encodeURIComponent(location.pathname)),replace:true,state:{from:location}});}// Redirect to login if not authenticated\nif(!isAuthenticated||!user){// Store the attempted location for redirect after login\nsessionStorage.setItem('redirectAfterLogin',location.pathname+location.search);return/*#__PURE__*/_jsx(Navigate,{to:\"\".concat(redirectPath,\"?redirect=\").concat(encodeURIComponent(location.pathname)),replace:true,state:{from:location}});}// Check email verification\nif(!isEmailVerified()){return/*#__PURE__*/_jsx(Navigate,{to:\"/verify-email\",replace:true,state:{from:location,message:\"Please verify your email address to access this page.\"}});}// Check role-based access\nif(!hasRequiredRole()){// Log unauthorized access attempt (security monitoring)\nconsole.warn(\"Unauthorized access attempt by user \".concat(user.id,\" to \").concat(location.pathname));// Optionally send to security monitoring\nif(process.env.NODE_ENV==='production'){// apiService.post('/security/access-denied', {\n//   userId: user.id,\n//   path: location.pathname,\n//   requiredRoles,\n//   userRoles: user.roles,\n//   timestamp: new Date().toISOString()\n// }).catch(() => {});\n}return/*#__PURE__*/_jsx(Navigate,{to:\"/unauthorized\",replace:true,state:{from:location,requiredRoles,userRoles:user.roles}});}// Render children or outlet\nreturn children?children:/*#__PURE__*/_jsx(Outlet,{});};// Production-grade PropTypes with documentation\nProtectedRoute.defaultProps={requiredRoles:[],redirectPath:'/login',requireVerifiedEmail:false,showLoading:true};// Export with display name for debugging\nProtectedRoute.displayName='ProtectedRoute';export default ProtectedRoute;","map":{"version":3,"names":["React","useContext","useEffect","useState","Navigate","Outlet","useLocation","AuthContext","LoadingSpinner","apiService","jsx","_jsx","ProtectedRoute","_ref","children","requiredRoles","redirectPath","requireVerifiedEmail","showLoading","user","isLoading","isAuthenticated","logout","location","isValidatingSession","setIsValidatingSession","validationError","setValidationError","isMounted","validateSession","token","localStorage","getItem","sessionStorage","process","env","REACT_APP_ENABLE_SESSION_VALIDATION","testConnection","error","_error$response","console","code","response","status","setTimeout","hasRequiredRole","length","roles","some","role","includes","isEmailVerified","emailVerified","verified","className","size","message","setItem","pathname","search","to","concat","encodeURIComponent","replace","state","from","warn","id","NODE_ENV","userRoles","defaultProps","displayName"],"sources":["C:/Users/KADZ-TECH/Documents/dev/it-support-system/frontend/src/components/ProtectedRoute.js"],"sourcesContent":["// frontend/src/components/ProtectedRoute.js\r\nimport React, { useContext, useEffect, useState } from 'react';\r\nimport { Navigate, Outlet, useLocation } from 'react-router-dom';\r\nimport PropTypes from 'prop-types'; // Import PropTypes\r\nimport { AuthContext } from '../context/AuthContext';\r\nimport LoadingSpinner from '../components/LoadingSpinner';\r\nimport apiService from '../services/api'; // Import the enhanced apiService\r\n\r\n/**\r\n * Production-grade Protected Route component\r\n * Features:\r\n * - Authentication checking\r\n * - Role-based access control\r\n * - Loading states\r\n * - Session validation\r\n * - Redirect handling\r\n * - Error boundary integration\r\n */\r\n\r\nconst ProtectedRoute = ({ \r\n  children, \r\n  requiredRoles = [], \r\n  redirectPath = '/login',\r\n  requireVerifiedEmail = false,\r\n  showLoading = true \r\n}) => {\r\n  const { user, isLoading, isAuthenticated, logout } = useContext(AuthContext);\r\n  const location = useLocation();\r\n  const [isValidatingSession, setIsValidatingSession] = useState(false);\r\n  const [validationError, setValidationError] = useState(null);\r\n\r\n  // Validate session with backend on component mount and when auth state changes\r\n  useEffect(() => {\r\n    let isMounted = true;\r\n    \r\n    const validateSession = async () => {\r\n      // Skip validation if no token exists\r\n      const token = localStorage.getItem('token') || sessionStorage.getItem('token');\r\n      if (!token) {\r\n        if (isMounted) {\r\n          setValidationError('NO_TOKEN');\r\n        }\r\n        return;\r\n      }\r\n      \r\n      if (isMounted) {\r\n        setIsValidatingSession(true);\r\n        setValidationError(null);\r\n      }\r\n      \r\n      try {\r\n        // Optional: Validate session with backend\r\n        // This can be enabled for extra security\r\n        if (process.env.REACT_APP_ENABLE_SESSION_VALIDATION === 'true') {\r\n          await apiService.testConnection();\r\n          // Or call a specific session validation endpoint\r\n          // await apiService.get('/auth/validate-session');\r\n        }\r\n        \r\n        if (isMounted) {\r\n          setValidationError(null);\r\n        }\r\n      } catch (error) {\r\n        if (isMounted) {\r\n          console.error('Session validation failed:', error);\r\n          setValidationError('SESSION_INVALID');\r\n          \r\n          // Auto-logout on session validation failure\r\n          if (error.code === 'AUTH_REQUIRED' || error.response?.status === 401) {\r\n            setTimeout(() => {\r\n              if (isMounted) {\r\n                logout();\r\n              }\r\n            }, 1000);\r\n          }\r\n        }\r\n      } finally {\r\n        if (isMounted) {\r\n          setIsValidatingSession(false);\r\n        }\r\n      }\r\n    };\r\n    \r\n    if (isAuthenticated && user) {\r\n      validateSession();\r\n    }\r\n    \r\n    return () => {\r\n      isMounted = false;\r\n    };\r\n  }, [isAuthenticated, user, logout]);\r\n\r\n  // Check if user has required roles\r\n  const hasRequiredRole = () => {\r\n    if (!requiredRoles || requiredRoles.length === 0) return true;\r\n    if (!user || !user.roles) return false;\r\n    \r\n    return requiredRoles.some(role => user.roles.includes(role));\r\n  };\r\n\r\n  // Check if email verification is required and user is verified\r\n  const isEmailVerified = () => {\r\n    if (!requireVerifiedEmail) return true;\r\n    if (!user) return false;\r\n    \r\n    // Check based on your user model structure\r\n    return user.isEmailVerified || user.emailVerified || user.verified || true;\r\n  };\r\n\r\n  // Show loading state\r\n  if (isLoading || isValidatingSession) {\r\n    if (showLoading) {\r\n      return (\r\n        <div className=\"flex items-center justify-center min-h-screen bg-gray-50\" data-testid=\"protected-route-loading\">\r\n          <LoadingSpinner \r\n            size=\"lg\" \r\n            message={isValidatingSession ? \"Validating session...\" : \"Loading...\"}\r\n          />\r\n        </div>\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // Handle validation errors\r\n  if (validationError === 'SESSION_INVALID') {\r\n    // Store the attempted location for redirect after login\r\n    sessionStorage.setItem('redirectAfterLogin', location.pathname + location.search);\r\n    \r\n    return (\r\n      <Navigate \r\n        to={`${redirectPath}?session=invalid&redirect=${encodeURIComponent(location.pathname)}`} \r\n        replace \r\n        state={{ from: location }}\r\n      />\r\n    );\r\n  }\r\n\r\n  // Redirect to login if not authenticated\r\n  if (!isAuthenticated || !user) {\r\n    // Store the attempted location for redirect after login\r\n    sessionStorage.setItem('redirectAfterLogin', location.pathname + location.search);\r\n    \r\n    return (\r\n      <Navigate \r\n        to={`${redirectPath}?redirect=${encodeURIComponent(location.pathname)}`} \r\n        replace \r\n        state={{ from: location }}\r\n      />\r\n    );\r\n  }\r\n\r\n  // Check email verification\r\n  if (!isEmailVerified()) {\r\n    return (\r\n      <Navigate \r\n        to=\"/verify-email\" \r\n        replace \r\n        state={{ \r\n          from: location,\r\n          message: \"Please verify your email address to access this page.\"\r\n        }}\r\n      />\r\n    );\r\n  }\r\n\r\n  // Check role-based access\r\n  if (!hasRequiredRole()) {\r\n    // Log unauthorized access attempt (security monitoring)\r\n    console.warn(`Unauthorized access attempt by user ${user.id} to ${location.pathname}`);\r\n    \r\n    // Optionally send to security monitoring\r\n    if (process.env.NODE_ENV === 'production') {\r\n      // apiService.post('/security/access-denied', {\r\n      //   userId: user.id,\r\n      //   path: location.pathname,\r\n      //   requiredRoles,\r\n      //   userRoles: user.roles,\r\n      //   timestamp: new Date().toISOString()\r\n      // }).catch(() => {});\r\n    }\r\n    \r\n    return (\r\n      <Navigate \r\n        to=\"/unauthorized\" \r\n        replace \r\n        state={{ \r\n          from: location,\r\n          requiredRoles,\r\n          userRoles: user.roles\r\n        }}\r\n      />\r\n    );\r\n  }\r\n\r\n  // Render children or outlet\r\n  return children ? children : <Outlet />;\r\n};\r\n\r\n// Production-grade PropTypes with documentation\r\nProtectedRoute.propTypes = {\r\n  /**\r\n   * Child components to render when authenticated\r\n   */\r\n  children: PropTypes.node,\r\n  \r\n  /**\r\n   * Array of required roles to access this route\r\n   * If empty array, only authentication is required\r\n   */\r\n  requiredRoles: PropTypes.arrayOf(PropTypes.string),\r\n  \r\n  /**\r\n   * Path to redirect to when not authenticated\r\n   * @default '/login'\r\n   */\r\n  redirectPath: PropTypes.string,\r\n  \r\n  /**\r\n   * Whether email verification is required\r\n   * @default false\r\n   */\r\n  requireVerifiedEmail: PropTypes.bool,\r\n  \r\n  /**\r\n   * Whether to show loading spinner during authentication check\r\n   * @default true\r\n   */\r\n  showLoading: PropTypes.bool,\r\n};\r\n\r\nProtectedRoute.defaultProps = {\r\n  requiredRoles: [],\r\n  redirectPath: '/login',\r\n  requireVerifiedEmail: false,\r\n  showLoading: true,\r\n};\r\n\r\n// Export with display name for debugging\r\nProtectedRoute.displayName = 'ProtectedRoute';\r\n\r\nexport default ProtectedRoute;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}